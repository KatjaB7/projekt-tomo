[
  {
    "pk": 165, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Na volitvah volijo stare\u0161ino. Vsak izmed predstavnikov skupnosti mu\r\n# lahko podeli dolo\u010deno \u0161tevilo glasov (celo \u0161tevilo, razli\u010dni predstavniki\r\n# lahko imajo razli\u010dno \u0161tevilo glasov), pri \u010demer so ti glasovi lahko tudi\r\n# negativni (\u010de z njim niso zadovoljni). Te glasove dobimo v obliki seznama.\r\n# Sestavi metodo `stanje(seznam)`, ki vrne seznam glasov, ki jih ima \r\n# stare\u0161ina po glasovanju vsakega predstavnika.\r\n", 
      "solution": "def stanje(s):\r\n    return [sum(s[:i+1]) for i in range(len(s))]\r\n", 
      "trial": "def trial(source):\r\n    if check_function('stanje', 1):\r\n        _equal('stanje([1, 2, -3, 1])', [1, 3, 0, 1])\r\n        _equal('stanje([1, -5, -2, 3, 4])', [1, -4, -6, -3, 1])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 42, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavite funkcijo `levo(s, k)`, ki iz seznama `s` sestavi in vrne nov\r\n# seznam, ki predstavlja kro\u017eni pomik prvotnega seznama v levo za `k`\r\n# mest.", 
      "solution": "def levo(s, k):\r\n    return s[k:] + s[:k]", 
      "trial": "def trial(source):\r\n    _equal('levo([1, 2, 3, 4, 5, 6, 7], 3)', [4, 5, 6, 7, 1, 2, 3])\r\n    _equal('levo([1, 2, 3, 4, 5, 6, 7], 1)', [2, 3, 4, 5, 6, 7, 1])\r\n    _equal('levo([1, 2, 3, 4, 5, 6, 7], 0)', [1, 2, 3, 4, 5, 6, 7])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 83, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "#Sestavi funkcijo `kocka`, ki simulira met kocke pri igri \u010dlovek ne jezi se.\r\n#Pri tem si lahko pomaga\u0161 s funkcijo `randint` iz knji\u017enice `random`.\r\n#Funkcija naj vra\u010da cela \u0161tevila.", 
      "solution": "def kocka():\r\n    return random.randint(1,6)", 
      "trial": "def trial(source):\r\n    if check_function('kocka', 0):\r\n        for i in range(6):\r\n            _equal('1 <= kocka() <= 6', True)\r\n        _equal('isinstance(kocka(),int)',True)\r\n        _equal('nakljucna(kocka)',[1, 6, 5, 2, 3, 3, 4, 5, 1, 1])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 49, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavi funkcijo tabeliraj, ki tabelira vrednosti funkcije sin(x), kjer x prete\u010de vrednosti\r\n# od a do b s korakom k. \u0160tevila a, b in k so realna \u0161tevila, ki jih funkcija dobi za parametre.\r\n# Vrednosti x naj bodo izpisane na 2 decimalki, vrednosti funkcije pa na 4 decimalke. Med\r\n# \u0161tevili in sredinsko \u010drto naj bo en presledek razmika, \u0161tevila pa naj bodo skupaj \u0161iroka\r\n# 7 znakov\r\n# Primer: \r\n#    >>> tabeliraj(-1.54, 0, 0.62)\r\n#        x   |  sin(x)\r\n#    --------+---------\r\n#      -1.54 | -0.9995\r\n#      -0.92 | -0.7956\r\n#      -0.30 | -0.2955", 
      "solution": "def tabeliraj(a, b, k):\r\n    # Izpisemo prvi dve vrstici\r\n    print('    x   |  sin(x)')\r\n    print('--------+---------')\r\n    while a <= b:\r\n        # Izpisujemo formatirano\r\n        # Razlaga {0:7.2f}:\r\n        # 0 - tu naj stoji 0-ti element seznama, ki smo ga zapisali v format\r\n        # : - kar sledi dvopicju je oblika izpisa\r\n        # 7 - koliko mest naj zaseda izpis danega elementa\r\n        # .2 - koliko decimalnih mest stevila naj se izpise\r\n        # f - poravnava glede na decimalno vejico (float)\r\n        print('{0:7.2f} | {1:7.4f}'.format(a, sin(a)))\r\n        a += k", 
      "trial": "def trial(source):\r\n   global _warn\r\n   tabela=izpis(tabeliraj,-1.54, 0, 0.62)\r\n   pravilno='   x   |  sin(x)\\n--------+---------\\n  -1.54 | -0.9995\\n  -0.92 | -0.7956\\n  -0.30 | -0.2955'\r\n   if tabela.strip() != pravilno.strip():\r\n      _warn('Tabela je napa\u010dne oblike. Pravilno je\\n'+pravilno+'\\n'+'Va\u0161 program vrne\\n'+tabela)\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 9
    }
  }, 
  {
    "pk": 115, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavite funkcijo `dva()`, ki vra\u010da 2", 
      "solution": "def dva():\r\n  return 2", 
      "trial": "def trial(source):\r\n  _equal('dva()', 2)\r\n  yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 15
    }
  }, 
  {
    "pk": 99, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# V seznamu imamo podatke o prilivih in odlivih s teko\u010dega ra\u010duna.\r\n# Pozitivna \u0161tevila predstavljajo priliv (polog denarja),\r\n# negativna pa dvig.\r\n# Vsak element seznama predstavlja en dan.\r\n# \u010ce na nek dan ni prilivov ali dvigov, je vrednost v seznamu 0.\r\n# Privzemite, da je na za\u010detku stanje na ra\u010dunu 0.\r\n#\r\n# Sestavite funkcijo `koncno_stanje(spremembe)`, ki iz danega seznama\r\n# prilivov in odlivov izra\u010duna kon\u010dno stanje.", 
      "solution": "def koncno_stanje(spremembe):\r\n    return sum(spremembe)", 
      "trial": "def trial(source):\r\n    if check_function('koncno_stanje', 1):\r\n        _equal('koncno_stanje([1, 2, 3])', 6)\r\n        _equal('koncno_stanje([1, -5, -20, 30])', 6)\r\n        _equal('koncno_stanje([0])', 0)\r\n        _equal('koncno_stanje([10, -5, 20, -6])', 19)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 134, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# V seznamu imamo podatke o padavinah in izhlapevanju po posameznih\r\n# dnevih. Pozitivna \u0161tevila predstavljajo koli\u010dino de\u017eja (v mm),\r\n# negativna pa koli\u010dino izhlapele vode (tudi v mm).\r\n# Sestavi funkcijo `stanja(seznam)`, ki iz danega seznama tvori\r\n# seznam stanj, tj. delne vsote od prvega dne naprej. \u010ce je podani seznam\r\n# prazen, naj funkcija vrne prazen seznam.", 
      "solution": "def stanja(s):\r\n    return [sum(s[:i+1]) for i in range(len(s))]", 
      "trial": "def trial(source):\r\n    if check_function('stanja', 1):\r\n        _equal('stanja([1, 2, 3])', [1, 3, 6])\r\n        _equal('stanja([1, -5, -20, 30])', [1, -4, -24, 6])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 58, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "#Sestavi funkcijo `najkrajsi`, ki v danem seznamu seznamov poi\u0161\u010de in vrne\r\n#najkraj\u0161i seznam. \u010ce je seznam prazen, naj funkcija vrne vrednost `None`.\r\n#Primer:\r\n#    >>> najkrajsi([])\r\n#    None\r\n#    >>> najkrajsi([[3, 6], [17, 5, 2], [5], [6, 3]])\r\n#    [5]", 
      "solution": "def najkrajsi(s):\r\n    if len(s) == 0: return None\r\n    m = s[0]\r\n    for t in s:\r\n        if len(t) < len(m): m = t\r\n    return m", 
      "trial": "def trial(source):\r\n    _equal('najkrajsi([])', None)\r\n    _equal('najkrajsi([[3, 6], [17, 5, 2], [5], [6, 3]])', [5])\r\n    _equal('najkrajsi([[1, 2], [], [4, 5, 6, 7]])', [])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 75, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "#Sestavi funkcijo `najkrajsiNabor`, ki v danem seznamu naborov poi\u0161\u010de in vrne\r\n#najkraj\u0161i nabor. \u010ce je seznam prazen, naj funkcija vrne prazen nabor `()`.\r\n#Primer:\r\n#    >>> najkrajsiNabor([])\r\n#    ()\r\n#    >>> najkrajsiNabor([(3, 6), (17, 5, 2), (5,), (6, 3)])\r\n#    (5,)", 
      "solution": "def najkrajsiNabor(s):\r\n    if len(s) == 0: return ()\r\n    m = s[0]\r\n    for t in s:\r\n        if len(t) < len(m): m = t\r\n    return m", 
      "trial": "def trial(source):\r\n    if check_function('najkrajsiNabor', 1):\r\n      _equal('najkrajsiNabor([])', ())\r\n      _equal('najkrajsiNabor([(3, 6), (17, 5, 2), (5,), (6, 3)])', (5,))\r\n      _equal('najkrajsiNabor([(1, 2), (), (4, 5, 6, 7)])', ())\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 197, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Borzni posrednik opazuje gibanje vrednosti delnice na borzi. Za vsak\n# dan si zapi\u0161e razliko med trenutno vrednostjo delnice\n# in vrednostjo delnice prej\u0161njega dne. Tako pozitivna \u0161tevila povejo,\n# da je vrednost delnice zrasla, negativna pa,\tda je vrednost padla.\n# Sestavi funkcijo 'vrednostDelnice', ki iz danega seznama dvigov in\n# padcev sestavi seznam vrednosti delnice po dnevih.\n# Kot parametra naj dobi za\u010detno vrednost delnice in seznam dvigov in padcev.\n# Primer:\n#    >>> vrednostDelnice(100, [-5, 10, -5, 10])\n#    [100, 95, 105, 100, 110]", 
      "solution": "def vrednostDelnice(zacetnaVrednost, padci):\n    trenutnaVrednost = zacetnaVrednost\n    vrednosti = [trenutnaVrednost]\n    for padec in padci:\n        trenutnaVrednost += padec\n        vrednosti.append(trenutnaVrednost)\n    return vrednosti", 
      "trial": "def trial(source):\n    if check_function('vrednostDelnice', 2):\n        _equal('vrednostDelnice(100, [-5, 10, -5, 10])', [100, 95, 105, 100, 110])\n        _equal('vrednostDelnice(0, [1, -5, -20, 30])', [0, 1, -4, -24, 6])\n        _equal('vrednostDelnice(30, [-3, 9, 12, 6, -13, -15, -14, -4, 0, -11])', [30, 27, 36, 48, 54, 41, 26, 12, 8, 8, -3])\n        _equal('vrednostDelnice(2000, [-30, 100, -50, -70, -130,30, 70, 230, 100, -10])', [2000, 1970, 2070, 2020, 1950, 1820, 1850, 1920, 2150, 2250, 2240])\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 20, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "#Fibonaccijevo zaporedje reda n je zaporedje, kjer naslednji \u010dlen izra\u010dunamo kot vsoto\r\n#zadnjih n \u010dlenov. Namesto dveh moramo seveda podati prvih n \u010dlenov zaporedja.\r\n#Sestavi funkcijo fib, ki izra\u010duna in vrne zahtevani \u010dlen takega zaporedja.\r\n#Funkcija naj kot prvi parameter dobi zaporedno \u0161tevilko iskanega \u010dlena,\r\n#potem pa \u0161e prvih n \u010dlenov, ki dolo\u010dajo zaporedje. Primer:\r\n#    >>> fib(2, 1, 3, 5)\r\n#    3\r\n#    >>> fib(10, 1, 3, 5, 8)\r\n#    451", 
      "solution": "def fib(n, *s):\r\n    red = len(s)\r\n    if n <= red: return s[n - 1]\r\n    for i in range(red, n): s = s[1:] + (sum(s), )\r\n    return s[-1]", 
      "trial": "def trial(source):\r\n   _equal('fib(2, 1, 3, 5)',3)\r\n   _equal('fib(10, 1, 3, 5, 8)',451)\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 91, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavi funkcijo html2text, ki bo besedilo iz datoteke HTML\r\n# (kon\u010dnica .html) prepisala na datoteko TXT (kon\u010dnica txt),\r\n# pri \u010demer bo odstranila vse zna\u010dke.\r\n# Za\u010detek in konec zna\u010dke nista nujno v isti vrstici.\r\n# Datoteki naj imata enako ime, razlikujeta se samo v kon\u010dnici.\r\n# Funkcija naj za parameter dobi ime datoteke brez kon\u010dnice.\r\n# Zna\u010dka se za\u010dne z znakom '<' in kon\u010da z znakom '>'.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Primer:\r\n# Vhodna datoteka:\r\n# \r\n#     <h1>Napoved vremena</h1>\r\n#     <p>Jutri bo <i><b>lepo</b></i> vreme.\r\n#     Ve\u010d o vremenu preberite <a\r\n#     href=\"napoved.html\">tukaj</a>.</p>\r\n#\r\n# Izhodna datoteka:\r\n#\r\n#     Napoved vremena\r\n#     Jutri bo lepo vreme.\r\n#     Ve\u010d o vremenu preberite tukaj.", 
      "solution": "def html2text(file):\r\n    infile = open(file + '.html', 'r')\r\n    outfile = open(file + '.txt', 'w')\r\n    znacka = False\r\n    for row in infile:\r\n        outRow = \"\"\r\n        for znak in row:\r\n            if znak in '<>': znacka = not znacka\r\n            elif not znacka: outRow += znak\r\n        outfile.write(outRow)\r\n    outfile.close()", 
      "trial": "def trial(source):\r\n    if check_function(\"html2text\", 1):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 275, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavite funkcijo `praviDelitelji(n)`, ki vrne seznam vseh pravih\r\n# deliteljev \u0161tevila `n`.", 
      "solution": "def praviDelitelji(n):\r\n    return [i for i in range(1, n) if n % i == 0]", 
      "trial": "def trial(source):\r\n    if check_function('praviDelitelji', 1):\r\n        _equal('praviDelitelji(19)', [1])\r\n        _equal('praviDelitelji(28)', [1, 2, 4, 7, 14])\r\n        _equal('praviDelitelji(42)', [1, 2, 3, 6, 7, 14, 21])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 245, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Janez rad igra ruleto. Ker pa je previden igralec, stavi vedno samo\r\n# na rde\u010de ali \u010drno in vsaki\u010d stavi 1 \u017eeton. Rezultate zapisuje v\r\n# seznam (kot vrednosti +1 ali -1).\r\n# Sestavi funkcijo 'kolikoDenarja', ki ugotovi, koliko denarja ima Janez na koncu.\r\n# Metoda naj sprejme dva parametra: za\u010detno koli\u010dino denarja in seznam\r\n# rezultatov stav.\r\n# Primer:\r\n#    >>> kolikoDenarja(100, [-1, 1, 1, 1])\r\n#    102", 
      "solution": "def kolikoDenarja(zacetnaVrednost, padci):\r\n    trenutnaVrednost = zacetnaVrednost\r\n    vrednosti = [trenutnaVrednost]\r\n    for padec in padci:\r\n        trenutnaVrednost += padec\r\n        vrednosti.append(trenutnaVrednost)\r\n    return trenutnaVrednost", 
      "trial": "def trial(source):\r\n    if check_function('kolikoDenarja', 2):\r\n        _equal('kolikoDenarja(100, [-1, 1, 1, 1])', 102)\r\n        _equal('kolikoDenarja(10, [-1, -1, -1, 1, 1, -1, -1, -1, -1, -1])', 4)\r\n        _equal('kolikoDenarja(10, [-1, 1, -1, -1, 1, 1, -1, 1, 1, 1])', 12)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 27, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Napi\u0161ite funkcijo `vsotaPotenc(n, k)`, ki izra\u010duna vsoto\r\n#   $$1^k + 2^k + ... + n^k$$", 
      "solution": "def vsotaPotenc(n, k):\r\n    vsota = 0\r\n    i = 0\r\n    while i < n:\r\n        i += 1\r\n        vsota += i ** k\r\n    return vsota", 
      "trial": "def trial(source):\r\n    if check_function(\"vsotaPotenc\", 2):\r\n        _equal('vsotaPotenc(3, 4)', 98)\r\n        _equal('vsotaPotenc(4, 3)', 100)\r\n        _equal('vsotaPotenc(6, 6)', 67171)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 1, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Petvrsti\u010dno smre\u010dico lahko v Pythonu izpi\u0161emo z naslednjim programom:\r\n#    print(\"*\")\r\n#    print(\"**\")\r\n#    print(\"***\")\r\n#    print(\"****\")\r\n#    print(\"*****\")\r\n# Sestavite program, ki izpi\u0161e osemvrsti\u010dno smre\u010dico.", 
      "solution": "print(\"*\")\r\nprint(\"**\")\r\nprint(\"***\")\r\nprint(\"****\")\r\nprint(\"*****\")\r\nprint(\"******\")\r\nprint(\"*******\")\r\nprint(\"********\")", 
      "trial": "def trial(source):\r\n    preveriSmrecico(izpis(source), 8 * [0], range(1, 9), \"*\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 21, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavi funkcijo kroga, ki dobi za parametre sredi\u0161\u010di in polmera dveh krogov ter preveri, ali sta kroga \r\n# lo\u010dena, se dotikata, ali pa imata skupno ve\u010d kot eno to\u010dko. Parametri metode bomo podani v \r\n# slede\u010dem vrstnem redu: $x_1$, $y_1$, $r_1$, $x_2$, $y_2$, $r_2$\r\n# (kjer je $x_i$ $x$-koordinata $i$-tega kroga).\r\n# Metoda naj za lo\u010dena kroga vrne 0, \u010de se dotikata naj vrne 1 in \u010de imata skupno ve\u010d kot eno to\u010dko naj \r\n# vrne 2.\r\n#    >>> kroga(3, 5, 2, 6, 7, 3)\r\n#    2\r\n#    >>> kroga(3, 5, 2, 8, 5, 3)\r\n#    1\r\n#    >>> kroga(3, 5, 2, 8, 7, 3)\r\n#    0", 
      "solution": "def kroga(x1,y1,r1,x2,y2,r2):\r\n  razdalja = (x1-x2)**2  + (y1-y2)**2\r\n  razdalja1 = (r1 + r2)**2\r\n  if razdalja > razdalja1:\r\n    return 0\r\n  elif razdalja == razdalja1:\r\n    return 1\r\n  else:\r\n    return 2\r\n", 
      "trial": "def trial(source):\r\n  podatki = [[random.randint(0, 10) for i in range(6)] for i in range(10)]\r\n  podatki.append([3,5,2,8,5,3])\r\n  if check_function(\"kroga\", 6):\r\n    for test in podatki:\r\n      test[2]=abs(test[2])\r\n      test[5]=abs(test[5])\r\n      razdalja = (test[0]-test[3])**2 + (test[1]-test[4])**2\r\n      res = 2\r\n      if razdalja > (test[2]+test[5])**2:\r\n        res = 0\r\n      elif razdalja ==  (test[2]+test[5])**2:\r\n        res = 1\r\n      _equal(\"kroga({0}, {1}, {2}, {3}, {4}, {5})\".format(test[0], test[1], test[2], test[3], test[4], test[5]), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 35, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavite funkcijo `papagaj(niz)`, ki dani niz prevede v papagaj\u0161\u010dino\r\n# (za vsakim samoglasnikom doda \u010drko `p` in \u0161e enkrat isti (mali)\r\n# samoglasnik.\r\n", 
      "solution": "def papagaj(niz):\r\n    papagaj = ''\r\n    for z in niz:\r\n        papagaj += z\r\n        mala = z.lower()\r\n        if mala in 'aeiou':\r\n            papagaj += 'p' + mala\r\n    return papagaj\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"papagaj\", 1):\r\n        _equal('papagaj(\"aeiou\")', 'apaepeipiopoupu')\r\n        _equal('papagaj(\"Anka Betka Cvetka\")', 'Apankapa Bepetkapa Cvepetkapa')\r\n        _equal('papagaj(\"Perica re\u017ee raci rep.\")', 'Peperipicapa repe\u017eepe rapacipi repep.')\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 117, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavi funkcijo naloga1a, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga1a(s):\r\n    return [sum(s[:i+1]) for i in range(len(s))]\r\n", 
      "trial": "def trial(source):\r\n    if check_function('naloga1a', 1):\r\n        _equal('naloga1a([1.2, 2.3, 3.1])', [1.2, 3.5, 6.6])\r\n        _equal('naloga1a([1, -5.2, -2.0, 3])', [1, -4.2, -6.2, -3.2])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 133, 
    "model": "problem.part", 
    "fields": {
      "_order": 0, 
      "description": "# Sestavi funkcijo `povprecje(seznam)`, ki izra\u010duna povpre\u010dje podanega\r\n# seznama realnih ali celih \u0161tevil. \u010ce je seznam prazen, naj funkcija\r\n# vrne 0.\r\n", 
      "solution": "def povprecje(seznam):\r\n    if len(seznam) == 0: return 0\r\n    return sum(seznam)/len(seznam)", 
      "trial": "def trial(source):\r\n    if check_function('povprecje', 1):\r\n        _equal('povprecje([1, 2, 3])', 2)\r\n        _equal('povprecje([1, -5, -20, 30])', 1.5)\r\n        _equal('povprecje([])', 0)\r\n        _equal('round(povprecje([1.3,-4.6, 2.7, 12]),2)', 2.85)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 198, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo 'padci' , ki iz danega seznama vrednosti delnice po dnevih\n# sestavi nov seznam dvigov in padcev delnice.\n# Primer:\n#    >>> padci([100, 95, 105, 100, 110])\n#    [-5, 10, -5, 10]", 
      "solution": "def padci(vrednosti):\n    return [vrednosti[i+1]-vrednosti[i] for i in range(len(vrednosti)-1)]", 
      "trial": "def trial(source):\n    if check_function('padci', 1):\n        _equal('padci([100, 95, 105, 100, 110])', [-5, 10, -5, 10])\n        _equal('padci([30, 27, 36, 48, 54, 41, 26, 12, 8, 8, -3])', [-3, 9, 12, 6, -13, -15, -14, -4, 0, -11])\n        \n    yield\n    pass", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 118, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo naloga1b, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga1b(s):\r\n    s2=naloga1a(s)\r\n    return (min(s2),max(s2))", 
      "trial": "def trial(source):\r\n    if check_function('naloga1b', 1):\r\n        _equal('naloga1b([1.2, 2.3, 3.1])', (1.2, 6.6))\r\n        _equal('naloga1b([1, -5.2, -2.0, 3])', (-6.2, 1))\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 43, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `desno(s, k)`, ki iz seznama `s` sestavi in vrne\r\n# nov seznam, ki predstavlja kro\u017eni pomik prvotnega seznama v desno za\r\n# `k` mest.", 
      "solution": "def desno(s, k):\r\n    return s[-k:] + s[:-k]", 
      "trial": "def trial(source):\r\n    _equal('desno([1, 2, 3, 4, 5, 6, 7], 3)', [5, 6, 7, 1, 2, 3, 4])\r\n    _equal('desno([1, 2, 3, 4, 5, 6, 7], 1)', [7, 1, 2, 3, 4, 5, 6])\r\n    _equal('desno([1, 2, 3, 4, 5, 6, 7], 0)', [1, 2, 3, 4, 5, 6, 7])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 116, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `tri()`, ki vra\u010da 3", 
      "solution": "def tri():\r\n  return 3", 
      "trial": "def trial(source):\r\n  _equal('tri()', 3)\r\n  yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 15
    }
  }, 
  {
    "pk": 36, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `celostevilski(sprehod)`, ki sprejme niz, ki\r\n# predstavlja sprehod po celih \u0161tevilih, in vrne \u0161tevilo, v katerem se\r\n# sprehod kon\u010da.\r\n#\r\n# Sprehod po celih \u0161tevilih se za\u010dne v \u0161tevilu 0, predstavimo pa ga z\r\n# nizem, sestavljenim iz znakov `+` in `-`. Na ostale znake v nizu se\r\n# ne oziramo.\r\n", 
      "solution": "def celostevilski(sprehod):\r\n    x = 0\r\n    for korak in sprehod:\r\n        if korak == '+':\r\n            x += 1\r\n        elif korak == '-':\r\n            x -= 1\r\n    return x\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"celostevilski\", 1):\r\n        _equal('celostevilski(\"+++-+---+++-\")', 2)\r\n        _equal('celostevilski(\"----++----\")', -6)\r\n        _equal('celostevilski(\"\")', 0)\r\n        _equal('celostevilski(\"+===-@#$*!@--==+\")', -1)\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 246, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Janeza sedaj zanima, \u010de bi morda njegov zaslu\u017eek bil ve\u010dji, \u010de bi\r\n# prej nehal igrati. Sestavi funkcijo 'kolikoMax', ki poi\u0161\u010de maksimalni mo\u017eni\r\n# zaslu\u017eek, \u010de Janez ne igra do konca (torej, \u010de se po dolo\u010denem\r\n# \u0161tevilu korakov ustavi). Kot argument metoda sprejme seznam rezultatov stav.\r\n# Primer:\r\n#    >>> kolikoMax([1, 1, -1, -1, 1])\r\n#    2", 
      "solution": "def kolikoMax(zasluzki):\r\n    maxZasluzek = 0\r\n    for j in range(len(zasluzki)):\r\n        if sum(zasluzki[0:j+1])>maxZasluzek:\r\n            maxZasluzek = sum(zasluzki[0:j+1])\r\n    return maxZasluzek", 
      "trial": "def trial(source):\r\n    if check_function('kolikoMax', 1):\r\n        _equal('kolikoMax([1, 1, -1, -1, 1])', 2)\r\n        _equal('kolikoMax([-1, -1, -1, 1, 1, -1, -1, -1, -1, -1])', 0)\r\n        _equal('kolikoMax([-1, 1, -1, -1, 1, 1, -1, 1, 1, 1])', 2)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 100, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `stanja(spremembe)`, ki iz danega seznama\r\n# prilivov in odlivov ustvari seznam vmesnih stanj na ra\u010dunu.", 
      "solution": "def stanja(spremembe):\r\n    stanje = 0\r\n    stanja = [0]\r\n    for sprememba in spremembe:\r\n        stanje += sprememba\r\n        stanja.append(stanje)\r\n    return stanja", 
      "trial": "def trial(source):\r\n    if check_function('stanja', 1):\r\n        _equal('stanja([1, 2, 3])', [0, 1, 3, 6])\r\n        _equal('stanja([1, -5, -20, 30])', [0, 1, -4, -24, 6])\r\n        _equal('stanja([0])', [0, 0])\r\n        _equal('stanja([10, -5, 20, -6])', [0, 10, 5, 25, 19])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 50, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo tabelirajF(f,a,b,k), ki tabelira vrednosti f(x) podane funkcije f, kjer x prete\u010de\r\n# vrednosti od a do b s korakom k. \u0160tevila a, b in k so realna \u0161tevila, ki jih funkcija dobi za parametre.\r\n# Oblika izpisa naj bo enaka kot pri prej\u0161nji nalogi.\r\n# Primer: \r\n#    >>> tabelirajF(sin,-1.54, 0, 0.62)\r\n#        x   |  sin(x)\r\n#    --------+---------\r\n#      -1.54 | -0.9995\r\n#      -0.92 | -0.7956\r\n#      -0.30 | -0.2955\r\n# Za izpis imena funkcije lahko uporabite f.\\_\\_name\\_\\_", 
      "solution": "def tabelirajF(f,a, b, k):\r\n    # Izpisemo prvi dve vrstici\r\n    print('    x   |  {0}(x)'.format(f.__name__))\r\n    print('--------+---------')\r\n    while a <= b:\r\n        # Izpisujemo formatirano\r\n        # Razlaga {0:7.2f}:\r\n        # 0 - tu naj stoji 0-ti element seznama, ki smo ga zapisali v format\r\n        # : - kar sledi dvopicju je oblika izpisa\r\n        # 7 - koliko mest naj zaseda izpis danega elementa\r\n        # .2 - koliko decimalnih mest stevila naj se izpise\r\n        # f - poravnava glede na decimalno vejico (float)\r\n        print('{0:7.2f} | {1:7.4f}'.format(a, f(a)))\r\n        a += k", 
      "trial": "def trial(source):\r\n   global _warn\r\n   from math import sin\r\n   tabela=izpis2(tabelirajF,sin,-1.54, 0, 0.62)\r\n   pravilno='    x   |  sin(x)\\n--------+---------\\n  -1.54 | -0.9995\\n  -0.92 | -0.7956\\n  -0.30 | -0.2955'\r\n   if tabela.strip() !=pravilno.strip():\r\n      _warn('Tabela je napa\u010dne oblike. Pravilno je\\n'+pravilno+'\\n'+'Va\u0161 program vrne\\n'+tabela)\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 9
    }
  }, 
  {
    "pk": 28, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `harmonicna(n)`, ki izra\u010duna delno vsoto:\r\n#   $$1 + 1 / 2 + 1 / 3 + ... + 1 / n$$", 
      "solution": "def harmonicna(n):\r\n    return vsotaPotenc(n, -1)", 
      "trial": "def trial(source):\r\n    if check_function(\"harmonicna\", 1):\r\n        _equal('harmonicna(4)', 2.083333333333333)\r\n        _equal('harmonicna(10)', 2.9289682539682538)\r\n        _equal('harmonicna(40)', 4.278543038936376)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 59, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "#Sestavi funkcijo `dolzinaVektorja`, ki izra\u010duna in vrne do\u017eino podanega\r\n#vektorja. Primer:\r\n#    >>> dolzinaVektorja([1, 1])\r\n#    1.41421356237\r\n#    >>> dolzinaVektorja([1, 4, 2, -5])\r\n#    6.78232998313", 
      "solution": "def dolzinaVektorja(vec):\r\n    return sum([x ** 2 for x in vec]) ** 0.5", 
      "trial": "def trial(source):\r\n    _equal('round(dolzinaVektorja([1, 1]),7)',1.4142136)\r\n    _equal('round(dolzinaVektorja([1, 4, 2, -5]),7)',6.78233)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 150, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo `minmax(seznam)`, ki poi\u0161\u010de dneva, ko je bil vodostaj\r\n# najvi\u0161ji oz. najni\u017eji in ju vrne v obliki nabora. Privzemi, da je na\r\n# za\u010detku vodostaj 0 (glede na neko referen\u010dno oznako).", 
      "solution": "def minmax(s):\r\n    s = [0] + stanja(s)\r\n    mini = s.index(min(s))\r\n    maksi = s.index(max(s))\r\n    return (mini, maksi)", 
      "trial": "def trial(source):\r\n    if check_function('minmax', 1):\r\n        _equal('minmax([1, 2, 3])', (0, 3))\r\n        _equal('minmax([1, -5, -20, 30])', (3, 4))\r\n        _equal('minmax([10, -5, 20, -6])', (0, 3))\r\n    yield\r\n    pass", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 92, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Na datoteki je zapisanih ve\u010d vrstic podatkov, pri \u010demer so\r\n# podatki v isti vrstici lo\u010deni z vejicami.\r\n# Sestavi funkcijo tabela, ki bo podatke iz vhodne datoteke\r\n# prepisala v obliki tabele HTML na izhodno datoteko.\r\n# Vrstica na vhodni datoteki ustreza eni vrstici v tabeli.\r\n# Imeni datotek naj funkcija dobi za parametra.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Primer:\r\n# Vhod:  \r\n#     ena,dva,tri\r\n#     17,52,49.4,6\r\n#     abc,xyz\r\n#\r\n# Izhod:\r\n#     <table>\r\n#        <tr>\r\n#          <td> ena </td>\r\n#          <td> dva </td>\r\n#          <td> tri </td>\r\n#        </tr>\r\n#        <tr>\r\n#          <td> 17 </td>\r\n#          <td> 52 </td>\r\n#          <td> 49.4 </td>\r\n#          <td> 6 </td>\r\n#        </tr>\r\n#        <tr>\r\n#          <td> abc </td>\r\n#          <td> xyz </td>\r\n#        </tr>\r\n#      </table>\r\n#", 
      "solution": "def tabela(vhod, izhod):\r\n    with open(vhod) as f:\r\n        with open(izhod, 'w') as g:\r\n            print('<table>', file=g)\r\n            for vrstica in f:\r\n                print('  <tr>', file=g)\r\n                s = vrstica.strip().split(',')\r\n                for podatek in s:\r\n                    print('    <td>', podatek, '</td>', file=g)\r\n                print('  </tr>', file=g)\r\n            print('</table>', file=g)", 
      "trial": "def trial(source):\r\n    if check_function(\"tabela\", 2):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 135, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo `podseznam(seznam, zacetek, dolzina)`, ki vrne\r\n# podseznam danega seznama z danim za\u010detkom in dol\u017eino.\r\n# \u010ce je seznam prazen ali pa je za\u010detek neveljaven, naj funkcija vrne\r\n# prazen seznam.\r\n# Primer: `podseznam(['a','b','c','d','e'], 1, 3)` vrne `['b','c','d']`\r\n", 
      "solution": "def podseznam(seznam, i, dolzina):\r\n    d=len(seznam)\r\n    if i<0 or i>=d or dolzina < 0:\r\n        return []\r\n    return seznam[i:i+dolzina]", 
      "trial": "def trial(source):\r\n    if check_function('podseznam', 3):\r\n        _equal('podseznam([1, 2, 3, 4, 5], 1, 3)', [2, 3, 4])\r\n        _equal('podseznam([1, 2, 3, 4], 5, 1)', [])\r\n        _equal('podseznam([1, 2, 3, 4], 0, 4)', [1, 2, 3, 4])\r\n        _equal('podseznam([], 0, 1)', [])\r\n        _equal('podseznam([1, 2], -1, 0)', [])\r\n        _equal('podseznam([1, 2, 3], 1, -1)', [])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 84, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "#Sestavi funkcijo `histogram`, ki prika\u017ee rezultate simulacije\r\n#metanja kocke. Pri tem si pomagaj s funkcijo `kocka`. Funkcija naj\r\n#sprejme dva parametra. Prvi pove, kolikokrat naj simuliramo met kocke,\r\n#drugi (katerega privzeta vrednost je '*') pa znak, ki se naj uporabi\r\n#za izpis. Pri izpisu normaliziraj podatke tako, da bo imela vrstica z\r\n#najve\u010d zvezdicami (oz. znaki) 40 znakov.\r\n#Primer:\r\n#    >>> histogram(3000)\r\n#       1|*************************************\r\n#       2|***************************************\r\n#       3|**************************************\r\n#       4|****************************************\r\n#       5|***************************************\r\n#       6|***********************************", 
      "solution": "def histogram(n,z='*'):\r\n    meti = [0]*6\r\n    for i in range(n):\r\n        meti[kocka()-1] += 1\r\n    M=max(meti)\r\n    for i in range(6):\r\n        print('{0:4d}|{1}'.format(i+1,z*round(40*meti[i]/M)))", 
      "trial": "def trial(source):\r\n    if check_function('histogram', 2):\r\n        _equal('izpis(histogram,300)','   1|**********************************\\n   2|****************************************\\n   3|********************************\\n   4|**********************************\\n   5|********************************\\n   6|***************************************\\n')\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 2, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Program za izpis osemvrsti\u010dne smre\u010dice popravite tako, da na primer\r\n# namesto niza `\"*****\"` uporabite niz `5 * \"*\"`.", 
      "solution": "print(1 * \"*\")\r\nprint(2 * \"*\")\r\nprint(3 * \"*\")\r\nprint(4 * \"*\")\r\nprint(5 * \"*\")\r\nprint(6 * \"*\")\r\nprint(7 * \"*\")\r\nprint(8 * \"*\")", 
      "trial": "def trial(source):\r\n    preveriSmrecico(izpis(source), 8 * [0], range(1, 9), \"*\")\r\n    if \"**\" in re.sub(r'#.*', '', source):\r\n        _warn(\"V programu nastopata dve zaporedni zvezdici.\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 51, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "#Sestavi funkcijo, ki bo vrnila seznam prvih n \u010dlenov fibonaccijeva zaporedja vi\u0161jega reda.\r\n#Pomen parametrov naj bo enak, kot pri prej\u0161nji nalogi.\r\n#    >>> fibonacci(2, 1, 3, 5)\r\n#    [1, 3]\r\n#    >>> fibonacci(10, 1, 3, 5, 8)\r\n#    [1, 3, 5, 8, 17, 33, 63, 121, 234, 451]", 
      "solution": "def fibonacci(n, *s):\r\n    red = len(s)\r\n    if n <= red: return list(s[:n])\r\n    s = list(s)\r\n    for i in range(red, n): s.append(sum(s[-red:]))\r\n    return s", 
      "trial": "def trial(source):\r\n   _equal('fibonacci(2, 1, 3, 5)',[1, 3])\r\n   _equal('fibonacci(10, 1, 3, 5, 8)',[1, 3, 5, 8, 17, 33, 63, 121, 234, 451])\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 22, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi funkcijo trikotnik, ki dobi za parametre tri realna \u0161tevila ter preveri, ali obstaja trikotnik s takimi \r\n# dol\u017einami stranic. \u010ce obstaja, naj vrne dvojico (plo\u0161\u010dina, obseg), sicer pa naj vrne False. \r\n# Primer:\r\n#    >>> trikotnik(3, 4, 8)\r\n#    False\r\n#    >>> trikotnik(3, 4, 5)\r\n#    (12, 6.0)", 
      "solution": "def trikotnik(a, b, c):\r\n    if a + b <= c or a + c <= b or b + c <= a:\r\n        return False\r\n    else:\r\n        obseg = a + b + c\r\n        s = obseg / 2\r\n        ploscina = sqrt(s * (s - a) * (s - b) * (s - c))\r\n        return ((ploscina,obseg))\r\n", 
      "trial": "def trial(source):\r\n  podatki = [[random.randint(1, 10) for i in range(3)] for i in range(10)]\r\n  podatki.append([3,4,8])\r\n  podatki.append([3,4,5])\r\n  if check_function(\"trikotnik\", 3):\r\n    for test in podatki:\r\n      (a,b,c) = (test[0], test[1], test[2])\r\n      obseg = a + b + c\r\n      s = obseg / 2\r\n      ploscina = math.sqrt(abs(s * (s - a) * (s - b) * (s - c)))\r\n      res = (ploscina,obseg)\r\n      if a + b <= c or a + c <= b or b + c <= a:\r\n        res = False\r\n      _equal(\"trikotnik({0}, {1}, {2})\".format(a,b,c), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 76, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "#Vektorje v prostoru predstavimo kot nabor treh realnih \u0161tevil. \r\n# Sestavi funkcijo `vektorskiProdukt`, ki izra\u010duna in vrne vektorski \r\n# produkt dveh vektorjev. Primer:\r\n#    >>> `vektorskiProdukt`((1,0,0), (1,0,0))\r\n#    (0,0,0)\r\n#    >>> `vektorskiProdukt`((1,0,0), (0,1,0))\r\n#    (0,0,1)", 
      "solution": "def vektorskiProdukt(v1, v2):\r\n    x = v1[1]*v2[2] - v1[2]*v2[1]\r\n    y = v1[2]*v2[0] - v1[0]*v2[2]\r\n    z = v1[0]*v2[1] - v1[1]*v2[0]\r\n    return (x, y, z)", 
      "trial": "def trial(source):\r\n    if check_function('vektorskiProdukt', 2):\r\n      _equal('vektorskiProdukt((4,0,0), (1,0,0))',(0,0,0))\r\n      _equal('vektorskiProdukt((3,0,0), (0,1,0))',(0,0,3))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 166, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavi metodo `vecmanj(seznam)`, ki vrne najve\u010dje in najmanj\u0161e \u0161tevilo\r\n# glasov, ki jih je stare\u0161ina imel tekom glasovanja. Glasove vrnite v obliki\r\n# nabora z dvema elementoma `(minimum, maksimum)`.\r\n", 
      "solution": "def vecmanj(seznam):\r\n    s=stanje(seznam)\r\n    return (min(s), max(s))\r\n", 
      "trial": "def trial(source):\r\n    if check_function('vecmanj', 1):\r\n        _equal('vecmanj([1, 2, -3, 1])', (0, 3))\r\n        _equal('vecmanj([1, -5, -2, 3, 4])', (-6, 1))\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 276, 
    "model": "problem.part", 
    "fields": {
      "_order": 1, 
      "description": "# Sestavite funkcijo `nepopolnost(n)`, ki vrne absolutno razliko med\r\n# \u0161tevilom `n` in vsoto vseh njegovih pravih deliteljev.", 
      "solution": "def nepopolnost(n):\r\n    return abs(n - sum(praviDelitelji(n)))", 
      "trial": "def trial(source):\r\n    if check_function('nepopolnost', 1):\r\n        _equal('nepopolnost(19)', 18)\r\n        _equal('nepopolnost(28)', 0)\r\n        _equal('nepopolnost(42)', 12)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 199, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Borzni posrednik je delnice v preteklosti \u017ee kupil,\n# zanima pa ga, kdaj se mu je najbolj spla\u010dalo delnico prodati.\n# Sestavi funkcijo 'kdajProdam', ki ugotovi, kdaj bi borzni\n# posrednik imel najve\u010dji zaslu\u017eek. Kot argumente sprejme seznam\n# cen delnic po dnevih, vrne pa naj dan, ko se mu delnico najbolj\n# spla\u010da prodati (dnevi se za\u010dnejo \u0161tevi z ni\u010d - prvi element v\n# seznamu cen je torej vrednost delnice na 0. dan).\n# Primer:\n#    >>> kdajprodam([30, 40, 20, 45, 15, 28])\n#    3", 
      "solution": "def kdajProdam(cene):\n    dan = cene.index(max(cene))\n    return dan", 
      "trial": "def trial(source):\n    if check_function('kdajProdam', 1):\n        _equal('kdajProdam([1, 1, 1])', 0)\n        _equal('kdajProdam([30, 40, 20, 45, 15, 28])', 3)\n        _equal('kdajProdam([15, 45, 38, 12, 45, 44])', 1)\n        _equal('kdajProdam([124, 125, 177, 155, 156, 154, 191, 156, 130, 190, 168, 194, 173, 142, 106, 128, 142, 114, 115, 197, 151, 119, 116, 188, 146, 178, 141, 146, 146, 151, 105, 152, 101, 109, 151, 118, 117, 181, 199, 162, 120, 183, 162, 136, 145, 143, 185, 161, 193, 157, 170, 193, 107, 152, 133, 175, 121, 114, 182, 147, 143, 129, 126, 146, 146, 158, 197, 133, 135, 134, 164, 170, 194, 105, 121, 190, 134, 170, 131, 178, 135, 144, 148, 189, 144, 101, 158, 177, 175, 117, 161, 195, 144, 123, 125, 143, 157, 162, 192, 186])', 38)\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 77, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "#Fiziki so kot rezultat meritve dobili mno\u017eico celih \u0161tevil.\r\n# Meritev so ponovili dvakrat in obakrat dobili nekoliko razli\u010dne\r\n# rezultate. Sestavi metodo `koliko(rez1, rez2)`, ki bo sprejela\r\n# ti dve mno\u017eici in vrnila nabor dveh \u0161tevil `(x,y)`, pri \u010demer\r\n# je x \u0161tevilo vseh razli\u010dnih rezultatov pri obeh poskusih,\r\n# y pa \u0161tevilo vseh enakih rezultatov pri obeh poskusih.\r\n#Primer: \r\n#    >>> `koliko`({3,-2,6,4},{6,5,4})\r\n#    (5, 2)", 
      "solution": "def koliko(m1, m2):\r\n    return len(m1.union(m2)), len(m1.intersection(m2))", 
      "trial": "def trial(source):\r\n    if check_function('koliko', 2):\r\n      _equal('koliko({3,-2,6,4},{6,5,4})', (5,2))\r\n      _equal('koliko({0, -1, 3,-2,6,4},{6,5,4,0})', (7,3))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 70, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "#Mirko gre v trgovino in zapi\u0161e zneske kupljenih predmetov v\r\n#seznam. Namesto z decimalnim \u0161tevilom ceno vsakega predmeta raje\r\n#zapi\u0161e s parom `[evri, centi]`. Sestavi funkcijo `euroSum`, ki na\r\n#podlagi podanega Mirkovega seznama izra\u010duna, koliko je zapravil za\r\n#vse predmete skupaj, ter vrne vsoto v obliki para `[evri, centi]`.\r\n#Primer:\r\n#    >>> euroSum([[3, 12], [5, 0], [1, 33]])\r\n#    [9, 45]\r\n#    >>> euroSum([[3, 12], [5, 0], [1, 33], [4, 65], [2, 55], [16, 18]])\r\n#    [32, 83]", 
      "solution": "def euroSum(nakupi):\r\n    centi = sum([100 * n[0] + n[1] for n in nakupi])\r\n    return [centi // 100, centi % 100]", 
      "trial": "def trial(source):\r\n    _equal('euroSum([[3, 12], [5, 0], [1, 33]])', [9, 45])\r\n    _equal('euroSum([[3, 12], [5, 0], [1, 33], [4, 65], [2, 55], [16, 18]])', [32, 83])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 14, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Predpostavite, da imate v spremenljivkah a in b shranjeni\r\n# dve celi \u0161tevili. Sestavite kodo, ki vam bo v spremenljivke z \r\n# imeni vsota, razlika, produkt, potenca, kvocient, celikvocient in \r\n# ostanek po vrsti shranila rezultate aritmeti\u010dnih operacij\r\n#   +, -, \\*, \\*\\*,  /, // in %. \r\n# Vse te rezultate tudi po vrsti izpi\u0161ite na zaslon, vsakega v svojo vrstico.\r\n# Primer: \u010de sta \u0161tevili a in b enaki\r\na = 5\r\nb = 4\r\n# , naj imajo spremenljivke po\r\n# vrsti vrednosti 9, 1, 20, 625, 1.25, 1 in 1, na zaslon pa naj se izpi\u0161e\r\n#    9\r\n#    1\r\n#    20\r\n#    625\r\n#    1.25\r\n#    1\r\n#    1\r\n#.", 
      "solution": "vsota = a + b\r\nrazlika = a - b\r\nprodukt = a * b\r\npotenca = a ** b\r\nkvocient = a / b\r\ncelikvocient = a // b\r\nostanek = a % b\r\nprint(vsota)\r\nprint(razlika)\r\nprint(produkt)\r\nprint(potenca)\r\nprint(kvocient)\r\nprint(celikvocient)\r\nprint(ostanek)\r\n", 
      "trial": "import random \r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer sta definirana a in b\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    # Pripravimo okolje\r\n    d = dict()\r\n    d[\"a\"] = random.randint(3, 30)\r\n    d[\"b\"] = random.randint(2, 20)\r\n    a = d[\"a\"]\r\n    b = d[\"b\"]\r\n    (d, izpis) = izvedi(source, d)\r\n    rezultati = [(a+b, \"+\", \"vsota\"), (a-b, \"-\", \"razlika\"), (a*b, \"*\", \"produkt\"), (a**b, \"**\", \"potenca\"), (a/b, \"/\", \"kvocient\"), (a//b, \"//\", \"celikvocient\"), (a%b, \"%\", \"ostanek\")]\r\n    pizpis = \"\\n\".join([str(a+b),str(a-b),str(a*b),str(a**b),str(a/b),str(a//b), str(a%b)])\r\n    for (rez, oper, spr) in rezultati:\r\n        if spr not in d:\r\n            _warn(\"Spremenljivka {0} ni definirana.\".format(spr))\r\n        elif d[spr] != rez:\r\n            _warn(\"Rezultat za operacijo {0} ni pravilen: {1} {2} {3} != {4}\".format(oper, a, oper, b, d[spr]))\r\n    if pizpis != izpis.strip():\r\n        _warn(\"Izpis za vrednosti a = {0} in b = {1} ni prave oblike: \\n\".format(a,b) + izpis.strip())\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 277, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# \u0160tevilo je simetri\u010dno nepopolno, kadar je njegova nepopolnost enaka\r\n# nepopolnosti \u0161tevila, obrnjenega na glavo.\r\n# Na primer, vsa palindromna \u0161tevila so simetri\u010dno nepopolna, prav tako\r\n# pa je nepopolno \u0161tevilo 24, saj je njegova nepopolnost enaka\r\n# $|24 - (1 + 2 + 3 + 4 + 6 + 8 + 12)| = 12$, kar je prav tako\r\n# nepopolnost \u0161tevila 42.\r\n#\r\n# Sestavite funkcijo `simetricnoNepopolna(n)`, ki vrne seznam vseh\r\n# simetri\u010dno nepopolnih \u0161tevil med 1 in `n`.", 
      "solution": "def simetricnoNepopolna(n):\r\n    def simetricnoNepopolno(i):\r\n        return nepopolnost(i) == nepopolnost(int(str(i)[::-1]))\r\n    return [i for i in range(1, n + 1) if simetricnoNepopolno(i)]", 
      "trial": "def trial(source):\r\n    if check_function('simetricnoNepopolna', 1):\r\n        _equal('simetricnoNepopolna(19)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\r\n        _equal('simetricnoNepopolna(28)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 24])\r\n        _equal('simetricnoNepopolna(42)', [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 24, 33, 42])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 247, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Janez zboli, tako da ne more sam v igralnico, zato prosi Pepeta,\r\n# da namesto njega igra. Seveda pa Janez Pepetu ne zaupa, da bo\r\n# 'pravilno' stavil, zato Pepetu da seznam svojih stav (kot seznam \u010drk\r\n# 'r' ali '\u010d'), Pepe pa Janezu prinese seznam rezultatov na ruleti (tudi\r\n# kot seznam 'r', '\u010d'). Sestavi funkcijo 'zasluzek', ki iz teh dveh seznamov tvori\r\n# seznam zaslu\u017ekov (tj. \u010de se stava in vrednost na ruleti ujemata,\r\n# Janez dobi 1 \u017eeton, sicer pa 1 \u017eeton izgubi).\r\n# Primer: \r\n#    >>> zasluzek(\"r\u010d\u010d\", \"rr\u010d\")\r\n#    [1, -1, 1]", 
      "solution": "def zasluzek(janez, pepe):\r\n    zasluzek = []\r\n    for i in range(len(janez)):\r\n        if janez[i]==pepe[i]:\r\n            zasluzek.append(1)\r\n        else:\r\n            zasluzek.append(-1)\r\n    return zasluzek", 
      "trial": "def trial(source):\r\n    if check_function('zasluzek', 2):\r\n        _equal('zasluzek(\"r\u010d\u010d\", \"rr\u010d\")', [1,-1,1])\r\n        _equal(\"zasluzek('\u010d\u010drrr\u010d\u010dr\u010dr', 'r\u010d\u010d\u010drr\u010d\u010dr\u010d')\", [-1, 1, -1, -1, 1, -1, 1, -1, -1, -1])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 23, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavi funkcijo presekIntervalov, ki preveri, ali se intervala [a1, b1] in [a2, b2] se\u010deta.\r\n# Funkcija sprejme argumente v slede\u010dem vrstnem redu: a1, b1, a2 in b2.\r\n# \u010ce se se\u010deta, naj vrne interval, na katerem se sekata (interval je dvojica \u0161tevil).\r\n# \u010ce se ne se\u010deta, naj vrne False.\r\n# Primer:\r\n#    >>> presek(3, 7, 1, 2)\r\n#    False\r\n#    >>> presek(3, 7, 1, 5)\r\n#    (3, 5)\r\n#    >>> presek(3, 7, 7, 8)\r\n#    (7, 7)", 
      "solution": "def presekIntervalov(a1, b1, a2, b2):\r\n    a3 = max(a1, a2)\r\n    b3 = min(b1, b2)\r\n    if a3 > b3:\r\n        return False\r\n    else:\r\n        return (a3, b3)\r\n", 
      "trial": "def trial(source):\r\n  podatki = []\r\n  for i in range(10):\r\n    z1 = random.randint(1, 20)\r\n    k1 = z1 + random.randint(1,10)\r\n    z2 = random.randint(1, 20)\r\n    k2 = z2 + random.randint(1,10)\r\n    podatki.append([z1, k1, z2, k2])\r\n  podatki.append([3,7,1,2])\r\n  podatki.append([3,7,1,5])\r\n  podatki.append([3,7,7,8])\r\n  if check_function(\"presekIntervalov\", 4):\r\n    for test in podatki:\r\n      (a1,b1,a2,b2) = (test[0], test[1], test[2],test[3])\r\n      a3 = max(a1, a2)\r\n      b3 = min(b1, b2)\r\n      res = (a3, b3)\r\n      if a3 > b3:\r\n        res = False\r\n      _equal(\"presekIntervalov({0}, {1}, {2}, {3})\".format(a1,b1,a2,b2), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 29, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavite funkcijo `divergencaHarmonicne(n)`, ki izra\u010duna \u0161tevilo\r\n# \u010dlenov harmoni\u010dne vrste, ki jih je treba se\u0161teti, da bo njihova delna\r\n# vsota ve\u010dja od \u0161tevila `n`.", 
      "solution": "def divergencaHarmonicne(n):\r\n    vsota = 0\r\n    i = 0\r\n    while vsota < n:\r\n        i += 1\r\n        vsota += 1 / i\r\n    return i", 
      "trial": "def trial(source):\r\n    if check_function(\"divergencaHarmonicne\", 1):\r\n        _equal('divergencaHarmonicne(3)', 11)\r\n        _equal('divergencaHarmonicne(4)', 31)\r\n        _equal('divergencaHarmonicne(5)', 83)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 119, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavi funkcijo naloga1c, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga1c(s,i,j):\r\n    return naloga1a(s[i-1:j])[-1]", 
      "trial": "def trial(source):\r\n    if check_function('naloga1c', 3):\r\n        _equal('naloga1c([1.2, 2.3, 3.1],1,1)', 1.2)\r\n        _equal('naloga1c([1, -5.2, -2.0, 3],1,3)', -6.2)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 37, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavite funkcijo `ravninski(sprehod)`, ki sprejme niz, ki\r\n# predstavlja zaporedje korakov v ravnini, in vrne to\u010dko, v kateri se\r\n# sprehod kon\u010da.\r\n#\r\n# Sprehod po ravnini se za\u010dne v izhodi\u0161\u010du, predstavimo pa ga z nizem,\r\n# sestavljenim iz \u010drk `S`, `J`, `V` ali `Z`, odvisno od smeri\r\n# (sever, jug, vzhod, zahod). Na ostale znake v nizu se ne oziramo.\r\n", 
      "solution": "def ravninski(sprehod):\r\n    x = y = 0\r\n    for korak in sprehod:\r\n        if korak == 'S':\r\n            y += 1\r\n        elif korak == 'J':\r\n            y -= 1\r\n        elif korak == 'V':\r\n            x += 1\r\n        elif korak == 'Z':\r\n            x -= 1\r\n    return (x, y)\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"ravninski\", 1):\r\n        _equal('ravninski(\"SSJSSVSZ\")', (0, 4))\r\n        _equal('ravninski(\"JJSJJSZZSZ\")', (-3, -1))\r\n        _equal('ravninski(\"\")', (0, 0))\r\n        _equal('ravninski(\"ABCDEFGHIJKLMNOPRSTUVZ\")', (0, 0))\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 44, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavite funkcijo `podvoji(s)`, ki iz seznama `s` sestavi in vrne\r\n# nov seznam, v katerem je za vsakim elementom vrinjena \u0161e njegova\r\n# kopija.", 
      "solution": "def podvoji(s):\r\n    podvojen = []\r\n    for x in s:\r\n        podvojen += [x, x]\r\n    return podvojen", 
      "trial": "def trial(source):\r\n    _equal('podvoji([1, 2, 3])', [1, 1, 2, 2, 3, 3])\r\n    _equal('podvoji([])', [])\r\n    _equal('podvoji([1, True, 3.5, 7, [1, 2], 3 - 2j])', [1, 1, True, True, 3.5, 3.5, 7, 7, [1, 2], [1, 2], (3-2j), (3-2j)])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 101, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavite funkcijo `ekstrema(spremembe)`, ki pri danih spremembah\r\n# stanja poi\u0161\u010de dneva, ko je bilo stanje na ra\u010dunu najni\u017eje oziroma\r\n# najvi\u0161je. Stanji naj vrne v obliki nabora.", 
      "solution": "def ekstrema(spremembe):\r\n    s = stanja(spremembe)\r\n    najnizje = s.index(min(s))\r\n    najvisje = s.index(max(s))\r\n    return (najnizje, najvisje)", 
      "trial": "def trial(source):\r\n    if check_function('ekstrema', 1):\r\n        _equal('ekstrema([1, 2, 3])', (0, 3))\r\n        _equal('ekstrema([1, -5, -20, 30])', (3, 4))\r\n        _equal('ekstrema([])', (0, 0))\r\n        _equal('ekstrema([10, -5, 20, -6])', (0, 3))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 93, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Na datoteki je zapisano besedilo, pri \u010demer so nekatere vrstice\r\n# posebej ozna\u010dene z zvezdico na za\u010detku. Sestavi funkcijo seznami,\r\n# ki bo besedilo iz vhodne datoteke prepisala na izhodno datoteko,\r\n# pri \u010demer bo vrstice ozna\u010dene z zvezdico izpisala kot o\u0161tevil\u010den\r\n# seznam v LaTeXu. \u010ce je ozna\u010denih ve\u010d vrstic skupaj, seveda vse\r\n# pripadajo istemu seznamu. Imeni datotek naj funkcija dobi za parametra.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Primer:\r\n# Vhod:  \r\n# V trgovini moram kupiti:\r\n# *jajca\r\n# *kruh\r\n# *moko\r\n# Na poti nazaj moram:\r\n# *obiskati sosedo\r\n# \r\n# Izhod:\r\n#     V trgovini moram kupiti:\r\n#      \\begin{enumerate}\r\n#      \\item jajca\r\n#      \\item kruh\r\n#      \\item moko\r\n#      \\end{enumerate}\r\n#      Na poti nazaj moram:\r\n#      \\begin{enumerate}\r\n#      \\item obiskati sosedo\r\n#      \\end{enumerate}", 
      "solution": "def seznami(vhod, izhod):\r\n    seznam = False\r\n    with open(vhod) as f:\r\n        with open(izhod, 'w') as g:\r\n            for vrstica in f:\r\n                if vrstica[0] == '*':\r\n                    if not seznam:\r\n                        print('\\\\begin{enumerate}', file=g)\r\n                        seznam = True\r\n                    print('\\\\item', vrstica[1:].strip(), file=g)\r\n                else:\r\n                    if seznam:\r\n                        print('\\\\end{enumerate}', file=g)\r\n                        seznam = False\r\n                    print(vrstica.strip(), file=g)\r\n            if seznam: print('\\\\end{enumerate}', file=g)", 
      "trial": "def trial(source):\r\n    if check_function(\"seznami\", 2):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 167, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavi metodo `medIinJ(seznam, i, j)`, ki vrne \u0161tevilo glasov po\r\n# glasovnaju j-tega predstavnika relativno glede na glasovanje i-tega\r\n# predstavnika (torej gledamo le \u0161tevilo glasov od takrat dalje oz. gledamo,\r\n# kot da se je glasovanje za\u010delo pri i-tem). Prvi element seznama ustreza\r\n# vrednosti i=1. Predpostavi\u0161 lahko, da je i < j.\r\n", 
      "solution": "def medIinJ(seznam, i, j):\r\n    return sum(seznam[i-1:j])\r\n", 
      "trial": "def trial(source):\r\n    if check_function('medIinJ', 3):\r\n        _equal('medIinJ([1, 2, -3, 1], 2, 3)', -1)\r\n        _equal('medIinJ([1, -5, -2, 3, 4], 1, 3)', -6)\r\n        _equal('medIinJ([1, -5, -2, 3, 4, 2, -1, 5, -3, 4], 3, 7)', 6)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 136, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Sestavi funkcijo `povprecja(seznam, m)`, ki iz danega seznama dol\u017eine\r\n# N sestavi seznam dol\u017eine N-m+1, ki sestoji iz teko\u010dih povpre\u010dij\r\n# zaporednih podseznamov dol\u017eine m. Funkcija kot parametra dobi seznam\r\n# in \u017eeleno dol\u017eino podseznamov, vrne pa ustrezen seznam. \u010ce je dol\u017eina\r\n# seznama manj\u0161a kot zahtevana dol\u017eina podseznamov, naj funkcija vrne\r\n# prazen seznam.\r\n# Primer: `povprecja([1, 2, 3, 4, 5, 6], 3)` vrne `[2.0, 3.0, 4.0, 5.0]`.", 
      "solution": "def povprecja(seznam, m):\r\n    N=len(seznam)\r\n    return [povprecje(podseznam(seznam,i,m)) for i in range(N-m+1)]\r\n", 
      "trial": "def trial(source):\r\n    if check_function('povprecja', 2):\r\n        _equal('povprecja([1, 2, 3, 4, 5, 6], 3)', [2, 3, 4, 5])\r\n        _equal('povprecja([1, 2, 3, 4, 5, 6], 1)', [1, 2, 3, 4, 5, 6])\r\n        _equal('povprecja([], 1)', [])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 3, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "# Ra\u010dunalnik si je naklju\u010dno izbral enega izmed slede\u010dih znakov\r\n#     \"*\", \".\", \"#\", \"$\", \"@\", \"o\", \"O\", \"+\", \"=\"\r\n# S posku\u0161anjem uganite, s katerim od teh znakom morate narisati\r\n# smre\u010dico. Dokler smre\u010dice ne boste narisali s pravim znakom,\r\n# boste dobili opozorilo:\r\n#    Smrecica vsebuje znak, ki ga racunalnik ni izbral\r\n# Namig: ugibali boste hitreje, \u010de uporabite slede\u010do spremenljivko:\r\nznak = \"*\"\r\n# in popravljate le to, ne pa vsega programa.", 
      "solution": "print(1 * znak)\r\nprint(2 * znak)\r\nprint(3 * znak)\r\nprint(4 * znak)\r\nprint(5 * znak)\r\nprint(6 * znak)\r\nprint(7 * znak)\r\nprint(8 * znak)", 
      "trial": "def trial(source):\r\n    smrecica = izpis(source)\r\n    preveriSmrecico(smrecica, 8 * [0], range(1, 9), dovoljeni)\r\n    znak = dovoljeni[random.randint(0, 8)]\r\n    if any(z not in znak + \" \\n\" for z in smrecica):\r\n        _warn(\"Smre\u010dica vsebuje znak, ki ga ra\u010dunalnik ni izbral.\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 52, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "#Sestavi funkcijo, ki bo uredila dani seznam \u0161tevil, pri \u010demer naj seznam uredi po zadnji \u0161tevki. \u010ce\r\n#se zadnje \u0161tevke ujemajo, naj \u0161tevila uredi kot obi\u010dajno.\r\n#Pomagaj si z metodo sort na seznamu, ki ji lahko v parametru __key__ poda\u0161 funkcijo, ki se\r\n#izra\u010duna na vsakem elementu pred primerjavo. Definiraj funkcijo, ki vra\u010da zadnjo \u0161tevko \u0161tevila\r\n#in jo uporabi kot vrednost parametra key. Primer:\r\n#    >>> urediStevila([12,3,17,21,101,33])\r\n#    [21, 101, 12, 3, 33, 17]", 
      "solution": "def stevka(stevilo): return stevilo%10\r\ndef urediStevila(s): \r\n   s.sort(key=stevka)\r\n   return s\r\n\r\n", 
      "trial": "def trial(source):\r\n   _equal('urediStevila([12,3,17,21,101,33])',[21, 101, 12, 3, 33, 17])\r\n   _equal('urediStevila([1,2,3,11,12,13])',[1, 11, 2, 12, 3, 13])\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 85, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "#Sestavi funkcijo `karta`, ki vrne naklju\u010dno karto za tarok. Karte za\r\n#tarok so (skupaj jih je 54):\r\n# 22 tarokov, ozna\u010denih z rimskimi \u0161tevilkami od I do XXI in '\u0160kis'\r\n# 32 barvnih kart v srcu(H), kari(D), kri\u017eu(C) in piku(S). Vsaka barva\r\n# ima 8 kart: fanta(J), kavala(C), damo(Q) in kralja(K) ter 7-10\r\n# za pike in kri\u017ee in 1-4 za srce in karo.\r\n#Funkcija naj vrne niz, ki predstavlja karto, za barvne karte je to najprej\r\n#barva (ena od \u010drk H,D,C ali S) in nato vrednost (\u0161tevilka ali J,C,Q,K), za taroke\r\n#pa ustrezna rimska \u0161tevilka oz. '\u0160kis'. Za tarok 4 uporabi 'IV'.\r\n#Primer:\r\n#    >>> karta()\r\n#    'DJ'\r\n#    >>> karta()\r\n#    'C10'\r\n#    >>> karta()\r\n#    'XII'\r\n#    >>> karta()\r\n#    'HC'", 
      "solution": "def karta():\r\n    karte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0160kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n    N=len(karte)\r\n    return karte[random.randint(1,N)-1]", 
      "trial": "def trial(source):\r\n    if check_function('karta', 0):\r\n#        _equal('karta() in karte', True, 'Napa\u010dna oznaka karte. Veljavne oznake so\\n{}'.format(karte))\r\n        _equal('karta() in karte', True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 151, 
    "model": "problem.part", 
    "fields": {
      "_order": 2, 
      "description": "#Sestavi funkcijo `relativno(seznam,i,j)`, ki poi\u0161\u010de relativno stanje po\r\n#dnevu `j`, \u010de za\u010dnemo meriti od `i`-tega dneva naprej.", 
      "solution": "def relativno(seznam, i, j):\r\n    s = [0] + stanja(seznam)\r\n    return s[j] - s[i]", 
      "trial": "def trial(source):\r\n    if check_function('relativno', 3):\r\n        _equal('relativno([1, 2, 3], 2, 3)', 3)\r\n        _equal('relativno([1, -5, -20, 30], 0, 4)', 6)\r\n        _equal('relativno([10, -5, 20, -6], 1, 2)', -5)\r\n        _equal('relativno([10, -5, 20, -6], 2, 4)', 14)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 15, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Predpostavite, da imate v spremenljivkah stopinje1, minute1, sekunde1, stopinje2, minute2 in \r\n# sekunde2 shranjene stopinje, minute in sekunde dveh kotov (vse vrednosti si celo\u0161tevilske). \r\n# Sestavite program, ki bo ta dva kota se\u0161tel in izpisal niz oblike\r\n#    Vsota kotov je x stopinj, y minut in z sekund.\r\n# Seveda morata biti vrednosti spremenljivk y in z manj\u0161i od 60.\r\n# Za vrednosti\r\nstopinje1 = 14\r\nminute1 = 43\r\nsekunde1 = 15\r\nstopinje2 = 55\r\nminute2 = 21\r\nsekunde2 = 57\r\n# naj tako program izpi\u0161e\r\n#    Vsota kotov je 70 stopinj, 5 minut in 12 sekund.", 
      "solution": "stopinje = stopinje1 + stopinje2\r\nminute = minute1 + minute2\r\nsekunde = sekunde1 + sekunde2\r\nminute += sekunde // 60\r\nsekunde = sekunde % 60\r\nstopinje += minute // 60\r\nminute = minute % 60\r\nprint(\"Vsota kotov je {0} stopinj, {1} minut in {2} sekund.\".format(stopinje, minute, sekunde))", 
      "trial": "import random \r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer so definirane spremenljivke v kodi\r\n    # in jih nadomestimo s svojimi\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    d = dict()\r\n    d[\"stopinje1\"] = random.randint(5, 30)\r\n    d[\"stopinje2\"] = random.randint(5, 30)\r\n    d[\"minute1\"] = random.randint(35, 59)\r\n    d[\"minute2\"] = random.randint(30, 59)\r\n    d[\"sekunde1\"] = random.randint(35, 59)\r\n    d[\"sekunde2\"] = random.randint(30, 59)\r\n\r\n    (st, min, sek) = (d[\"stopinje1\"] + d[\"stopinje2\"], d[\"minute1\"]+d[\"minute2\"], d[\"sekunde1\"] + d[\"sekunde2\"])\r\n    (st, min, sek) = (st + (min + sek//60) // 60  , (min + sek//60)%60, sek % 60)\r\n    (d, izpis) = izvedi(source, d)\r\n    if izpis.strip() != \"Vsota kotov je {0} stopinj, {1} minut in {2} sekund.\".format(st, min, sek):\r\n        _warn(\"Za vrednosti ({0}, {1}, {2}) in ({3}, {4}, {5}) je izpis je napa\u010dne oblike:\\n \".format(d[\"stopinje1\"],d[\"minute1\"],d[\"sekunde1\"],d[\"stopinje2\"],d[\"minute2\"],d[\"sekunde2\"]) + izpis.strip())\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 168, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo `najvecjidvig(seznam)`, ki za dani seznam glasov\r\n# poi\u0161\u010de najve\u010dji relativni dvig glasov.\r\n", 
      "solution": "def najvecjidvig(s):\r\n    m=s[0]\r\n    p=0\r\n    for i in range(len(s)):\r\n        if p+s[i] > 0:\r\n            p+= s[i]\r\n            if p > m: m=p\r\n        else:\r\n            if s[i] > m: m=s[i]\r\n            p=0\r\n    return m\r\n", 
      "trial": "def trial(source):\r\n    if check_function('najvecjidvig', 1):\r\n        _equal('najvecjidvig([1, 2, -3, 1])', 3)\r\n        _equal('najvecjidvig([1, -5, -2, 3, 4])', 7)\r\n        _equal('najvecjidvig([1, -5, -2, 3, 4, 2, -1, 5, -3, 4])', 14)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 38, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavite funkcijo `hitri(tek)`, ki sprejme niz, ki predstavlja\r\n# zaporedje korakov in skokov v ravnini, in vrne to\u010dko, v kateri se\r\n# tek kon\u010da.\r\n#\r\n# Tek po ravnini se za\u010dne v izhodi\u0161\u010du, predstavimo pa ga, tako kot\r\n# sprehod, z nizem, sestavljenim iz \u010drk `S`, `J`, `V` ali `Z`, odvisno\r\n# od smeri (sever, jug, vzhod, zahod).\r\n#\r\n# Poleg tega lahko tek vsebuje tudi \u0161tevke od `1` do `9`, ki povedo,\r\n# koliko dolg naj bo naslednji korak. Tako niz `5S` pomeni skok\r\n# na sever, dolg 5 korakov. Privzamete lahko, da zaporednih \u0161tevk v\r\n# nizu ni, ter da se na ostale znake v nizu ne oziramo.\r\n", 
      "solution": "def hitri(tek):\r\n    x = y = 0\r\n    dolzina = 1\r\n    for korak in tek:\r\n        if korak == 'S':\r\n            y += dolzina\r\n        elif korak == 'J':\r\n            y -= dolzina\r\n        elif korak == 'V':\r\n            x += dolzina\r\n        elif korak == 'Z':\r\n            x -= dolzina\r\n        if korak in '123456789':\r\n            dolzina = int(korak)\r\n        else:\r\n            dolzina = 1\r\n    return (x, y)\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"hitri\", 1):\r\n        _equal('hitri(\"5S2V3S4V\")', (6, 8))\r\n        _equal('hitri(\"JJS2JS2ZSZ\")', (-3, -1))\r\n        _equal('hitri(\"1S2J3Z4V\")', (1, -1))\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 71, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "#Sestavi funkcijo `tekociMaxAbs`, ki zgradi in vrne seznam enake\r\n#dol\u017eine kot je bil vhodni vektor. Novi seznam naj za vsak element\r\n#prvotnega seznama vsebuje do sedaj po absolutni vrednosti najve\u010dje\r\n#\u0161tevilo. Primer:\r\n#    >>> tekociMaxAbs([5, -3, 7, 3, -9, -4, -12, 60, 1, -33, 12])\r\n#    [5, 5, 7, 7, -9, -9, -12, 60, 60, 60, 60]", 
      "solution": "def tekociMaxAbs(sez):\r\n    rezultat = []\r\n    for el in sez:\r\n        if rezultat == [] or abs(rezultat[-1]) < abs(el):\r\n            rezultat.append(el)\r\n        else:\r\n            rezultat.append(rezultat[-1])\r\n    return rezultat", 
      "trial": "def trial(source):\r\n    _equal('tekociMaxAbs([5, -3, 7, 3, -9, -4, -12, 60, 1, -33, 12])', [5, 5, 7, 7, -9, -9, -12, 60, 60, 60, 60])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 53, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "#Prej\u0161njo nalogo re\u0161i s pomo\u010djo anonimne funkcije. Funkcijo poimenuj urediStevila2.", 
      "solution": "def urediStevila2(s): \r\n   s.sort(key=lambda x: x%10)\r\n   return s\r\n\r\n", 
      "trial": "def trial(source):\r\n   _equal('urediStevila2([12,3,17,21,101,33])',[21, 101, 12, 3, 33, 17])\r\n   _equal('urediStevila2([1,2,3,11,12,13])',[1, 11, 2, 12, 3, 13])\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 78, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "#Sestavi funkcijo `presek`, ki bo za parametra dobila seznam mno\u017eic in celo \r\n# \u0161tevilo n. Funkcija naj vrne mno\u017eico tistih elementov, \r\n# ki se pojavljajo v natanko n mno\u017eicah iz seznama.\r\n#Primer:\r\n#    >>> `presek`([{1, 4, 2}, {3, 4, 1}, {6, 3, 2, 1}, {4, 6}, {5}], 2)\r\n#    {2,3,6}", 
      "solution": "def presek(mnozice, n):\r\n    vsiElementi = set()\r\n    for mnozica in mnozice:\r\n      vsiElementi = vsiElementi.union(mnozica)\r\n    vrni = set()\r\n    for element in vsiElementi:\r\n      kolikokrat = 0\r\n      for mnozica in mnozice:\r\n        if element in mnozica:\r\n          kolikokrat += 1\r\n      if kolikokrat == n:\r\n        vrni.add(element)\r\n    return vrni", 
      "trial": "def trial(source):\r\n    if check_function('presek', 2):\r\n      _equal('presek([{1, 4, 2}, {3, 4, 1}, {6, 3, 2, 1}, {4, 6}, {5}], 2)', {2,3,6})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 120, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo naloga1d, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga1d(s):\r\n    m=s[0]\r\n    p=0\r\n    for i in range(len(s)):\r\n        if p+s[i] < 0:\r\n            p+= s[i]\r\n            if p < m: m=p\r\n        else:\r\n            if s[i] < m: m=s[i]\r\n            p=0\r\n    return m", 
      "trial": "def trial(source):\r\n    if check_function('naloga1d', 1):\r\n        _equal('naloga1d([1.2,-3.2,-1,.5,-1.2,3.1,-2.1])', -4.9)\r\n        _equal('naloga1d([1,2,3,4,0.5])', 0.5)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 278, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# \u0160tevilo je popolnomaNepopolno, kadar je njegova nepopolnost ve\u010dja od\r\n# njega samega.\r\n#\r\n# Sestavite funkcijo `popolnomaNepopolno(n)`, ki vrne prvo popolnoma\r\n# nepopolno \u0161tevilo, ve\u010dje ali enako `n`.", 
      "solution": "def popolnomaNepopolno(n):\r\n    while(nepopolnost(n) <= n):\r\n        n += 1\r\n    return n", 
      "trial": "def trial(source):\r\n    if check_function('popolnomaNepopolno', 1):\r\n        _equal('popolnomaNepopolno(0)', 180)\r\n        _equal('popolnomaNepopolno(181)', 240)\r\n        _equal('popolnomaNepopolno(241)', 360)\r\n        _equal('popolnomaNepopolno(361)', 420)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 24, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo vecjeStevke , ki vrne vsoto tistih \u0161tevk danega \u0161tirimestnega \u0161tevila, ki so ve\u010dje od \r\n# dane \u0161tevke. Kot argumente sprejme \u0161tevilo in \u0161tevko (v tem vrstnem redu). \r\n# \u010ce tak\u0161nih \u0161tevk ni, naj vrne 0.\r\n# Primer:\r\n#    >>> vecjeStevke(1234, 5)\r\n#    0\r\n#    >>> vecjeStevke(4285, 5)\r\n#    8\r\n#    >>> vecjeStevke(9563, 3)\r\n#    20", 
      "solution": "def vecjeStevke(n, k):\r\n    a = n // 1000\r\n    b = n // 100 % 10\r\n    c = n // 10 % 10\r\n    d = n % 10\r\n    suma = 0\r\n    if a > k: suma += a\r\n    if b > k: suma += b\r\n    if c > k: suma += c\r\n    if d > k: suma += d\r\n    return suma", 
      "trial": "def trial(source):\r\n  podatki = [[random.randint(1000, 9999), random.randint(0,9)] for i in range(10)]\r\n  if check_function(\"vecjeStevke\", 2):\r\n    for test in podatki:\r\n      (n,s) = (test[0], test[1])\r\n      a = n // 1000\r\n      b = n // 100 % 10\r\n      c = n // 10 % 10\r\n      d = n % 10\r\n      res = 0\r\n      if a > s:\r\n        res += a\r\n      if b > s:\r\n        res += b\r\n      if c > s:\r\n        res += c\r\n      if d > s:\r\n        res += d\r\n    _equal(\"vecjeStevke({0}, {1})\".format(n,s), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 30, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Pribli\u017eke za kvadratni koren \u0161tevila $n$ lahko izra\u010dunamo po\r\n# naslednjem postopku. Za\u010detni pribli\u017eek $x_0$ je enak $n / 2$.\r\n# Vsak naslednji pribli\u017eek $x_{k + 1}$ pa izra\u010dunamo kot\r\n# $(x_k + n / x_k) / 2$.\r\n#\r\n# Sestavite funkcijo `priblizekKorena(n, k)`, ki vrne `k`-ti pribli\u017eek\r\n# kvadratnega korena \u0161tevila `n`.", 
      "solution": "def priblizekKorena(n, k):\r\n    x = n / 2\r\n    i = 0\r\n    while i < k:\r\n        x = (x + n / x) / 2\r\n        i += 1\r\n    return x", 
      "trial": "def trial(source):\r\n    if check_function(\"priblizekKorena\", 2):\r\n        _equal('priblizekKorena(2, 3)', 1.4142156862745097)\r\n        _equal('priblizekKorena(3, 4)', 1.7320508075688772)\r\n        _equal('priblizekKorena(100, 4)', 10.030495203889796)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 248, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo 'maxDobicek', ki iz danih seznamov stav in rezultatov poi\u0161\u010de\r\n# maksimalni mo\u017eni zaslu\u017eek za Janeza. Pri tem Janez ne za\u010dne nujno\r\n# igrati na za\u010detku in ne vztraja nujno do konca. Kot argument metoda \r\n# sprejme seznam rezultatov stav (kot v prvi nalogi).\r\n# \r\n#    >>> maxDobicek([1, 1, -1, 1, -1, 1, 1, -1])\r\n#    3", 
      "solution": "def maxDobicek(stave):\r\n    cene = stave\r\n    (kupim, prodam, maxZasluzek) = (0, 0, 0)\r\n    for i in range(len(cene)):\r\n        for j in range(i,len(cene)):\r\n            zasluzim = sum(cene[i:j+1])\r\n            if zasluzim > maxZasluzek:\r\n                (kupim, prodam, maxZasluzek) = (i, j+1, zasluzim)\r\n    return maxZasluzek", 
      "trial": "def trial(source):\r\n    if check_function('maxDobicek', 1):\r\n        _equal('maxDobicek([1, 1, -1, 1, -1, 1, -1, -1, 1, 1])', 2)\r\n        _equal('maxDobicek([-1, -1, -1, 1, 1, 1, 1, 1, 1, -1])', 6)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 86, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "#Sestavi funkcijo `tarok`, ki vrne naklju\u010dno razdeljene karte za tarok.\r\n#Pomagaj si s funkcijo karta. Funkcija naj sprejme en parameter, ki pove,\r\n#za koliko igralcev moramo razdeliti karte (3 ali 4), vrne pa naj seznam\r\n#mno\u017eic, ki predstavljajo porazdelitev kart po rokah ter talon.\r\n#Pri igri v 3 vsak igralec dobi 16 kart, pri igri v \u0161tiri pa 12 kart. Talon\r\n#ima vedno 6 kart. Bodi pozoren na to, da se vsaka karta pojavi samo enkrat.\r\n#Primer:\r\n#    >>> tarok(3)\r\n#    [{'SK', 'S9', 'XI', 'IX', 'XV', 'III', 'IV', 'XVI', 'HK', 'XIII', 'VIII', 'XVIII', 'X', 'HC', 'C7', 'D3'}, {'CJ', 'VI', #    'S8', 'HQ', 'DK', 'H1', 'I', 'XII', 'VII', 'S7', 'II', 'CC', 'XX', 'V', 'XIX', 'CQ'}, {'CK', 'DJ', 'H2', 'H3', 'SQ', #    'S10', 'HJ', 'SJ', 'C9', 'C8', 'XVII', 'XIV', 'SC', 'XXI', 'C10', 'D1'}, {'\u0161kis', 'DC', 'H4', 'D4', 'D2', 'DQ'}]", 
      "solution": "def tarok(igralcev):\r\n    karte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0160kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n    random.shuffle(karte)\r\n    stkart = 16 if igralcev==3 else 12\r\n    return [set(karte[stkart*i:stkart*i+stkart]) for i in range(igralcev+1)]", 
      "trial": "def trial(source):\r\n    if check_function('tarok', 1):\r\n        _equal('isinstance(tarok(3)[0],set) and len(tarok(3)[0])==16', True, 'Prvi igralec nima pravih kart')\r\n        _equal('isinstance(tarok(3)[1],set) and len(tarok(3)[0])==16', True, 'Drugi igralec nima pravih kart')\r\n        _equal('isinstance(tarok(3)[2],set) and len(tarok(3)[0])==16', True, 'Tretji igralec nima pravih kart')\r\n        _equal('isinstance(tarok(4)[3],set) and len(tarok(4)[3])==12', True, '\u010cetrti igralec nima pravih kart')\r\n        _equal('len(unija(tarok(4)))', 54, 'Nekatere karte so uporabljene ve\u010dkrat')\r\n        _equal('len(unija(tarok(3)))', 54, 'Nekatere karte so uporabljene ve\u010dkrat')\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 152, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo `maxdvig(seznam)`, ki poi\u0161\u010de najve\u010dji relativni dvig\r\n# nivoja vode. Z drugimi besedami, poi\u0161\u010di najve\u010djo vrednost, ki jo zavzame vsota\r\n# poljubnega strnjenega podseznama.", 
      "solution": "def maxdvig(spremembe):\r\n    n = len(spremembe)\r\n    return max(relativno(spremembe, i, j)\r\n               for i in range(0, n + 1)\r\n               for j in range(i, n + 1))", 
      "trial": "def trial(source):\r\n    if check_function('maxdvig', 1):\r\n        _equal('maxdvig([10, -13, 3, 20, -2, 5])', 26)\r\n        _equal('maxdvig([1, 2, 3])', 6)\r\n        _equal('maxdvig([1, -5, -20, 30])', 30)\r\n        _equal('maxdvig([10, -5, 20, -6])', 25)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 102, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavite funkcijo `razlika(spremembe, i, j)`, ki poi\u0161\u010de razliko\r\n# stanj med dnevoma z indeksom `i` in `j`.\r\n# Predpostavite lahko, da je `i` manj\u0161i ali enak `j`.", 
      "solution": "def razlika(spremembe, i, j):\r\n    s = stanja(spremembe[i:j + 1])\r\n    return s[-1]", 
      "trial": "def trial(source):\r\n    if check_function('razlika', 3):\r\n        _equal('razlika([1, 2, 3], 2, 3)', 3)\r\n        _equal('razlika([1, -5, -20, 30], 0, 4)', 6)\r\n        _equal('razlika([10, -5, 20, -6], 1, 2)', 15)\r\n        _equal('razlika([10, -5, 20, -6], 2, 4)', 14)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 45, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavite funkcijo `pomnozi(s, n)`, ki iz seznama `s` sestavi in vrne\r\n# nov seznam, v katerem je za vsakim elementom vrinjenih \u0161e `n - 1`\r\n# njegovih kopij.", 
      "solution": "def pomnozi(s, n):\r\n    pomnozen = []\r\n    for x in s:\r\n        pomnozen += n * [x]\r\n    return pomnozen", 
      "trial": "def trial(source):\r\n    _equal('pomnozi([1, 2, 3], 3)', [1, 1, 1, 2, 2, 2, 3, 3, 3])\r\n    _equal('pomnozi([1, 2, 3], 0)', [])\r\n    _equal('pomnozi([1, True, 3.5, 7, [1, 2], 3 - 2j], 2)', [1, 1, True, True, 3.5, 3.5, 7, 7, [1, 2], [1, 2], (3-2j), (3-2j)])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 200, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Borzni posrednik je nekako uspe priti do \u010dasovnega stroja, tako\n# da ima podatke o vrednosti delnice za vsak dan za naslednjih nekaj\n# mesecev. Sestavi funkcijo 'kolikoLahkoZasluzi', ki poi\u0161\u010de najve\u010dji\n# mo\u017eni zaslu\u017eek. Vrne naj tri podatke: dan, na katerega naj posrednik\n# kupi delnice (kot indeks v seznamu), dan, kdaj jih naj proda, ter kak\u0161en\n# zaslu\u017eek bo imel. Vrne naj jih kot nabor.\n# Metoda kot parameter dobi seznam z vrednostmi delnice po dnevih.\n# \u010ce z nakupom delnic ne more zaslu\u017eiti ni\u010desar (npr. \u010de njihova vrednost\n# neprestano pada), naj metoda vrne nabor (0,0,0).\n# Primer:\n#    >>> kolikoLahkoZasluzi([2,3,2])\n#    (0, 1, 1)", 
      "solution": "def kolikoLahkoZasluzi(cene):\n    cene = padci(cene)\n    (kupim, prodam, maxZasluzek) = (0, 0, 0)\n    for i in range(len(cene)):\n        for j in range(i,len(cene)):\n            zasluzim = sum(cene[i:j+1])\n            if zasluzim > maxZasluzek:\n                (kupim, prodam, maxZasluzek) = (i, j+1, zasluzim)\n    return (kupim, prodam, maxZasluzek)", 
      "trial": "def trial(source):\n    if check_function('kolikoLahkoZasluzi', 1):\n        _equal('kolikoLahkoZasluzi([2,3,2])', (0,1,1))\n        _equal('kolikoLahkoZasluzi([30, 27, 36, 48, 54, 41, 26, 12, 8, 8])', (1,4,27))\n        _equal('kolikoLahkoZasluzi([124, 125, 177, 155, 156, 154, 191, 156, 130, 190, 168, 194, 173, 142, 106, 128, 142, 114, 115, 197, 151, 119, 116, 188, 146, 178, 141, 146, 146, 151, 105, 152, 101, 109, 151, 118, 117, 181, 199, 162, 120, 183, 162, 136, 145, 143, 185, 161, 193, 157, 170, 193, 107, 152, 133, 175, 121, 114, 182, 147, 143, 129, 126, 146, 146, 158, 197, 133, 135, 134, 164, 170, 194, 105, 121, 190, 134, 170, 131, 178, 135, 144, 148, 189, 144, 101, 158, 177, 175, 117, 161, 195, 144, 123, 125, 143, 157, 162, 192, 186])', (32, 38, 98))\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 94, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo seznam, ki za parametra dobi ime vhodne in ime\r\n# izhodne datoteke. Na vhodni datoteki je opisan ve\u010dnivojski seznam,\r\n# vsak element seznama v svoji vrstici.\r\n# Na za\u010detku vrstice je \u0161e \u0161tevilka, ki dolo\u010da, kateremu nivoju\r\n# pripada element. Predpostavi\u0161 lahko, da je \u0161tevilka enomestna in\r\n# da je za njo presledek. Program naj seznam prepi\u0161e na izhodno\r\n# datoteko v obliki gnezdenega seznama HTML.\r\n# Elementov LI ni potrebno zaklju\u010devati.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Primer:\r\n# Vhod:  \r\n#      1 Novi avtomobili\r\n#      2 Audi\r\n#      3 A3\r\n#      3 A4\r\n#      3 A6\r\n#      2 Honda\r\n#      3 Civic\r\n#      3 Accord\r\n#      1 Rabljeni avtomobili\r\n#      2 Hyundai\r\n#      3 Elantra\r\n#      3 Accent\r\n#      3 Getz\r\n#      3 Atos\r\n# \r\n# Izhod:\r\n#      <ul>\r\n#        <li> Novi avtomobili\r\n#          <ul>\r\n#            <li> Audi\r\n#              <ul>\r\n#                <li> A3\r\n#                <li> A4\r\n#                <li> A6\r\n#              </ul>\r\n#            <li> Honda\r\n#              <ul>\r\n#                <li> Civic\r\n#                <li> Accord\r\n#              </ul>\r\n#          </ul>\r\n#        <li> Rabljeni avtomobili\r\n#          <ul>\r\n#            <li> Hyundai\r\n#              <ul>\r\n#                <li> Elantra\r\n#                <li> Accent\r\n#                <li> Getz\r\n#                <li> Atos\r\n#              </ul>\r\n#          </ul>\r\n#      </ul>", 
      "solution": "def seznam(vhod, izhod):\r\n    nivo = 0\r\n    zamik = 2\r\n    with open(vhod) as f:\r\n        with open(izhod, 'w') as g:\r\n            for vrstica in f:\r\n                n = int(vrstica[0])\r\n                vrstica = vrstica[2:].strip()\r\n                if n > nivo:\r\n                    print(2 * zamik * nivo * ' ' + '<ul>', file=g)\r\n                    nivo += 1\r\n                while n < nivo:\r\n                    nivo -= 1\r\n                    print(2 * zamik * nivo * ' ' + '</ul>', file=g)\r\n                print((2 * zamik * nivo - zamik) * ' ' + '<li>', vrstica, file=g)\r\n            while nivo > 0:\r\n                nivo -= 1\r\n                print(2 * zamik * nivo * ' ' + '</ul>', file=g)", 
      "trial": "def trial(source):\r\n    if check_function(\"seznam\", 2):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 137, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Sestavi funkcijo `povprecnoPovprecje(seznam, m)`, ki izra\u010duna povpre\u010dno\r\n# povpre\u010dje, tj. iz podanege seznama tako dolgo ra\u010duna teko\u010da povpre\u010dja,\r\n# dokler ne pride do seznama dol\u017eine `m`. Vrne naj povpre\u010dje tega zadnjega\r\n# seznama. \u010ce je podani seznam kraj\u0161i od m, naj funkcija vrne 0.\r\n# Primer: `povprecnoPovprecje([1, 2, 3, 4, 5, 6], 3)` vrne `3.5`.", 
      "solution": "def povprecnoPovprecje(seznam, m):\r\n    s=povprecja(seznam, m)\r\n    while len(s) > m:\r\n        s=povprecja(s, m)\r\n    return povprecje(s)", 
      "trial": "def trial(source):\r\n    if check_function('povprecnoPovprecje', 2):\r\n        _equal('povprecnoPovprecje([1, 2, 3, 4, 5, 6], 3)', 3.5)\r\n        _equal('povprecnoPovprecje([], 1)', 0)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 4, 
    "model": "problem.part", 
    "fields": {
      "_order": 3, 
      "description": "# Osemvrsti\u010dno smre\u010dico izpi\u0161ite z enim samim klicem funkcije print. \r\n# Pri tem ne smete uporabiti niza z ve\u010d kot eno zaporedno zvezdico.\r\n# Namig: znak za prelom vrstice je `\"\\n\"`.", 
      "solution": "print(1 * znak + \"\\n\" +\r\n      2 * znak + \"\\n\" +\r\n      3 * znak + \"\\n\" +\r\n      4 * znak + \"\\n\" +\r\n      5 * znak + \"\\n\" +\r\n      6 * znak + \"\\n\" +\r\n      7 * znak + \"\\n\" +\r\n      8 * znak)", 
      "trial": "def trial(source):\r\n    preveriSmrecico(izpis(source), 8 * [0], range(1, 9), dovoljeni)\r\n    if re.sub(r'#.*', '', source).count(\"print(\") > 1:\r\n        _warn(\"Program vsebuje ve\u010d kot en klic funkcije print.\")\r\n    if \"**\" in re.sub(r'#.*', '', source):\r\n        _warn(\"V programu nastopata dve zaporedni zvezdici.\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 39, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavite funkcijo `oklepaji(niz)`, ki bo preverila, ali so v danem\r\n# nizu oklepaji pravilno gnezdeni. Na ostale znake naj se funkcija ne\r\n# ozira.\r\n#\r\n# Oklepaji so pravilno gnezdeni, \u010de oklepaji in zaklepaji nastopajo v\r\n# parih in \u0161tevilo zaklepajev nikoli ne prese\u017ee \u0161tevila oklepajev, ko\r\n# jih \u0161tejemo od leve proti desni.\r\n", 
      "solution": "def oklepaji(niz):\r\n    oklepaji = 0\r\n    for z in niz:\r\n        if z == '(':\r\n            oklepaji += 1\r\n        elif z == ')':\r\n            oklepaji -= 1\r\n        if oklepaji < 0:\r\n            return False\r\n    return oklepaji == 0\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"oklepaji\", 1):\r\n        _equal('oklepaji(\"(2 + a) + ((3 - x) + (3 - 2))\")', True)\r\n        _equal('oklepaji(\"() +krneki-/*+3@ (() - ()((()())))\")', True)\r\n        _equal('oklepaji(\"(((()) + (\")', False)\r\n        _equal('oklepaji(\"(2 + 3) - 3 + ) (\")', False)\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 5, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Osemvrsti\u010dno smre\u010dico izpi\u0161ite \u0161e desno poravnano.\r\n# Na primer:\r\n#         *\r\n#        **\r\n#       ***\r\n#      ****\r\n#     *****\r\n# Pri tem ne smete uporabiti niza z ve\u010d kot eno zaporedno zvezdico.\r\n# Namig: na za\u010detku vsake vrstice natisnite ustrezno \u0161tevilo presledkov.", 
      "solution": "znak = \"*\"\r\nprint(7 * \" \" + 1 * znak + \"\\n\" +\r\n      6 * \" \" + 2 * znak + \"\\n\" +\r\n      5 * \" \" + 3 * znak + \"\\n\" +\r\n      4 * \" \" + 4 * znak + \"\\n\" +\r\n      3 * \" \" + 5 * znak + \"\\n\" +\r\n      2 * \" \" + 6 * znak + \"\\n\" +\r\n      1 * \" \" + 7 * znak + \"\\n\" +\r\n      8 * znak)", 
      "trial": "def trial(source):\r\n    preveriSmrecico(izpis(source), range(7, -1, -1), 8 * [8], dovoljeni)\r\n    if \"**\" in re.sub(r'#.*', '', source):\r\n        _warn(\"V programu nastopata dve zaporedni zvezdici.\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 16, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavi program, ki dani kot v radianih (realno \u0161tevilo) izpi\u0161e v stopinjah in minutah (kot celi \u0161tevili,\r\n# za minute ne uporabi zaokro\u017eenja ampak samo odre\u017ee decimalna mesta). Predpostavite, da \r\n# je kot podan v spremenljivki kot. \r\n# Primer: za \r\nkot = 2.185\r\n# naj program izpi\u0161e\r\n#    2.185 radianov je 125 stopinj in 11 minut.", 
      "solution": "import math\r\nstopinje = kot * 360 / (2*math.pi)\r\nminute = int((stopinje - int(stopinje))*60)\r\nstopinje = int(stopinje)\r\nprint(\"{0} radianov je {1} stopinj in {2} minut.\".format(kot, stopinje, minute))\r\n", 
      "trial": "import random \r\nimport math\r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer so definirane spremenljivke v kodi\r\n    # in jih nadomestimo s svojimi\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    d = dict()\r\n    kot = random.random()*10\r\n    d[\"kot\"] = kot\r\n    stopinje = kot * 360 / (2*math.pi)\r\n    stopinje, minute = int(stopinje), int((stopinje - int(stopinje))*60)\r\n    (d, izpis) = izvedi(source, d)\r\n    if izpis.strip() != \"{0} radianov je {1} stopinj in {2} minut.\".format(kot, stopinje, minute):\r\n        _warn(\"Za kot {} je izpis napa\u010dne oblike: \".format(kot) + izpis.strip())\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 25, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Interval [a, b] je mno\u017eica vseh \u0161tevil, ki so ve\u010dja ali enaka a in manj\u0161a ali enaka b.\r\n# Torej je interval [3, 2] dobro definiran (in seveda prazna mno\u017eica).\r\n# Popravi svojo metodo presekIntervalov (in je poimenuj presekIntervalov1), ki naj \r\n# vrne pravilen rezultat tudi za intervale tak\u0161ne oblike.\r\n# Namig: lahko se zgodi, da va\u0161a metoda \u017ee deluje pravilno.", 
      "solution": "def presekIntervalov(a1, b1, a2, b2):\r\n    a3 = max(a1, a2)\r\n    b3 = min(b1, b2)\r\n    if a3 > b3:\r\n        return False\r\n    else:\r\n        return (a3, b3)\r\n", 
      "trial": "def trial(source):\r\n  podatki = [[random.randint(1, 20) for i in range(4)] for i in range(20)]\r\n  if check_function(\"presekIntervalov1\", 4):\r\n    for test in podatki:\r\n      (a1,b1,a2,b2) = (test[0], test[1], test[2],test[3])\r\n      a3 = max(a1, a2)\r\n      b3 = min(b1, b2)\r\n      res = (a3, b3)\r\n      if a3 > b3:\r\n        res = False\r\n      _equal(\"presekIntervalov1({0}, {1}, {2}, {3})\".format(a1,b1,a2,b2), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 31, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavite funkcijo `eksponentna(n)`, ki izra\u010duna delno vsoto:\r\n#   $$1 + 1 / 1! + 1 / 2! + 1 / 3! + ... + 1 / n!$$", 
      "solution": "def eksponentna(n):\r\n    vsota = 0\r\n    i = 0\r\n    clen = 1\r\n    while i <= n:\r\n        vsota += clen\r\n        i += 1\r\n        clen /= i\r\n    return vsota", 
      "trial": "def trial(source):\r\n    if check_function(\"eksponentna\", 1):\r\n        _equal('eksponentna(4)', 2.708333333333333)\r\n        _equal('eksponentna(5)', 2.716666666666666)\r\n        _equal('eksponentna(10)', 2.7182818011463845)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 169, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavi funkcijo `ostanki(mnozica, k)`, ki kot parametra dobi mno\u017eico\r\n# celih \u0161tevil in naravno \u0161tevilo k, vrne pa mno\u017eico ostankov elementov\r\n# te mno\u017eice po modulu k.\r\n", 
      "solution": "def ostanki(m, k):\r\n    return {x%k for x in m}\r\n", 
      "trial": "def trial(source):\r\n    if check_function('ostanki', 2):\r\n        _equal('ostanki({1, 2, 12, 7, 5, 9}, 4)', {0, 1, 2, 3})\r\n        _equal('ostanki({0, 2, 4}, 5)', {0, 2, 4})\r\n        _equal('ostanki({-10, 5, 7, 3, 10}, 6)', {1, 2, 5, 3, 4})\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 138, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# V slovarju imamo shranjeno substitucijsko \u0161ifro. To pomeni, da so klju\u010di\r\n# in vrednosti slovarja \u010drke od 'A' do '\u017d', vrednost za nek klju\u010d pa pove,\r\n# kako se ta \u010drka za\u0161ifrira. Tako bi na primer (poenostavljena verzija s samo\r\n# \u0161tirimi \u010drkami A,B,C,D) slovar `{'A': 'B', 'C': 'C', 'B': 'D', 'D': 'A'}`\r\n# pomenil, da se \u010drka A za\u0161ifrira v B, B v D, C se ne spremeni, D gre\r\n# pa v A.\r\n# Sestavi funkcijo `sifriraj(slovar, beseda)`, ki sprejme slovar s \u0161ifro\r\n# in besedo, vrne pa za\u0161ifrirano besedo. Predpostavi\u0161 lahko, da so v\r\n# besedi same velike \u010drke.", 
      "solution": "def sifriraj(slovar, beseda):\r\n    return ''.join([slovar[c] for c in beseda])\r\n", 
      "trial": "def trial(source):\r\n    if check_function('sifriraj', 2):\r\n        _equal('sifriraj(_slovar, \"KOLOKVIJ\")', \"IRHRINBA\")\r\n        _equal('sifriraj(_slovar, \"PESEM\")', \"JVTVU\")\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 54, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "#Sestavi funkcijo, ki bo uredila dani seznam nizov, v katerih so zapisana imena in priimki oseb.\r\n#V vsakem nizu je najprej ime, nato pa priimek. Funkcija naj osebe uredi po priimkih, tiste osebe,\r\n#ki imajo enak priimek, pa \u0161e po imenu. Nalogo re\u0161i z obi\u010dajno in anonimno funkcijo. Funkciji poimenuj\r\n# urediOsebe in urediOsebe2. Primer:\r\n#    >>> osebe = ['Janez Novak', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Ana Dolenc']\r\n#    >>> urediOsebe(osebe)\r\n#    ['Ana Dolenc', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Janez Novak']\r\n#    >>> osebe\r\n#    ['Ana Dolenc', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Janez Novak']", 
      "solution": "def vrednostOseba(oseba): return oseba.split()[::-1]\r\ndef urediOsebe1(s): \r\n   s.sort(key=vrednostOseba)\r\n   return s\r\n\r\ndef urediOsebe2(s): \r\n   s.sort(key=lambda oseba: oseba.split()[::-1])\r\n   return s", 
      "trial": "def trial(source):\r\n   _equal(\"urediOsebe(['Janez Novak', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Ana Dolenc'])\", ['Ana Dolenc', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Janez Novak'])\r\n   _equal(\"urediOsebe2(['Janez Novak', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Ana Dolenc'])\", ['Ana Dolenc', 'Miha Dolenc', 'Ana Novak', 'Darko Novak', 'Janez Novak'])\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 121, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavi funkcijo naloga2a, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga2a(slovar, ime):\r\n    return len(slovar.get(ime, []))", 
      "trial": "def trial(source):\r\n    if check_function('naloga2a', 2):\r\n        _equal('naloga2a(_prijatelji,\"Miha\")', 2)\r\n        _equal('naloga2a(_prijatelji, \"Franc\")', 0)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 72, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "#V seznamu imamo spravljen izpisek na\u0161ih telefonskih pogovorov.\r\n#Vsak element seznama je peterica `[leto,mesec,dan,ura,minuta]`, ki\r\n#opisuje \u010das, ko smo za\u010deli nek pogovor. Sestavi funkcijo `zgovorenDan`,\r\n#ki sprejme tak\u0161en izpisek in vrne trojko `[leto, mesec, dan]`, ki\r\n#opisuje najbolj *zgovoren* dan -- torej tistega, na katerega smo\r\n#opravili najve\u010d pogovorov. \u010ce je tak\u0161nih dni ve\u010d, naj funkcija vrne\r\n#tistega, ki se na izpisku pojavi prvi. Primer:\r\n#    >>> zgovorenDan([[2011, 4, 21, 13, 53], [2011, 4, 16, 0, 35],\r\n#       [2011, 4, 21, 2, 44], [2011, 4, 16, 9, 14], [2011, 4, 21, 13, 30],\r\n#       [2011, 4, 16, 22, 56], [2011, 4, 19, 15, 56], [2011, 4, 20, 12, 23],\r\n#       [2011, 4, 17, 17, 39], [2011, 4, 18, 9, 1], [2011, 4, 20, 12, 0],\r\n#       [2011, 4, 18, 10, 40], [2011, 4, 19, 9, 53], [2011, 4, 18, 8, 5],\r\n#       [2011, 4, 19, 3, 22], [2011, 4, 16, 4, 53], [2011, 4, 16, 12, 19],\r\n#       [2011, 4, 18, 11, 17], [2011, 4, 17, 17, 59], [2011, 4, 19, 12, 13]])\r\n#\r\n#    [2011, 4, 16]\r\n#    >>> zgovorenDan([[2011, 4, 19, 16, 12], [2011, 4, 20, 0, 21],\r\n#       [2011, 4, 18, 19, 30], [2011, 4, 20, 4, 46], [2011, 4, 17, 8, 36],\r\n#       [2011, 4, 16, 22, 54], [2011, 4, 17, 14, 56], [2011, 4, 16, 4, 4],\r\n#       [2011, 4, 21, 4, 5], [2011, 4, 19, 10, 0], [2011, 4, 21, 21, 50],\r\n#       [2011, 4, 17, 18, 1], [2011, 4, 16, 2, 53], [2011, 4, 16, 1, 12],\r\n#       [2011, 4, 20, 12, 19], [2011, 4, 17, 11, 26], [2011, 4, 19, 1, 20],\r\n#       [2011, 4, 20, 14, 58], [2011, 4, 19, 4, 33], [2011, 4, 20, 3, 1]])\r\n#\r\n#    [2011, 4, 20]", 
      "solution": "def zgovorenDan(klici):\r\n    # seznam dni, ko smo klicali\r\n    klici = [cas[:3] for cas in klici]\r\n\r\n    maxKlicev = 0  # st. klicev na najbolj zgovoren dan\r\n    for dan in klici:\r\n        kKlicev = klici.count(dan)\r\n        if kKlicev > maxKlicev:\r\n            maxKlicev = kKlicev\r\n            rezultat = dan\r\n    return None if maxKlicev == 0 else rezultat", 
      "trial": "def trial(source):\r\n    _equal('zgovorenDan([[2011, 4, 21, 13, 53], [2011, 4, 16, 0, 35], [2011, 4, 21, 2, 44], [2011, 4, 16, 9, 14], [2011, 4, 21, 13, 30], [2011, 4, 16, 22, 56], [2011, 4, 19, 15, 56], [2011, 4, 20, 12, 23], [2011, 4, 17, 17, 39], [2011, 4, 18, 9, 1], [2011, 4, 20, 12, 0], [2011, 4, 18, 10, 40], [2011, 4, 19, 9, 53], [2011, 4, 18, 8, 5], [2011, 4, 19, 3, 22], [2011, 4, 16, 4, 53], [2011, 4, 16, 12, 19], [2011, 4, 18, 11, 17], [2011, 4, 17, 17, 59], [2011, 4, 19, 12, 13]])', [2011, 4, 16])\r\n    _equal('zgovorenDan([[2011, 4, 19, 16, 12], [2011, 4, 20, 0, 21], [2011, 4, 18, 19, 30], [2011, 4, 20, 4, 46], [2011, 4, 17, 8, 36], [2011, 4, 16, 22, 54], [2011, 4, 17, 14, 56], [2011, 4, 16, 4, 4], [2011, 4, 21, 4, 5], [2011, 4, 19, 10, 0], [2011, 4, 21, 21, 50], [2011, 4, 17, 18, 1], [2011, 4, 16, 2, 53], [2011, 4, 16, 1, 12], [2011, 4, 20, 12, 19], [2011, 4, 17, 11, 26], [2011, 4, 19, 1, 20], [2011, 4, 20, 14, 58], [2011, 4, 19, 4, 33], [2011, 4, 20, 3, 1]])', [2011, 4, 20])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 87, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "#Sestavi funkcijo `rndinterval(a,b)`, ki vrne naklju\u010dno realno \u0161tevilo z\r\n#intervala [a,b).\r\n#Primer:\r\n#    >>> rndinterval(1,4)\r\n#    3.4592431331845415\r\n#    >>> rndinterval(1,1)\r\n#    1.0", 
      "solution": "def rndinterval(a,b):\r\n    return a+(b-a)*random.random()", 
      "trial": "def trial(source):\r\n    if check_function('rndinterval', 2):\r\n        for i in range(1,5):\r\n            for j in range(i+1,i+5):\r\n                _equal('{0}<=rndinterval({0},{1})<{1}'.format(i,j),True,'Funkcija rndinterval({0},{1}) ne vra\u010da vrednosti z intervala [{0},{1})'.format(i,j))\r\n        _equal('jeenakomerna(rndinterval,0,1)',True,'Funkcija ne vra\u010da enakomerno porazdeljenih vrednosti na intervalu [0,1)')\r\n        _equal('jeenakomerna(rndinterval,2,7)',True,'Funkcija ne vra\u010da enakomerno porazdeljenih vrednosti na intervalu [2,7)')\r\n        _equal('jeenakomerna(rndinterval,-2,-1)',True,'Funkcija ne vra\u010da enakomerno porazdeljenih vrednosti na intervalu [-2,-1)')\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 79, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavite funkcijo `skupnaTeza`. Kot argument naj sprejme slovar, \r\n# ki hrani podatke o tem, kak\u0161en tovor smo nalo\u017eili na tovornjak\r\n# (kot klju\u010d seznama) in kolik\u0161na je bila masa posameznih kosov tovora\r\n# (kot vrednost pri danem klju\u010du). Primer:\r\n#    >>> `skupnaTeza`({'televizor': 17, 'gajba piva': 3, 'zofa': 35})\r\n#    55", 
      "solution": "def skupnaTeza(slovar):\r\n    vsota = 0\r\n    for (kljuc, vrednost) in slovar.items(): vsota += vrednost\r\n    return vsota", 
      "trial": "def trial(source):\r\n    if check_function('skupnaTeza', 1):\r\n      _equal(\"skupnaTeza({'televizor': 17, 'gajba piva': 3, 'zofa': 35})\", 55)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 95, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# S pomo\u010djo datoteke 'besedilo.txt' na spletni u\u010dilnici\r\n# sestavi slovar frekvenc slovenskih \u010drk. V slovarju kot klju\u010de\r\n# hrani 25 \u010drk slovenske abecede in presledke, ostale znake pa ignoriraj. \r\n# Izra\u010dunaj tudi povprecno dolzino slovenske besede (tako, da deli\u0161\r\n# \u0161tevilo vseh prebranih \u010drk s \u0161tevilom presledkov pove\u010danim za 1).\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Metodi naj bo ime frekvence, vrne pa naj nabor\r\n# (slovar, povpre\u010dna dol\u017eina besede). Kot argument naj sprejme ime\r\n# datoteke, iz katere prebere besede.\r\n#", 
      "solution": "def frekvence(datoteka):\r\n    slovar = dict()\r\n    st=0\r\n    f=open(datoteka,\"r\",encoding=\"utf-8\")\r\n    for vrstica in f:\r\n        for c in vrstica:\r\n            c=' ' if c.isspace() else c.upper()\r\n            if c.isalpha() or c.isspace(): # \u010de je \u010drka ali presledek, jo damo v slovar\r\n                slovar[c] = slovar.get(c,0)+1\r\n                st+=1\r\n    f.close()\r\n    dolzinaBesede=st/(slovar.get(\" \",0)+1)\r\n    for k,v in slovar.items():\r\n        slovar[k]=v/st\r\n    return (slovar, dolzinaBesede)", 
      "trial": "def trial(source):\r\n    if check_function(\"frekvence\", 1):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 46, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavite funkcijo `razrezi(s, n)`, ki iz danega seznama `s` sestavi\r\n# in vrne seznam, sestavljen iz zaporednih podseznamov dol\u017eine `n`\r\n# prvotnega seznama. Zadnji podseznam je lahko kraj\u0161i od ostalih.\r\n# Funkcija naj prvotnega seznama ne spreminja.", 
      "solution": "def razrezi(s, n):\r\n    razrezan = []\r\n    i = 0\r\n    while i + n < len(s):\r\n        razrezan.append(s[i : i + n])\r\n        i += n\r\n    razrezan.append(s[i:])\r\n    return razrezan", 
      "trial": "def trial(source):\r\n    _equal('razrezi([1, 4, 2, 4, 7, 7, 3, 2], 2)', [[1, 4], [2, 4], [7, 7], [3, 2]])\r\n    _equal('razrezi([1, 4, 2, 4, 7, 7, 3, 2], 3)', [[1, 4, 2], [4, 7, 7], [3, 2]])\r\n    _equal('razrezi([1, 4, 2, 4, 7, 7, 3, 2], 1)', [[1], [4], [2], [4], [7], [7], [3], [2]])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 103, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavite funkcijo `najvecja_razlika(spremembe)`, ki poi\u0161\u010de najve\u010dji\r\n# relativni priliv. Z drugimi besedami, poi\u0161\u010de najve\u010djo vrednost, ki jo\r\n# zavzame vsota poljubnega strnjenega podseznama.\r\n# Tako na primer `najvecja_razlika([10, -13, 3, 20, -2, 5])` vrne\r\n# 3 + 20 - 2 + 5 = 26.\r\n# \u010ce je seznam `spremembe` prazen, naj funkcija vrne `None`.", 
      "solution": "def najvecja_razlika(spremembe):\r\n    if spremembe:\r\n        n = len(spremembe)\r\n        return max(razlika(spremembe, i, j)\r\n                   for i in range(0, n)\r\n                   for j in range(i, n))", 
      "trial": "def trial(source):\r\n    if check_function('najvecja_razlika', 1):\r\n        _equal('najvecja_razlika([10, -13, 3, 20, -2, 5])', 26)\r\n        _equal('najvecja_razlika([1, 2, 3])', 6)\r\n        _equal('najvecja_razlika([])', None)\r\n        _equal('najvecja_razlika([1, -5, -20, 30])', 30)\r\n        _equal('najvecja_razlika([10, -5, 20, -6])', 25)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 153, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Imamo kino dvorano velikosti `MxN` (M vrst, v vsaki N sede\u017eev).\r\n# Sestavi funkcijo `jedvorana(velikost,sedezi)`, ki sprejme dva parametra:\r\n# nabor `(M, N)` dol\u017eine 2, ki predstavlja velikost dvorane ter slovar, v\r\n# katerem so pari `(x,y):v`. Nabor `(x,y)` predstavlja sede\u017e y v vrsti x,\r\n# v pa je vi\u0161ina \u010dloveka v decimetrih, ki sedi na tem sede\u017eu. Pozor: ni\r\n# nujno, da so vsi sede\u017ei zasedeni!\r\n# Funkcija naj vrne True, \u010de so vsi podatki veljavni in False sicer.\r\n# Podatki so veljavni, \u010de se sede\u017e nahaja v dvorani (tj. 1 <= x <= M,\r\n# 1 <= y <= N).", 
      "solution": "def jedvorana(v,s):\r\n    (m, n) = v\r\n    for (x, y), v in s.items():\r\n        if not (1 <= x <= m and 1 <= y <= n):\r\n            return False\r\n    return True", 
      "trial": "def trial(source):\r\n    if check_function('jedvorana', 2):\r\n        _equal('jedvorana((3, 4), {(1, 2): 17.5, (3, 4): 16.5})', True)\r\n        _equal('jedvorana((3, 4), {(1, 2): 17.5, (30, 40): 16.5})', False)\r\n        _equal('jedvorana((3, 4), {})', True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 249, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Sestavi funkcijo 'preberi', ki uporabnika vpra\u0161a za ime spremenljivke \r\n# (uporabi ukaz input) in vrednost, ter jo vrne kot nabor (ime, vrednost).", 
      "solution": "def preberi():\r\n    ime = input('Vnesi ime:')\r\n    vrednost = input('Vnesi vrednost:')\r\n    return (ime, vrednost)", 
      "trial": "def trial(source):\r\n    import sys\r\n    _makefile0('_2a.in', 'test', 'me')\r\n    old_stdin = sys.stdin\r\n    sys.stdin = open('_2a.in')\r\n    if check_function('preberi', 0):\r\n        _equal('preberi()', ('test', 'me'))\r\n    sys.stdin = old_stdin\r\n    _removefiles(\"_2a.in\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 279, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# Lojzku je dolg\u010das, zato se igra z velikimi praznimi \u0161katlami, ki se\r\n# nahajajo v skladi\u0161\u010du, v katerem dela. Dimenzije \u0161katel so shranjene v\r\n# seznamu  trojic. Na primer, trojica `(50, 100, 100)` predstavlja\r\n# \u0161katlo, ki je visoka 50 cm ter \u0161iroka in dolga 100 cm.\r\n#\r\n# Sestavite funkcijo `stolp(skatle)`, ki vrne vi\u0161ino najvi\u0161jega\r\n# stolpa, ki ga lahko sestavimo iz \u0161katel, ne da bi jih obra\u010dali.\r\n# Pri tem ni treba paziti na stabilnost stolpa.\r\n# Na primer, najvi\u0161ji tak stolp iz \u0161katel z dimenzijami (50, 100, 100),\r\n# (60, 50, 50) in (40, 40, 40) bi imel vi\u0161ino 150 cm.", 
      "solution": "def stolp(skatle):\r\n    return sum(v for v, _, _ in skatle)", 
      "trial": "def trial(source):\r\n    if check_function('stolp', 1):\r\n        _equal('stolp([(50, 100, 100), (60, 30, 50), (40, 40, 40)])', 150)\r\n        _equal('stolp([(50, 100, 100), (60, 50, 50), (40, 40, 40)])', 150)\r\n        _equal('stolp([(60, 30, 50), (40, 40, 40)])', 100)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 201, 
    "model": "problem.part", 
    "fields": {
      "_order": 4, 
      "description": "# V slovarju 'd' imamo podane prehode za nek kon\u010dni avtomat. Pri tem vrednost\n# za $y=d[x]$ predstavlja stanje, v katerega preidemo, \u010de se trenutno\n# nahajamo v stanju $x$. Sestavi funkcijo 'prehod', ki kot parametra dobi \n# trenutno stanje in slovar prehodov, vrne pa novo stanje.\n# Primer: \n#    >>> prehod('a', {'a': 'b', 'c': 'a', 'b': 'c'})\n#    'b'", 
      "solution": "def prehod(trenutnoStanje,prehodi):\n    return prehodi[trenutnoStanje]", 
      "trial": "def trial(source):\n    if check_function('prehod', 2):\n        _equal(\"prehod('a', {'a': 'b', 'c': 'a', 'b': 'c'})\", 'b')\n        _equal(\"prehod('2', {'1': '3', '2': '1', '3': '2'})\", '1')\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 73, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "#Sestavi funkcije `delitelji`, `prastevila`, `delneVsote`, ki\r\n#zgradijo spodnje sezname. Uporabi izpeljane sezname.\r\n#\r\n#* Seznam vseh pozitivnih deliteljev \u0161tevila *n*.\r\n#* Seznam vseh pra\u0161tevil od *a* do *b* (pomagaj si s funkcijo `jePrastevilo`\r\n#  iz vaj o zankah (Naloga 6)).\r\n#* Seznam vseh vsot strnjenih podzaporedij dol\u017eine *k* v danem seznamu.\r\n#\r\n#Primer:\r\n#    >>> delitelji(60)\r\n#    [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60]\r\n#    >>> prastevila(0, 50)\r\n#    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\r\n#    >>> delneVsote([1, 4, 3, 8, 5, 6, 3, 6, 4, 5], 3)\r\n#    [8, 15, 16, 19, 14, 15, 13, 15]", 
      "solution": "def delitelji(n):\r\n    n = abs(n)\r\n    return [i for i in range(1, n + 1) if n % i == 0]\r\n\r\ndef prastevilo(n):\r\n    d = 2\r\n    while d ** 2 <= n:\r\n        if n % d == 0: return False\r\n        d += 1\r\n    return n > 1\r\n\r\ndef prastevila(a, b):\r\n    return [i for i in range(a, b + 1) if prastevilo(i)]\r\n\r\ndef delneVsote(s, k):\r\n    return [sum(s[i:i + k]) for i in range(len(s) - k + 1)]", 
      "trial": "def trial(source):\r\n    _equal('delitelji(60)', [1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30, 60])\r\n    _equal('delitelji(37)', [1, 37])\r\n    _equal('prastevila(0, 50)', [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47])\r\n    _equal('prastevila(7,12)', [7, 11])\r\n    _equal('prastevila(7,13)', [7, 11, 13])\r\n    _equal('delneVsote([1, 4, 3, 8, 5, 6, 3, 6, 4, 5], 3)', [8, 15, 16, 19, 14, 15, 13, 15])\r\n    _equal('delneVsote([1, 4, 3, 8, 5, 6], 1)', [1, 4, 3, 8, 5, 6])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 80, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "#Dan je seznam besed s in \u0161tevilo n. \r\n# Sestaviti \u017eelimo slovar, katerega klju\u010di so za\u010detki besed dol\u017eine n \r\n# iz seznama s. Vrednosti so besede, ki se za\u010dnejo z danim klju\u010dem. \r\n# \u010ce je kaka beseda v seznamu kraj\u0161a od n, je kar eden od klju\u010dev. \r\n# Sestavi funkcijo `slovar`, ki iz danega seznama s sestavi tak slovar.\r\n#Primer: \r\n#    >>> `slovar`(['jajca', 'moka', 'sladkor', 'jabolka', 'sladoled'], 2)\r\n#    {'ja': ['jajca', 'jabolka'], 'mo': ['moka'], 'sl': ['sladkor', 'sladoled']}\r\n#    >>> `slovar`(['enostaven', 'en', 'enotno'], 3)\r\n#    {'en': ['en'], 'eno': ['enostaven', 'enotno']}", 
      "solution": "def slovar(seznam, n):\r\n  slovar = dict()\r\n  for beseda in seznam:\r\n    kljuc = beseda[0:n]\r\n    if kljuc not in slovar:  slovar[kljuc] = []\r\n    slovar[kljuc].append(beseda)\r\n  return slovar", 
      "trial": "def trial(source):\r\n    if check_function('slovar', 2):\r\n      _equal(\"slovar(['jajca', 'moka', 'sladkor', 'jabolka', 'sladoled'], 2)\", {'ja': ['jajca', 'jabolka'], 'mo': ['moka'], 'sl': ['sladkor', 'sladoled']})\r\n      _equal(\"slovar(['enostaven', 'en', 'enotno', 'nikola'], 3)\",  {'en': ['en'], 'eno': ['enostaven', 'enotno'], 'nik': ['nikola']})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 6, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Osemvrsti\u010dno smre\u010dico izpi\u0161ite \u0161e sredinsko poravnano in z razmaki.\r\n# Na primer:\r\n#         *\r\n#        * *\r\n#       * * *\r\n#      * * * *\r\n#     * * * * *\r\n# Pri tem ne smete uporabiti niza z ve\u010d kot eno zvezdico.\r\n# Namig: levi rob je enak kot pri desno poravnani smre\u010dici,\r\n# \\       za vsakim osnovnim znakom pa je presledek.", 
      "solution": "znak = \"* \"\r\nprint(7 * \" \" + 1 * znak + \"\\n\" +\r\n      6 * \" \" + 2 * znak + \"\\n\" +\r\n      5 * \" \" + 3 * znak + \"\\n\" +\r\n      4 * \" \" + 4 * znak + \"\\n\" +\r\n      3 * \" \" + 5 * znak + \"\\n\" +\r\n      2 * \" \" + 6 * znak + \"\\n\" +\r\n      1 * \" \" + 7 * znak + \"\\n\" +\r\n      8 * znak)", 
      "trial": "def trial(source):\r\n    preveriSmrecico(izpis(source), range(7, -1, -1), range(8, 17), dovoljeni)\r\n    if \"* *\" in re.sub(r'#.*', '', source):\r\n        _warn(\"V programu nastopata dve zaporedni zvezdici.\")\r\n\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 1
    }
  }, 
  {
    "pk": 88, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "#Sestavi funkcijo `priblizekPi(N)`, ki s pomo\u010djo Monte Carlo simulacije\r\n#izra\u010duna pribli\u017eek \u0161tevila Pi tako, da generira N naklju\u010dnih\r\n#to\u010dk v enotskem kvadratu [0,1]x[0,1] in pre\u0161teje, koliko jih je znotraj\r\n#dela enotskega kroga, ki le\u017ei v enotskem kvadratu (najprej ugotovi, kaj\r\n#mora veljati za to\u010dko (x,y), da le\u017ei znotraj enotskega kroga). Razmerje\r\n#med tem \u0161tevilom in N je pribli\u017eek za razmerje plo\u0161\u010din, ki je Pi/4. Od\r\n#tod lahko izra\u010dunamo pribli\u017eek za Pi.\r\n#Primer:\r\n#    >>> priblizekPi(1000)\r\n#    3.228\r\n#    >>> priblizekPi(100000)\r\n#    3.14188", 
      "solution": "def priblizekPi(N):\r\n    x=[random.random() for i in range(N)]\r\n    y=[random.random() for i in range(N)]\r\n    st=0\r\n    for i in range(N):\r\n        if x[i]**2+y[i]**2 <= 1: st+=1\r\n    return 4*st/N\r\n", 
      "trial": "def trial(source):\r\n    if check_function('priblizekPi', 1):\r\n        _equal('3.1<priblizekPi(10000)<3.2',True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 250, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo 'dodaj', ki kot parameter dobi slovar s spremenljivkami in\r\n# nabor (ime, vrednost). \u010ce spremenljivka v slovarju \u017ee obstaja, naj\r\n# funkcija vrne False, sicer pa naj spremenljivko doda v slovar in vrne\r\n# True.", 
      "solution": "def dodaj(slovar, nabor):\r\n    (i, v) = nabor\r\n    if i in slovar:\r\n        return False\r\n    else:\r\n        slovar[i] = v\r\n        return True", 
      "trial": "def trial(source):\r\n    if check_function('dodaj', 2):\r\n        d = {'a': 1, 'b': 3}\r\n        _equal('dodaj({\"a\": 1, \"b\": 3}, (\"a\", 0))', False)\r\n        _equal('dodaj({\"a\": 1, \"b\": 3}, (\"c\", 0))', True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 104, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# V slovarju imamo shranjeno permutacijo naravnih \u0161tevil od $1$ do $n$.\r\n# Na primer, permutacijo, ki transponira \u0161tevili $1$ in $3$, $2$ pa\r\n# pusti pri miru, zapi\u0161emo s slovarjem `{1: 3, 2: 2, 3: 1}`.\r\n#\r\n# Sestavite funkcijo `slika(permutacija, x)`, vrne pa sliko \u0161tevila `n`\r\n# s podano permutacijo.\r\n# Predpostavite lahko, da je dano \u0161tevilo v domeni permutacije.", 
      "solution": "def slika(permutacija, x):\r\n    return permutacija[x]", 
      "trial": "def trial(source):\r\n    if check_function('slika', 2):\r\n        _equal('slika({1: 3, 2: 4, 3: 2, 4: 1}, 1)', 3)\r\n        _equal('slika({1: 3, 2: 4, 3: 2, 4: 1}, 2)', 4)\r\n        _equal('slika({1: 3, 2: 4, 3: 2, 4: 1}, 3)', 2)\r\n        _equal('slika({1: 3, 2: 4, 3: 2, 4: 1}, 4)', 1)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 47, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavite funkcijo `zlepek(s1, s2)`, ki sestavi in vrne izmeni\u010dni\r\n# zlepek seznamov `s1` in `s2`. Izmeni\u010dni zlepek dobimo tako, da\r\n# izmeni\u010dno jemljemo elemente iz prvega in drugega seznama, ko elementov\r\n# v enem seznamu zmanjka, pa dodamo \u0161e vse preostale elemente iz drugega\r\n# seznama.", 
      "solution": "def zlepek(s1, s2):\r\n    zlepljen = []\r\n    n = min(len(s1), len(s2))\r\n    for i in range(n):\r\n        zlepljen.append(s1[i])\r\n        zlepljen.append(s2[i])\r\n    zlepljen += s1[n:]\r\n    zlepljen += s2[n:]\r\n    return zlepljen", 
      "trial": "def trial(source):\r\n    _equal('zlepek([1, 2, 3], [4, 5, 6])', [1, 4, 2, 5, 3, 6])\r\n    _equal('zlepek([1, 2, 3], [4, 5, 6, 7, 8, 9])', [1, 4, 2, 5, 3, 6, 7, 8, 9])\r\n    _equal('zlepek([1, 2, 3, 7, 8, 9], [4, 5, 6])', [1, 4, 2, 5, 3, 6, 7, 8, 9])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 170, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo `predstavnik(mnozica, k, n), ki kot parametre dobi\r\n# mno\u017eico celih \u0161tevil, naravno \u0161tevilo k in \u0161tevilo n, 0 <= n < k,\r\n# vrne pa najmanj\u0161e \u0161tevilo v mno\u017eici, katerega ostanek pri deljenju s\r\n# k je enak n. To \u0161tevilo imenujemo predstavnik. \u010ce takega \u0161tevila ni, naj\r\n# funkcija vrne None.\r\n", 
      "solution": "def predstavnik(m, k, n):\r\n    p=None\r\n    for x in m:\r\n        if x%k == n:\r\n            if p==None or p>x:\r\n                p=x\r\n    return p\r\n", 
      "trial": "def trial(source):\r\n    if check_function('predstavnik', 3):\r\n        _equal('predstavnik({1, 2, 12, 7, 5, 9, 15}, 4, 3)', 7)\r\n        _equal('predstavnik({0, 2, 4}, 5, 1)', None)\r\n        _equal('predstavnik({-10, 5, 7, 3, 10}, 6, 2)', -10)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 26, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo pravokotnika, ki bo izra\u010dunala obseg in povr\u0161ino unije dveh pravokotnikov. \r\n# Stranice pravokotnikov so vzporedne koordinatnima osema. Vsak pravokotnik \r\n# je podan s koordinatami (katerihkoli) dveh nasprotnih si ogli\u0161\u010d.\r\n# Primer:\r\n#    >>> pravokotnika(1, 1, 5, 5, 6, 8, 8, 3)\r\n#    (30, 26)\r\n#    >>> pravokotnika(1, 1, 5, 5, 4, 8, 8, 3)\r\n#    (28, 34)", 
      "solution": "def pravokotnika(ax1, ay1, bx1, by1, ax2, ay2, bx2, by2):\r\n    if ax1 > bx1: ax1, bx1 = bx1, ax1\r\n    if ay1 > by1: ay1, by1 = by1, ay1\r\n    if ax2 > bx2: ax2, bx2 = bx2, ax2\r\n    if ay2 > by2: ay2, by2 = by2, ay2\r\n\r\n    ax3 = max(ax1, ax2)\r\n    ay3 = max(ay1, ay2)\r\n    bx3 = min(bx1, bx2)\r\n    by3 = min(by1, by2)\r\n\r\n    obseg = 2 * (bx1 - ax1 + by1 - ay1 + bx2 - ax2 + by2 - ay2)\r\n    ploscina = (bx1 - ax1) * (by1 - ay1) + (bx2 - ax2) * (by2 - ay2)\r\n\r\n    if ax3 <= bx3 and ay3 <= by3:\r\n        obseg -= 2 * (bx3 - ax3 + by3 - ay3)\r\n        ploscina -= (bx3 - ax3) * (by3 - ay3)\r\n\r\n    return obseg, ploscina\r\n", 
      "trial": "def trial(source):\r\n  podatki = [[random.randint(1, 20) for i in range(8)] for i in range(20)]\r\n  if check_function(\"pravokotnika\", 8):\r\n    for test in podatki:\r\n      (ax1, ay1, bx1, by1, ax2, ay2, bx2, by2) = (test[0], test[1], test[2],test[3],test[4], test[5], test[6],test[7])\r\n      if ax1 > bx1: ax1, bx1 = bx1, ax1\r\n      if ay1 > by1: ay1, by1 = by1, ay1\r\n      if ax2 > bx2: ax2, bx2 = bx2, ax2\r\n      if ay2 > by2: ay2, by2 = by2, ay2\r\n      ax3 = max(ax1, ax2)\r\n      ay3 = max(ay1, ay2)\r\n      bx3 = min(bx1, bx2)\r\n      by3 = min(by1, by2)\r\n      obseg = 2 * (bx1 - ax1 + by1 - ay1 + bx2 - ax2 + by2 - ay2)\r\n      ploscina = (bx1 - ax1) * (by1 - ay1) + (bx2 - ax2) * (by2 - ay2)\r\n      if ax3 <= bx3 and ay3 <= by3:\r\n        obseg -= 2 * (bx3 - ax3 + by3 - ay3)\r\n        ploscina -= (bx3 - ax3) * (by3 - ay3)\r\n      res = (obseg, ploscina)\r\n      _equal(\"pravokotnika({0}, {1}, {2}, {3}, {4}, {5}, {6}, {7})\".format(ax1, ay1, bx1, by1, ax2, ay2, bx2, by2), res)\r\n  yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 5
    }
  }, 
  {
    "pk": 40, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavite funkcijo `poudari(naslov)`, ki vrne naslov, poudarjen tako,\r\n# da so vse \u010drke velike in med seboj lo\u010dene s presledki. Presledke\r\n# obravnavajte tako kot ostale znake (spremenijo se v trojni presledek).\r\n# Pazite, da se niz ne kon\u010da s presledkom.\r\n#\r\n# _Na primer_: klic `poudari(\"Zadnja novica\")` naj vrne niz\r\n# `\"Z A D N J A   N O V I C A\"`.\r\n", 
      "solution": "def poudari(naslov):\r\n    poudarjen = ''\r\n    for z in naslov:\r\n        poudarjen += z.upper()\r\n        poudarjen += \" \"\r\n    return poudarjen[:-1]\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"poudari\", 1):\r\n        _equal(\"poudari('Zadnja novica')\", 'Z A D N J A   N O V I C A')\r\n        _equal(\"poudari('Podkupnine vsepovsod')\", 'P O D K U P N I N E   V S E P O V S O D')\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 154, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo `kjenajvisji(slovar)`, ki kot parameter dobi slovar\r\n# zasedenosti in poi\u0161\u010de polo\u017eaj najvi\u0161jega \u010dloveka. \u010ce je takih ve\u010d, naj\r\n# vrne seznam vseh polo\u017eajev.", 
      "solution": "def kjenajvisji(s):\r\n    max_visina = max(s.values())\r\n    return [(x, y) for (x, y), v in s.items() if v == max_visina]", 
      "trial": "def trial(source):\r\n    if check_function('kjenajvisji', 1):\r\n        _equal('kjenajvisji({(1, 2): 17.5, (3, 4): 16.5})', [(1, 2)])\r\n        _equal('kjenajvisji({(1, 2): 17.5, (30, 40): 18.5})', [(30, 40)])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 32, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavite funkcijo `jePrastevilo(n)`, ki vrne `True`, \u010de `n` je\r\n# pra\u0161tevilo, in `False`, \u010de ni.", 
      "solution": "def jePrastevilo(n):\r\n    if n == 1:\r\n        return False\r\n    if n == 2:\r\n        return True\r\n    i = 2\r\n    while i ** 2 <= n:\r\n        if n % i == 0:\r\n            return False\r\n        i += 1\r\n    return True", 
      "trial": "def trial(source):\r\n    if check_function(\"jePrastevilo\", 1):\r\n        _equal('jePrastevilo(1)', False)\r\n        _equal('jePrastevilo(2)', True)\r\n        _equal('jePrastevilo(3)', True)\r\n        _equal('jePrastevilo(23)', True)\r\n        _equal('jePrastevilo(42)', False)\r\n        _equal('jePrastevilo(97)', True)\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 139, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo `jeBijekcija(slovar)`, ki sprejme slovar s \u0161ifro in\r\n# ugotovi, ali slovar predstavlja bijekcijo mno\u017eice \u010drk slovenske abecede.\r\n", 
      "solution": "def jeBijekcija(slovar):\r\n    if len(slovar.keys()) == 25 and len(set(slovar.values())) == 25:\r\n        crke=\"ABC\u010cDEFGHIJKLMNOPRS\u0160TUUVZ\u017d\"\r\n        for k,v in slovar.items():\r\n            if not (k in crke and v in crke):\r\n                return False\r\n        return True\r\n    else:\r\n        return False", 
      "trial": "def trial(source):\r\n    if check_function('jeBijekcija', 1):\r\n        _equal('jeBijekcija(_slovar)', True)\r\n        _equal('jeBijekcija(_neslovar)', False)\r\n        _equal('jeBijekcija(_neslovar2)', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 96, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "#\r\n# S pomo\u010djo slovarja, ki si ga zgradil v prej\u0161nji nalogi, generiraj \r\n# naklju\u010dno besedilo, ki upo\u0161teva prave frekvence \u010drk.\r\n# Ime metode naj bo nakljucnoBesedilo. Besedilo naj vrne v obliki\r\n# niza dol\u017eine n, kjer n sprejme kot argument metode.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#", 
      "solution": "def nakljucnoBesedilo(dolzina):\r\n    slovar,d = frekvence(\"besedilo.txt\")\r\n    S=list(slovar.values())\r\n    K=list(slovar.keys())\r\n    niz=''.join([K[rnds(S)] for i in range(dolzina)])\r\n    return niz", 
      "trial": "def trial(source):\r\n    if check_function(\"nakljucnoBesedilo\", 1):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 122, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo naloga2b, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga2b(slovar, ime):\r\n    m=set()\r\n    for k,v in slovar.items():\r\n        if ime in v:\r\n            m.add(k)\r\n    return m", 
      "trial": "def trial(source):\r\n    if check_function('naloga2b', 2):\r\n        _equal('naloga2b(_prijatelji,\"Miha\")', {'Joze', 'Jernej'})\r\n        _equal('naloga2b(_prijatelji, \"Franc\")', {'Miha', 'Jernej'})\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 202, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi funkcijo kateraStanja, ki kot parametre dobi slovar prehodov, \n# trenutno stanje in naravno \u0161tevilo $n$, vrne pa seznam stanj, \n# ki jih obi\u0161\u010demo v n korakih. Seznam naj bo urejen po vrsti: \n# i-ti element v njem naj bo stanje, ki ga obi\u0161\u010demo v i-tem koraku,\n# Primer:\n#    >>> kateraStanja({'a': 'b', 'c': 'a', 'b': 'c'}, 'a', 2)\n#    ['b', 'c']", 
      "solution": "def kateraStanja(prehodi, trenutno, n):\n    stanja = []\n    for i in range(n):\n      trenutno = prehodi[trenutno]\n      stanja.append(trenutno)\n    return stanja", 
      "trial": "def trial(source):\n    if check_function('kateraStanja', 3):\n        _equal(\"kateraStanja({'a': 'b', 'c': 'a', 'b': 'c'}, 'a', 2)\", ['b', 'c'])\n        _equal(\"kateraStanja({0: 9, 1: 6, 2: 2, 3: 3, 4: 0, 5: 8, 6: 5, 7: 1, 8: 7, 9: 4}, 5, 4)\", [8, 7, 1, 6])\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 17, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavi program, ki bo izpisal prvih 10 \u010dlenov posplo\u0161enega Fibonaccijevega zaporedja: \r\n#    f1 = a, f2 = b, fn = fn-1 + fn-2. \r\n# Predpostavite, da sta prva dva \u010dlena zaporedja shranjena v spremenljivkah a in b. \r\n# Nalogo poskusi re\u0161iti brez uporabe dodatnih spremenljivk (samo z a in b).\r\n# Primer: za \r\na = 1\r\nb = 1\r\n# naj program izpi\u0161e\r\n#    1\r\n#    1\r\n#    2\r\n#    3\r\n#    5\r\n#    8\r\n#    13\r\n#    21\r\n#    34\r\n#    55", 
      "solution": "print(a)\r\nprint(b)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n(a,b) = (a+b,a)\r\nprint(a)\r\n", 
      "trial": "import random \r\nimport math\r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer so definirane spremenljivke v kodi\r\n    # in jih nadomestimo s svojimi\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    d = dict()\r\n    a = random.randint(1,5)\r\n    b = random.randint(a, 3*a)\r\n    za, zb = a, b\r\n    d[\"a\"] = a\r\n    d[\"b\"] = b\r\n    pizpis = str(a)+\"\\n\"+str(b)\r\n    for i in range(8):\r\n        (a,b) = (b,a+b)\r\n        pizpis += \"\\n\" + str(b)\r\n\r\n    (d, izpis) = izvedi(source, d)\r\n    if izpis.strip() != pizpis:\r\n        _warn(\"Izpis za za\u010detna \u010dlena a = {0} in b = {1} je napa\u010dne oblike: \\n{2}\".format(za,zb, izpis.strip()))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 280, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "# Sestavite funkcijo `najvisjiStolp(skatle)`, ki vrne vi\u0161ino najvi\u0161jega\r\n# stolpa, ki ga lahko sestavimo iz \u0161katel, \u010de jih lahko obra\u010damo.\r\n# Pri tem \u0161e vedno ni treba paziti na stabilnost stolpa.\r\n# Na primer, najvi\u0161ji tak stolp iz \u0161katel z dimenzijami (50, 100, 100),\r\n# (60, 50, 50) in (40, 40, 40) bi imel vi\u0161ino 200 cm, saj bi prvo \u0161katlo\r\n# prevrnili na bok.", 
      "solution": "def najvisjiStolp(skatle):\r\n    return sum(max(v, s, d) for v, s, d in skatle)", 
      "trial": "def trial(source):\r\n    if check_function('najvisjiStolp', 1):\r\n        _equal('najvisjiStolp([(50, 100, 100), (60, 30, 50), (40, 40, 40)])', 200)\r\n        _equal('najvisjiStolp([(50, 100, 100), (60, 50, 50), (40, 40, 40)])', 200)\r\n        _equal('najvisjiStolp([(60, 30, 50), (40, 40, 40)])', 100)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 55, 
    "model": "problem.part", 
    "fields": {
      "_order": 5, 
      "description": "#Sestavi funkcijo, ki za parametra dobi dve funkciji (obe sta funkciji z enim parametrom).\r\n#Funkcija naj vrne kompozitum teh dveh funkcij (torej novo funkcijo). Primer:\r\n#    >>> from math import *\r\n#    >>> sinus = kompozitum2(sin, radians)\r\n#    >>> sinus(90)\r\n#    1.0\r\n#    >>> sinus(45)\r\n#    0.707106781187", 
      "solution": "def kompozitum2(f, g): return lambda x: f(g(x))", 
      "trial": "def trial(source):\r\n   from math import sin,radians\r\n   _equal('round(kompozitum2(sin, radians)(90),7)',1.0)\r\n   _equal('round(kompozitum2(sin, radians)(45),7)',0.7071068)\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 33, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavite funkcijo `prastevilo(n)`, ki vrne `n`-to pra\u0161tevilo.", 
      "solution": "def prastevilo(n):\r\n    i = 1\r\n    kandidat = 2\r\n    while i < n:\r\n        kandidat += 1\r\n        if jePrastevilo(kandidat):\r\n            i += 1\r\n    return kandidat", 
      "trial": "def trial(source):\r\n    if check_function(\"prastevilo\", 1):\r\n        _equal('prastevilo(1)', 2)\r\n        _equal('prastevilo(2)', 3)\r\n        _equal('prastevilo(3)', 5)\r\n        _equal('prastevilo(23)', 83)\r\n        _equal('prastevilo(42)', 181)\r\n        _equal('prastevilo(97)', 509)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 140, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo `inverz(slovar)`, ki sprejme slovar s \u0161ifro in vrne\r\n# njen inverz, \u010de ta obstaja. Inverz obstaja, \u010de slovar predstavlja bijekcijo\r\n# mno\u017eice \u010drk. \u010ce inverz ne obstaja, naj funkcija vrne None.\r\n", 
      "solution": "def inverz(slovar):\r\n    if not jeBijekcija(slovar):\r\n        return None\r\n    s=dict()\r\n    for k,v in slovar.items():\r\n        s[v]=k\r\n    return s", 
      "trial": "def trial(source):\r\n    if check_function('inverz', 1):\r\n        _equal('_preveriinverz(_slovar,inverz(_slovar))', True)\r\n        _equal('inverz(_neslovar)', None)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 48, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavite funkcijo `premesaj(s)`, ki iz danega seznama sestavi in vrne\r\n# nov seznam, ki bo sestavljen iz elementov prvotnega seznama v\r\n# preme\u0161anem vrstnem redu. Pri sestavljanju novega seznama naj izmeni\u010dno\r\n# jemlje po en element iz za\u010detka in s konca seznama.", 
      "solution": "def premesaj(s):\r\n    premesan = []\r\n    n = len(s)\r\n    for i in range(n // 2):\r\n        premesan.append(s[i])\r\n        premesan.append(s[n - i - 1])\r\n    if n % 2 != 0:\r\n        premesan.append(s[n // 2])\r\n    return premesan", 
      "trial": "def trial(source):\r\n    _equal('premesaj([1, 2, 3, 4, 5, 6])', [1, 6, 2, 5, 3, 4])\r\n    _equal('premesaj([1, 2, 3, 4, 5, 6, 7])', [1, 7, 2, 6, 3, 5, 4])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 8
    }
  }, 
  {
    "pk": 18, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Za torto potrebujemo 0.8 kg margarine, 2 kg moke in 1.5 kg sladkorja. \r\n# Sestavi program, ki iz koli\u010dine sestavin, ki jih imamo na razpolago, izra\u010duna \r\n# najve\u010dje mo\u017eno \u0161tevilo tort, ki jih lahko naredimo, ter rezultat shrani v spremenljivki z \r\n# imenom koliko_tort. Koli\u010dine sestavin bodo zapisane v spremenljivkah z imeni margarina, moka in sladkor. Namig: Uporabi funkcijo min, ki vrne najmanj\u0161ega izmed svojih parametrov.\r\n# Primer: za vrednosti\r\nmargarina = 5\r\nmoka = 7\r\nsladkor = 3.5\r\n# naj se v spremenljivko koliko_tort zapi\u0161e vrednost 2.", 
      "solution": "koliko_tort = int(min(margarina // 0.8, moka // 2, sladkor // 1.5 ))", 
      "trial": "import random \r\nimport math\r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer so definirane spremenljivke v kodi\r\n    # in jih nadomestimo s svojimi\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    d = dict()\r\n    sladkor = random.randint(3, 20)\r\n    moka = random.randint(3, 20)   \r\n    margarina = random.randint(3, 20)\r\n    d[\"sladkor\"] = sladkor\r\n    d[\"moka\"] = moka\r\n    d[\"margarina\"] = margarina\r\n    koliko_tort = int(min(margarina // 0.8, moka // 2, sladkor // 1.5 ))\r\n    (d, izpis) = izvedi(source, d)\r\n    if \"koliko_tort\" not in d:\r\n        _warn(\"Spremenljivka koliko_tort ni definirana.\")\r\n    elif d[\"koliko_tort\"] != koliko_tort:\r\n        _warn(\"Spremenljivka koliko_tort za argumente margarina = {0}, moka = {1} in sladkor = {2} nima prave vrednosti.\".format(margarina, moka, sladkor))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 74, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "#Sestavi funkcijo `diagonalna`, ki zgradi in vrne diagonalno matriko,\r\n#ki ima po diagonali elemente danega seznama. Uporabi gnezden\r\n#izpeljan seznam. Primer:\r\n#    >>> diagonalna([1, 2, 3, 4])\r\n#    [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]", 
      "solution": "def diagonalnaMatrika(s):\r\n    n = len(s)\r\n    return [[s[i] if i == j else 0 for i in range(n)] for j in range(n)]", 
      "trial": "def trial(source):\r\n    _equal('diagonalnaMatrika([1, 2, 3, 4])', [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]])\r\n    _equal('diagonalnaMatrika([1])',[[1]])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 10
    }
  }, 
  {
    "pk": 171, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo `predstavniki(mnozica, k)`, ki kot parametra dobi\r\n# mno\u017eico celih \u0161tevil in naravno \u0161tevilo k, vrne pa slovar predstavnikov,\r\n# tj. klju\u010di so ostanki po modulu k, ki nastopajo v dani mno\u017eici, vrednost\r\n# za vsak klju\u010d pa je ustrezen predstavnik.\r\n", 
      "solution": "def predstavniki(m, k):\r\n    o=ostanki(m, k)\r\n    d={}\r\n    for n in o:\r\n        d[n]=predstavnik(m, k, n)\r\n    return d\r\n", 
      "trial": "def trial(source):\r\n    if check_function('predstavniki', 2):\r\n        _equal('predstavniki({1, 2, 12, 7, 5, 9, 15}, 4)', {0: 12, 1: 1, 2: 2, 3: 7})\r\n        _equal('predstavniki({0, 2, 4}, 5)', {0: 0, 2: 2, 4: 4})\r\n        _equal('predstavniki({-10, 11, 7, 3, 10, 17}, 6)', {1: 7, 2: -10, 3: 3, 4: 10, 5: 11})\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 56, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "#Sestavi funkcijo, ki za parametre dobi poljubno \u0161tevilo funkcij (vse so funkcije z enim parametrom).\r\n#Funkcija naj vrne kompozitum teh funkcij (torej novo funkcijo).\r\n# Primer:\r\n#    >>> f = kompozitumN(sin, sqrt, len)\r\n#    >>> f('besedilo')\r\n#    0.308071742363\r\n#    >>> g = kompozitumN(sqrt, sinus, sqrt, len)\r\n#    >>> g('besedilo')\r\n#    0.222138061474\r\n#    >>> stStevk = kompozitumN(len, str, abs)\r\n#    >>> stStevk(623)\r\n#    3\r\n#    >>> stStevk(-60173)\r\n#    5", 
      "solution": "def kompozitumN(*s):\r\n    f = lambda x: x\r\n    for g in s[::-1]: f = kompozitum2(g, f)\r\n    return f", 
      "trial": "def trial(source):\r\n   from math import sin,sqrt\r\n   _equal('round(kompozitumN(sin, sqrt, len)(\"besedilo\"),7)',0.3080717)\r\n   _equal('kompozitumN(len, str, abs)(623)',3)\r\n   _equal('kompozitumN(len, str, abs)(-60173)',5)\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 281, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavite funkcijo `greNotri(skatla1, skatla2)`, ki vrne `True`, \u010de\r\n# \u0161katlo `skatla1` lahko obrnemo tako, da gre v \u0161katlo `skatla2`, torej\r\n# da so dimenzije prve \u0161katle strogo manj\u0161e od dimenzij druge \u0161katle.", 
      "solution": "def greNotri(skatla1, skatla2):\r\n    skatla1 = list(skatla1)\r\n    skatla2 = list(skatla2)\r\n    skatla1.sort()\r\n    skatla2.sort()\r\n    \r\n    return skatla1[0] < skatla2[0] and \\\r\n           skatla1[1] < skatla2[1] and \\\r\n           skatla1[2] < skatla2[2]", 
      "trial": "def trial(source):\r\n    if check_function('greNotri', 2):\r\n        _equal('greNotri((30, 40, 50), (40, 50, 60))', True)\r\n        _equal('greNotri((30, 40, 50), (40, 50, 30))', False)\r\n        _equal('greNotri((30, 40, 50), (50, 50, 25))', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 81, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "#Sestavine, ki jih potrebujemo za kuhanje jedi, opi\u0161emo s slovarjem, \r\n# v katerem so klju\u010di sestavine, vrednosti pa koli\u010dine, ki jih \r\n# potrebujemo. Na podoben na\u010din opi\u0161emo tudi stanje v shrambi. \r\n# Sestavi funkcijo `imamoSestavine`, ki preveri, ali imamo v shrambi \r\n# dovolj sestavin za kuhanje jedi. Funkcija dobi za parametra dva \r\n# slovarja. Prvi opisuje sestavine, ki jih potrebujemo, drugi pa \r\n# stanje v shrambi. Pozor: v shrambi lahko kak\u0161na sestavina tudi manjka! \r\n# Primer: \r\n#    >>> `imamoSestavine`({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000, 'grah': 7})\r\n#    True\r\n#    >>> `imamoSestavine`({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})\r\n#    False\r\n#    >>> `imamoSestavine`({'jajca': 3, 'moka': 500}, {'moka': 100, 'jajca': 2})\r\n#    False\r\n#    >>> `imamoSestavine`({'jajca': 3, 'moka': 500}, {'moka': 600})\r\n#    False", 
      "solution": "def imamoSestavine(recept, shramba):\r\n  for sestavina, kolicina in recept.items():\r\n    if sestavina not in shramba or shramba[sestavina] < kolicina: return False\r\n  return True", 
      "trial": "def trial(source):\r\n    if check_function('imamoSestavine', 2):\r\n      _equal(\"imamoSestavine({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000, 'grah': 7})\",True)\r\n      _equal(\"imamoSestavine({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})\",False)\r\n      _equal(\"imamoSestavine({'jajca': 3, 'moka': 500}, {'moka': 100, 'jajca': 2})\",False)\r\n      _equal(\"imamoSestavine({'jajca': 3, 'moka': 500}, {'moka': 600})\",False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 251, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo 'preberiSpremenljivke', ki kot parameter dobi naravno \r\n# \u0161tevilo n, nato pa uporabnika n-krat vpra\u0161a po imenu spremenljivke \r\n# in vrednosti. Funkcija naj vrne slovar, v katerem so klju\u010di imena \r\n# spremenljivk, ki jih je vnesel uporabnik, njihove vrednosti pa \r\n# vrednosti ustreznih spremenljivk.", 
      "solution": "def preberiSpremenljivke(n):\r\n    d = dict()\r\n    for i in range(n):\r\n        ime = input()\r\n        vrednost = input()\r\n        d[ime]  = vrednost\r\n    return d", 
      "trial": "def trial(source):\r\n    _makefile1('2c.in')\r\n    old_stdin = sys.stdin\r\n    sys.stdin = open('2c.in')\r\n    \r\n    if check_function('preberiSpremenljivke', 1):\r\n        d = preberiSpremenljivke(3)\r\n        _equal(\"len({0}.keys())\".format(str(d)), 3)\r\n        _equal(str(d['a']), 0)\r\n        _equal(str(d['b']), 1)\r\n        _equal(str(d['c']), 2)\r\n    sys.stdin = old_stdin\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 89, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "#Sestavi funkcijo `meri(f,N,*argumenti)`, ki s pomo\u010djo metode clock\r\n#v modulu time izmeri \u010das, ki ga funkcija `f` porabi, \u010de jo `N`-krat\r\n#izvedemo na argumentih `argumenti`. Funkcija naj vrne povpre\u010den \u010das\r\n#enega izvajanja (tj. izmerjeni \u010das delite z N).\r\n#Primer:\r\n#    >>> meri(sin,1000000,2)\r\n#    3.7999999999999996e-07\r\n#    >>> meri(max,1000000,2,3,4,5,-1,7,8,9)\r\n#    8.399999999999999e-07", 
      "solution": "def meri(f,N,*args):\r\n    start=clock()\r\n    for i in range(N):\r\n        f(*args)\r\n    total=clock()-start\r\n    return total/N", 
      "trial": "def trial(source):\r\n    if check_function('meri', 2):\r\n        pass\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 123, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo naloga2c, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga2c(slovar):\r\n    m=set()\r\n    for k in slovar.keys():\r\n        for p in slovar[k]:\r\n            if not k in slovar.get(p,[]):\r\n                m.add(k)\r\n    return m", 
      "trial": "def trial(source):\r\n    if check_function('naloga2c', 1):\r\n        _equal('naloga2c(_prijatelji)', {'Joze', 'Miha', 'Jernej'})\r\n        _equal('naloga2c(_prijatelji2)', set())\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 97, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "#\r\n# S pomo\u010djo datoteke 'besedilo.txt' na spletni u\u010dilnici sestavi\r\n# slovar digramov v slovenskih besedilih. Pri tem upo\u0161tevaj 25\r\n# \u010drk slovenske abecede in presledke, ostale znake pa ignoriraj.\r\n#\r\n# Metodi naj bo ime digrami, vrne pa naj slovar zgrajenih digramov.\r\n# Kot argument naj sprejme ime datoteke, iz katere prebere besede.\r\n#\r\n# Pozor: testni program za to nalogo ne obstaja, zato mora\u0161\r\n# njeno delovanje preveriti sam.\r\n#\r\n# Ve\u010d o digramih si preberite na Wikipedii na naslovu\r\n# http://en.wikipedia.org/wiki/Bigram .\r\n#", 
      "solution": "def digrami(datoteka):\r\n    slovar = dict()\r\n    st=0\r\n    f=open(datoteka,\"r\",encoding=\"utf-8\")\r\n    # Poiscemo prvo crko\r\n    c1=f.read(1).upper()\r\n    while not c1.isalpha():\r\n        c1=f.read(1).upper()\r\n        \r\n    for vrstica in f:\r\n        for c2 in vrstica:\r\n            # Vse bele znake (nova vrstica, tab, presledek)\r\n            # spremenimo v presledke, \u010drke naredimo velike\r\n            c2=' ' if c2.isspace() else c2.upper()\r\n            # \u010de je \u010drka ali presledek, dodamo digram v slovar\r\n            if c2.isalpha() or c2.isspace():\r\n                if c1 == ' ' and c2 == ' ': continue # No\u010demo dvojnih presledkov\r\n                digram=c1+c2\r\n                slovar[digram] = slovar.get(digram,0)+1\r\n                st+=1\r\n                c1=c2\r\n    #Izra\u010dunamo \u0161e frekvence\r\n    for k,v in slovar.items():\r\n        slovar[k]=v/st    \r\n    return slovar", 
      "trial": "def trial(source):\r\n    if check_function(\"digrami\", 1):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 105, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavite funkcijo `slike(permutacija, x, n)`, vrne pa seznam slik\r\n# \u0161tevila `x`, \u010de uporabimo permutacijo `n`-krat.\r\n# Predpostavite lahko, da je dano \u0161tevilo v domeni permutacije.", 
      "solution": "def slike(permutacija, x, n):\r\n    if n == 0:\r\n        return []\r\n    else:\r\n        y = permutacija[x]\r\n        ostale = slike(permutacija, y, n - 1)\r\n        return [y] + ostale", 
      "trial": "def trial(source):\r\n    if check_function('slike', 3):\r\n        _equal('slike({1: 3, 2: 4, 3: 2, 4: 1}, 1, 3)', [3, 2, 4])\r\n        _equal('slike({1: 3, 2: 4, 3: 2, 4: 1}, 2, 6)', [4, 1, 3, 2, 4, 1])\r\n        _equal('slike({1: 3, 2: 4, 3: 2, 4: 1}, 3, 1)', [2])\r\n        _equal('slike({1: 3, 2: 4, 3: 2, 4: 1}, 4, 0)', [])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 155, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo `stolpec(slovar, y)`, ki kot parametra dobi slovar\r\n# zasedenosti in stolpec y, vrne pa nov slovar, ki vsebuje tiste ljudi,\r\n# ki sedijo v tem stolpcu. Klju\u010di slovarja naj bodo vrste, v katerih\r\n# sedijo ljudje, vrednosti pa njihove vi\u0161ine.", 
      "solution": "def stolpec(s,y):\r\n    return dict((x, v) for (x, y0), v in s.items() if y0 == y)", 
      "trial": "def trial(source):\r\n    if check_function('stolpec', 2):\r\n        _equal('stolpec({(1, 2): 17.5, (2, 2): 16.5, (3, 4): 16.5}, 2)', { 1: 17.5, 2:16.5})\r\n        _equal('stolpec({(1, 2): 17.5, (2, 2): 16.5, (3, 4): 16.5}, 3)', { })\r\n        _equal('stolpec({(1, 2): 16.5, (2, 2): 17.5, (3, 2): 16.5}, 2)', { 1: 16.5, 2:17.5, 3:16.5})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 203, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavi funkcijo 'prehodno', ki kot parametre dobi slovar prehodov in dve stanji A\n# in B, vrne pa True, \u010de se da iz stanja A priti v stanje B, sicer pa vrne\n# False.\n# Primer:\n#    >>> prehodno({'a': 'b', 'b': 'a', 'c': 'c'}, 'a', 'c')\n#    False\n#    >>> prehodno({'a': 'b', 'b': 'a', 'c': 'c'}, 'a', 'b')\n#    True", 
      "solution": "def prehodno(prehodi, a, b):\n    return b in kateraStanja(prehodi, a, len(prehodi))", 
      "trial": "def trial(source):\n    if check_function('prehodno', 3):\n        _equal(\"prehodno({'a': 'b', 'b': 'a', 'c': 'c'}, 'a', 'c')\", False)\n        _equal(\"prehodno({0: 9, 1: 6, 2: 2, 3: 3, 4: 0, 5: 8, 6: 5, 7: 1, 8: 7, 9: 4}, 0, 4)\", True)\n        _equal(\"prehodno({0: 9, 1: 6, 2: 2, 3: 3, 4: 0, 5: 8, 6: 5, 7: 1, 8: 7, 9: 4}, 0, 5)\", False)\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 41, 
    "model": "problem.part", 
    "fields": {
      "_order": 6, 
      "description": "# Sestavite funkcijo `poudari_besede(naslov)`, ki vrne naslov, v katerem\r\n# so vse besede, ozna\u010dene z znakoma `*`, zapisane z velikimi \u010drkami.\r\n#\r\n# _Na primer_: klic `poudari_besede(\"Zadnja *novica* danes!\")` naj vrne\r\n# niz `\"Zadnja NOVICA danes!\"`.\r\n", 
      "solution": "def poudari_besede(naslov):\r\n    poudarjen = ''\r\n    poudarjaj = False\r\n    for z in naslov:\r\n        if z == \"*\":\r\n            poudarjaj = not poudarjaj\r\n        elif poudarjaj:\r\n            poudarjen += z.upper()\r\n        else:\r\n            poudarjen += z\r\n    return poudarjen\r\n", 
      "trial": "def trial(source):\r\n    if check_function(\"poudari_besede\", 1):\r\n        _equal(\"poudari_besede('Zadnja *novica* danes!!!')\", 'Zadnja NOVICA danes!!!')\r\n        _equal(\"poudari_besede('Zadnja novica *danes!!!')\", 'Zadnja novica DANES!!!')\r\n        _equal(\"poudari_besede('Z*v*e*z*d*i*c*e* *v*s*e*p*o*v*s*o*d*')\", 'ZVeZdIcE VsEpOvSoD')\r\n        yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 7
    }
  }, 
  {
    "pk": 204, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo 'nepovezljiva', ki vrne vse pare nepovezljivih stanj. To so taki pari\n# (A,B), da se iz stanja A ne da priti v stanje B. Funkcija naj kot argument\n# sprejme slovar prehodov in vrne seznam tak\u0161nih naborov. \n# Primer:\n#    >>> nepovezljiva({'a': 'b', 'b': 'a', 'c': 'c'})\n#    [('a', 'c'), ('c', 'a'), ('c', 'b'), ('b', 'c')]", 
      "solution": "def nepovezljiva(prehodi):\n    neprehodno = []\n    for a in prehodi.keys():\n        for b in prehodi.keys():\n            if not prehodno(prehodi, a, b):\n                neprehodno.append((a,b))\n    return neprehodno", 
      "trial": "def trial(source):\n    if check_function('nepovezljiva', 1):\n        a = nepovezljiva({'a': 'b', 'b': 'a', 'c': 'c'})\n        b = [('a', 'c'), ('c', 'a'), ('c', 'b'), ('b', 'c')]\n        a.sort()\n        b.sort()\n        _equal(str(a), b)\n        a = nepovezljiva({0: 9, 1: 6, 2: 2, 3: 3, 4: 0, 5: 8, 6: 5, 7: 1, 8: 7, 9: 4})\n        b = [(0, 1), (0, 2), (0, 3), (0, 5), (0, 6), (0, 7), (0, 8), (1, 0), (1, 2), (1, 3), (1, 4), (1, 9), (2, 0), (2, 1), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (3, 0), (3, 1), (3, 2), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (3, 9), (4, 1), (4, 2), (4, 3), (4, 5), (4, 6), (4, 7), (4, 8), (5, 0), (5, 2), (5, 3), (5, 4), (5, 9), (6, 0), (6, 2), (6, 3), (6, 4), (6, 9), (7, 0), (7, 2), (7, 3), (7, 4), (7, 9), (8, 0), (8, 2), (8, 3), (8, 4), (8, 9), (9, 1), (9, 2), (9, 3), (9, 5), (9, 6), (9, 7), (9, 8)]\n        a.sort()\n        b.sort()        \n        _equal(str(a), b)\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 172, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo `operacije(mnozica, k, a, b)`, ki izvede operacijo s\r\n# predstavniki. Kot parametre dobi mno\u017eico celih \u0161tevil, naravno \u0161tevilo k\r\n# in dva predstavnika, vrne pa nabor dol\u017eine 3, katerega elementi so po\r\n# vrsti predstavnik za vsoto, razliko in produkt predstavnikov a in b\r\n# po modulu k. \u010ce a ali b ni veljaven predstavnik, naj funkcija vrne\r\n# nabor s tremi elementi None.\r\n", 
      "solution": "def operacije(m, k, a, b):\r\n    d=predstavniki(m, k)\r\n    if not (a in d.values() and b in d.values()):\r\n        return (None, None, None)\r\n    return (predstavnik(m, k, (a+b)%k), predstavnik(m, k, (a-b)%k), predstavnik(m, k, (a*b)%k))\r\n", 
      "trial": "def trial(source):\r\n    if check_function('operacije', 4):\r\n        _equal('operacije({1, 2, 12, 7, 5, 9, 15}, 4, 1, 7)', (12, 2, 7))\r\n        _equal('operacije({0, 2, 4}, 5, 2, 3)', (None, None, None))\r\n        _equal('operacije({-11, 11, 7, 3, 10, 19}, 7, 11, -11)', (7, None, 19))\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 57, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "#Sestavi rekurzivno funkcijo, ki izpi\u0161e zaporedje potez, ki re\u0161ijo problem Hanoiskih stolpi\u010dev z n diski.\r\n#Problem je naslednji: imamo tri palice z oznakami A, B in C, na katere lahko natikamo diske\r\n#razli\u010dnih velikosti. Omejitev je samo ta, da morajo biti diski na isti palici urejeni od najve\u010djega\r\n#spodaj do najve\u010djega zgoraj. Na za\u010detku imamo na palici A n razli\u010dno velikih diskov.\r\n#Vse je treba prestaviti na palico C, pri \u010demer lahko premikamo samo po en disk naenkrat,\r\n#pri tem moramo pa ves \u010das paziti na urejenost diskov na posamezni palici.\r\n#Primer:\r\n#    >>> hanoi(3, 'A', 'B', 'C')\r\n#    A -> C\r\n#    A -> B\r\n#    C -> B\r\n#    A -> C\r\n#    B -> A\r\n#    B -> C\r\n#    A -> C", 
      "solution": "def hanoi(n, a, b, c):\r\n    if n == 0: return\r\n    hanoi(n - 1, a, c, b)\r\n    print(a, '->', c)\r\n    hanoi(n - 1, b, a, c)", 
      "trial": "def trial(source):\r\n   global _warn\r\n   rezultat=izpis(hanoi,3,'A','B','C').strip()\r\n   if rezultat != 'A -> C\\nA -> B\\nC -> B\\nA -> C\\nB -> A\\nB -> C\\nA -> C'.strip():\r\n      _warn('Napa\u010dno zaporedje potez')\r\n   yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 4
    }
  }, 
  {
    "pk": 90, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "#Sestavi dve funkciji: `vsotaPrvihN(n)` in `vsotaPrvihN2(n)`, ki\r\n#izra\u010dunata vsoto prvih `n` naravnih \u0161tevil. Prva naj to stori z zanko\r\n#while, druga pa z uporabo formule `n*(n+1)/2`. Nato sestavi funkcijo\r\n#`zahtevnost(S)`, ki s pomo\u010djo funkcije `meri` tabelira \u010dasovno\r\n#zahtevnost obeh funkcij. Tabeliraj \u010dase izvajanja obeh\r\n#funkcij za razli\u010dne vrednosti `n`, ki so podane v seznamu S.\r\n#Primer:\r\n#    >>> zahtevnost([100, 1000, 10000, 100000, 1000000])\r\n#       N   | vsotaPrvihN | vsotaPrvihN2\r\n#    -------+-------------+--------------\r\n#        100|      2.7e-05|     7.1e-07\r\n#       1000|      0.00031|     7.6e-07\r\n#      10000|       0.0033|     7.7e-07\r\n#     100000|        0.032|     8.9e-07\r\n#    1000000|         0.31|       9e-07", 
      "solution": "def vsotaPrvihN(n):\r\n    v=0\r\n    while n>0:\r\n        v+=n\r\n        n-=1\r\n    return v\r\n\r\ndef vsotaPrvihN2(n):\r\n    return n*(n+1)//2\r\n\r\ndef zahtevnost(S):\r\n    #priblizno milijon izvajanj\r\n    print('    N     | vsotaPrvihN | vsotaPrvihN2')\r\n    print('-'*7+'+'+'-'*13+'+'+'-'*14)\r\n    for n in S:\r\n        N=1000000\r\n        print('{0:10}| '.format(n),end='')\r\n        print('{0:11} |{1:12}'.format(meri(vsotaPrvihN,N//n,n),meri(vsotaPrvihN2,N,n)))\r\n", 
      "trial": "def trial(source):\r\n    if check_function('zahtevnost', 1) and check_function('vsotaPrvihN',1) and check_function('vsotaPrvihN2',1):\r\n        _equal('vsotaPrvihN(3)',6)\r\n        _equal('vsotaPrvihN2(3)',6)\r\n        _equal('vsotaPrvihN(20)',210)\r\n        _equal('vsotaPrvihN2(20)',210)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 12
    }
  }, 
  {
    "pk": 98, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "#\r\n# Kot pri predprej\u0161nji nalogi generiraj naklju\u010dno besedilo, pri \u010demer tokrat \r\n# uporabi frekvence digramov.\r\n#\r\n# Pozor: \u010de za prvi digram naklju\u010dno izberemo \"AN\", potem se mora\r\n# naslednji digram za\u010deti z \"N\", besedi pa nato dodamo samo drugo\r\n# \u010drko izbranega digrama (npr. za NA bi tako dobili besedo ANA).\r\n#\r\n# Ime metode naj bo nakljucnoBesedilo2. Besedilo naj vrne v obliki\r\n# niza dol\u017eine n, kjer n sprejme kot argument metode.\r\n#", 
      "solution": "def nakljucnoBesedilo2(dolzina):\r\n    slovar = digrami(\"besedilo.txt\")\r\n    # Sestavimo slovar slovarjev za dane za\u010detke digramov\r\n    superslovar=dict()\r\n    for k in slovar:\r\n        d=superslovar.get(k[0])\r\n        if d==None:\r\n            superslovar[k[0]]=dict()\r\n        superslovar[k[0]][k]=slovar[k]\r\n    # \u0160e normalizacija\r\n    for sl in superslovar.values():\r\n        vsota=sum(sl.values())\r\n        if vsota==0: vsota=1\r\n        for k,v in sl.items():\r\n            sl[k]=v/vsota\r\n    digram=rndd(slovar) # Izberemo naklju\u010den za\u010detni digram\r\n    rezultat=[digram]\r\n    st=2 # \u0160t. znakov do zdaj\r\n    while st < dolzina:\r\n        novi=rndd(superslovar[digram[1]])\r\n        rezultat.append(novi[1])\r\n        digram=novi\r\n        st+=1\r\n    return ''.join(rezultat)", 
      "trial": "def trial(source):\r\n    if check_function(\"nakljucnoBesedilo2\", 1):\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 13
    }
  }, 
  {
    "pk": 141, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo `odsifriraj(slovar, beseda)`, ki sprejme slovar s\r\n# \u0161ifro in za\u0161ifrirano besedilo, vrne pa od\u0161ifrirano besedilo. \u010ce slovar\r\n# ni bijekcija (in se torej besedilo ne da nujno od\u0161ifrirati, naj\r\n# funkcija vrne None.\r\n", 
      "solution": "def odsifriraj(slovar, beseda):\r\n    inv=inverz(slovar)\r\n    if inv == None:\r\n        return None\r\n    return ''.join([inv[c] for c in beseda])", 
      "trial": "def trial(source):\r\n    if check_function('odsifriraj', 2):\r\n        _equal('odsifriraj(_slovar, \"IRHRINBA\")', \"KOLOKVIJ\")\r\n        _equal('odsifriraj(_slovar, \"JVTVU\")', \"PESEM\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 106, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavite funkcijo `cikel(permutacija, x)`, ki vrne celoten cikel, ki\r\n# se za\u010dne s \u0161tevilom `x`.\r\n# Tako je `cikel({1: 3, 2: 2, 3: 1}, 1)` enak `[1, 3]`,\r\n# `cikel({1: 3, 2: 2, 3: 1}, 2)` pa `[2]`.", 
      "solution": "def cikel(permutacija, x):\r\n    cikel = [x]\r\n    y = permutacija[x]\r\n    while y != x:\r\n        cikel.append(y)\r\n        y = permutacija[y]\r\n    return cikel", 
      "trial": "def trial(source):\r\n    if check_function('cikel', 2):\r\n        _equal('cikel({1: 3, 2: 4, 3: 2, 4: 1}, 1)', [1, 3, 2, 4])\r\n        _equal('cikel({1: 3, 2: 2, 3: 1}, 1)', [1, 3])\r\n        _equal('cikel({1: 3, 2: 2, 3: 1}, 2)', [2])\r\n        _equal('cikel({1: 3, 2: 2, 3: 1}, 3)', [3, 1])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 156, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo `vidim(slovar, polozaj, visina)`, ki kot parametre dobi\r\n# slovar zasedenosti, polo\u017eaj tvojega sede\u017ea (kot nabor dol\u017eine 2) in tvojo\r\n# vi\u0161ino, vrne pa True, \u010de vidi\u0161 na platno in False sicer. Na platno vidi\u0161,\r\n# \u010de pred tabo v stolpcu sedijo samo ljudje, ki so strogo ni\u017eji od tebe.", 
      "solution": "def vidim(s,kje,v):\r\n    (x, y) = kje\r\n    s = stolpec(s, y)\r\n    return all(v0 < v for (x0, v0) in s.items() if x0 < x)", 
      "trial": "def trial(source):\r\n    if check_function('vidim', 3):\r\n        _equal('vidim({(1, 2): 16.5, (3, 2): 17.5, (3, 4): 16.5}, (3, 2), 18.5)', True)\r\n        _equal('vidim({(1, 2): 16.5, (3, 2): 17.5, (3, 4): 16.5}, (4, 2), 17.5)', False)\r\n        _equal('vidim({(1, 2): 16.5, (3, 2): 17.5, (3, 4): 16.5}, (2, 2), 17.5)', True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 252, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo 'izracunaj', ki kot parameter dobi slovar s spremenljivkami in\r\n# njihovimi vrednostmi in seznam imen nekaterih spremenljivk, vrne pa nabor\r\n# (vsota, produkt) vsote in produkta vrednosti spremenljivk, ki so navedene\r\n# v seznamu. \u010ce je v seznamu ime spremenljivke, ki je ni v slovarju,\r\n# privzemi, da je vrednost spremenljivke 0 za se\u0161tevanje in 1 za\r\n# mno\u017eenje. Predpostavi\u0161 lahko, da bo dol\u017eina seznama imen vsaj ena.\r\n# Primer:\r\n#    >>> izracunaj({'a': 1, 'b': 2}, ['a', 'c'])\r\n#    (1, 1)", 
      "solution": "def izracunaj(slovar, imena):\r\n    (vsota, produkt) = (0, 1)\r\n    for spremenljivka in imena:\r\n        if spremenljivka in slovar:\r\n            (vsota, produkt) = (vsota + slovar[spremenljivka], produkt * slovar[spremenljivka])\r\n    return (vsota, produkt)", 
      "trial": "def trial(source):\r\n    if check_function('izracunaj', 2):\r\n        _equal(\"izracunaj({'a': 1, 'b': 2}, ['a', 'c'])\", (1,1))\r\n        _equal(\"izracunaj({'a': 0, 'b': 2, 'c': 3, 'd': -1}, ['a','b','c'])\", (5,0))\r\n        _equal(\"izracunaj({'a': 0, 'b': 2, 'c': 3, 'd': -1}, ['e','b','c'])\", (5,6))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 19, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi program, ki bo izra\u010dunal manj\u0161ega izmed kotov med urnim in minutnim kazalcem ob danem \r\n# \u010dasu. \u010cas je podan z uro in minutami. Upo\u0161tevaj, da se vsako minuto tudi urni kazalec malo prestavi.\r\n# Trenutno uro in minuto ima\u0161 podano v spremenljivkah z imenoma ura in minuta. Kot naj bo\r\n# izpisan v obliki \r\n#    Kot med urnim in minutnim kazalcem je x stopinj in y minut.\r\n# , kjer sta x in y celi \u0161tevili (minut ne zaokro\u017euj, ampak samo odre\u017ei decimalni del).\r\n# Primer: za vrednosti\r\nura = 17\r\nminuta = 47\r\n# naj program izpi\u0161e\r\n#    Kot med urnim in minutnim kazalcem je 108 stopinj in 30 minut.", 
      "solution": "ura = ura % 12\r\nalfa = 60*(6*minuta)\r\nbeta = 60*(30*ura + 0.5*minuta)\r\nbeta = int(beta)\r\nminute = abs(alfa - beta)\r\nminute = min(minute, 360*60 - minute)\r\nstopinje = minute // 60\r\nminute = minute % 60\r\nprint(\"Kot med urnim in minutnim kazalcem je\", stopinje, \"stopinj in\", minute, \"minut.\")\r\n", 
      "trial": "import random \r\nimport math\r\n\r\ndef trial(source):\r\n    # vr\u017eemo ven del, kjer so definirane spremenljivke v kodi\r\n    # in jih nadomestimo s svojimi\r\n    headerend = source.rfind(\"@#\\n\") + 3\r\n    source = source[headerend:]\r\n    d = dict()\r\n    ura = random.randint(1, 23)\r\n    minuta = random.randint(0, 59)   \r\n    d[\"ura\"] = ura\r\n    d[\"minuta\"] = minuta\r\n    (d, izpis) = izvedi(source, d)\r\n    ura = ura % 12\r\n    alfa = 60*(6*minuta)\r\n    beta = 60*(30*ura + 0.5*minuta)\r\n    beta = int(beta)\r\n    minute = abs(alfa - beta)\r\n    minute = min(minute, 360*60 - minute)\r\n    stopinje = minute // 60\r\n    minute = minute % 60\r\n    pizpis = \"Kot med urnim in minutnim kazalcem je {0} stopinj in {1} minut.\".format(stopinje, minute)\r\n    if izpis.strip() != pizpis:\r\n        _warn(\"Za ura = {0} in minuta = {1} izpis ni prave oblike: \\n\".format(ura, minuta) + izpis.strip())\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 3
    }
  }, 
  {
    "pk": 282, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavite funkcijo `babuska(skatle)`, ki vrne najve\u010dje \u0161tevilo \u0161katel,\r\n# ki jih lahko zlo\u017eimo eno v drugo, \u010de za\u010dnemo s prvo \u0161katlo s seznama,\r\n# vanjo vstavimo drugo, v drugo tretjo in tako naprej.", 
      "solution": "def babuska(skatle):\r\n    stevilo = 1\r\n    zadnja = skatle[0]\r\n    \r\n    for skatla in skatle[1:]:\r\n        if greNotri(skatla, zadnja):\r\n            zadnja = skatla\r\n            stevilo += 1\r\n        else:\r\n            return stevilo\r\n    return stevilo", 
      "trial": "def trial(source):\r\n    if check_function('babuska', 1):\r\n        _equal('babuska([(50, 100, 100), (60, 30, 50), (40, 40, 40)])', 2)\r\n        _equal('babuska([(60, 100, 100), (60, 50, 50), (40, 40, 40)])', 3)\r\n        _equal('babuska([(60, 30, 50), (40, 40, 40)])', 1)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 34, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavite funkcijo `naslednjePrastevilo(n)`, ki vrne prvo pra\u0161tevilo,\r\n# strogo ve\u010dje od \u0161tevila `n`.", 
      "solution": "def naslednjePrastevilo(n):\r\n    kandidat = n + 1\r\n    while not jePrastevilo(kandidat):\r\n        kandidat += 1\r\n    return kandidat", 
      "trial": "def trial(source):\r\n    if check_function(\"naslednjePrastevilo\", 1):\r\n        _equal('naslednjePrastevilo(1)', 2)\r\n        _equal('naslednjePrastevilo(2)', 3)\r\n        _equal('naslednjePrastevilo(3)', 5)\r\n        _equal('naslednjePrastevilo(23)', 29)\r\n        _equal('naslednjePrastevilo(42)', 43)\r\n        _equal('naslednjePrastevilo(97)', 101)\r\n        yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 6
    }
  }, 
  {
    "pk": 124, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "# Sestavi funkcijo naloga2d, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga2d(slovar, ime, n):\r\n    m2=set(slovar.get(ime,[]))\r\n    m=set()\r\n    for i in range(n):\r\n        m=m2\r\n        m2=m.copy()\r\n        for pr in m:\r\n            m2=m2 | set(slovar.get(pr,[]))\r\n    p=m2 - m - {ime}\r\n    return p", 
      "trial": "def trial(source):\r\n    if check_function('naloga2d', 3):\r\n        _equal('naloga2d(_prijatelji,\"Joze\",0)', {'Miha'})\r\n        _equal('naloga2d(_prijatelji,\"Joze\",1)', {'Franc', 'Jernej'})\r\n        _equal('naloga2d(_prijatelji,\"Joze\",2)', {'Janez'})\r\n        _equal('naloga2d(_prijatelji2, \"Miha\", 1)', {'Franc', 'Joze'})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 82, 
    "model": "problem.part", 
    "fields": {
      "_order": 7, 
      "description": "#Sestavi \u0161e funkcijo `potrebnoKupiti`, ki vrne slovar sestavin in \r\n# koli\u010din, ki jih moramo \u0161e dokupiti, da bomo lahko skuhali jed\r\n# (glej prej\u0161njo nalogo).\r\n#    >>> potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000})\r\n#    {}\r\n#    >>> potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})\r\n#    {'jajca': 3}\r\n#    >>> potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 100})\r\n#    {'jajca': 2, 'moka': 400}", 
      "solution": "def potrebnoKupiti(recept, shramba):\r\n  kupiti = dict()\r\n  for sestavina, kolicina in recept.items():\r\n    if sestavina not in shramba:\r\n      kupiti[sestavina] = kolicina\r\n    elif shramba[sestavina] < kolicina: \r\n      kupiti[sestavina] = kolicina - shramba[sestavina]\r\n  return kupiti", 
      "trial": "def trial(source):\r\n    if check_function('potrebnoKupiti', 2): \r\n      _equal(\"potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'jajca': 6, 'sladkor': 1000})\", {})\r\n      _equal(\"potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 1000, 'sladkor': 1000})\",{'jajca': 3} )\r\n      _equal(\"potrebnoKupiti({'jajca': 3, 'moka': 500}, {'moka': 100})\", {'jajca': 3, 'moka': 400})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 11
    }
  }, 
  {
    "pk": 107, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Sestavite funkcijo `cikli(permutacija, x)`, ki vrne seznam disjunktnih\r\n# ciklov dane permutacije. Vsak cikel naj se za\u010dne z najmanj\u0161im \u0161tevilom\r\n# v ciklu, cikli pa naj bodo urejeni po za\u010detnem \u0161tevilu.\r\n#\r\n# Tako naj bo `cikli({1: 3, 2: 2, 3: 1})` enako `[[1, 3], [2]]`.", 
      "solution": "def cikli(permutacija):\r\n    cikli = []\r\n    stevila = []\r\n    for i in range(1, len(permutacija) + 1):\r\n        if i not in stevila:\r\n            c = cikel(permutacija, i)\r\n            cikli.append(c)\r\n            stevila += c\r\n    return cikli", 
      "trial": "def trial(source):\r\n    if check_function('cikli', 1):\r\n        _equal('cikli({1: 3, 2: 4, 3: 2, 4: 1})', [[1, 3, 2, 4]])\r\n        _equal('cikli({1: 3, 2: 2, 3: 1})', [[1, 3], [2]])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 253, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Tina za vsako hrano, ki jo poje, zapi\u0161e njeno kalori\u010dno vrednost (celo \u0161tevilo).\r\n# Vse te podatke hrani v datoteki: podatke vsakega dne zapi\u0161e v svojo vrstico,\r\n# znotraj vrstice pa jih lo\u010di z vejico.\r\n# Sestavite funkcijo 'vrniKalorije', ki dobi seznam kalorij podan kot niz\r\n# lo\u010den z vejicami in jih vrne kot seznam celih \u0161tevil.\r\n# Primer:\r\n#    >>> vrniKalorije(\"10,4\")\r\n#    [10,4]", 
      "solution": "def vrniKalorije(niz):\r\n    return list(map(int, niz.split(',')))", 
      "trial": "def trial(source):\r\n    if check_function('vrniKalorije', 1):\r\n        _equal('vrniKalorije(\"11,23,1\")', [11, 23, 1])\r\n        _equal('vrniKalorije(\"15,50,72,68,2\")',[15, 50, 72, 68, 2])\r\n        _equal('vrniKalorije(\"10\")', [10])\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 261, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Usmerjeni graf lahko predstavimo s slovarjem, v katerem so klju\u010di\r\n# vozli\u0161\u010da, pripadajo\u010de vrednosti pa so mno\u017eice vozli\u0161\u010d, v katera\r\n# vodijo povezave iz izbranega vozli\u0161\u010da.\r\n#\r\n# Na primer, graf z vozli\u0161\u010di 1, 2, 3 in s povezavami 1->3, 2->1, 2->3\r\n# bi predstavili s slovarjem `{1: {3}, 2: {1, 3}, 3: set()}`.\r\n#\r\n# Vozli\u0161\u010di sta sosednji, \u010de med njima obstaja povezava vsaj v eno smer.\r\n# Sestavite funkcijo `sosednji(g, v1, v2)`, ki vrne `True`, kadar sta\r\n# vozli\u0161\u010di `v1` in `v2` v grafu `g` sosednji, in `False` sicer.", 
      "solution": "def sosednji(g, v1, v2):\r\n    return v1 in g[v2] or v2 in g[v1]", 
      "trial": "def trial(source):\r\n    if check_function('sosednji', 3):\r\n        _equal('sosednji({1: {3}, 2: {1, 3}, 3: set()}, 1, 3)', True)\r\n        _equal('sosednji({1: {3}, 2: {1, 3}, 3: set()}, 3, 1)', True)\r\n        _equal('sosednji({1: {3}, 2: {1}, 3: set()}, 2, 3)', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 125, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Sestavi funkcijo naloga3a, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga3a(vhod,izhod):\r\n    f1=open(vhod)\r\n    f2=open(izhod,\"w\")\r\n    for vrstica in f1:\r\n        if vrstica[0] == '%':\r\n            continue\r\n        f2.write(vrstica)\r\n    f1.close()\r\n    f2.close()", 
      "trial": "def trial(source):\r\n    if check_function('naloga3a', 2):\r\n        _makefile(\"_test1a.txt\")\r\n        _makefile1(\"_test3a.txt\")\r\n        naloga3a(\"_test1a.txt\",\"_test2a.txt\")\r\n        _equal('_istedatoteke(\"_test2a.txt\",\"_test3a.txt\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1a.txt\",\"_test2a.txt\",\"_test3a.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 205, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Vodovodar si je za vsak dan zapisal izdatke, ki jih je imel z nabavo materiala.\n# Vsi izdatki so pozitivna cela \u0161tevila. Shranjene ima v datoteki, \n# in sicer za vsak dan v svoji vrsti, lo\u010dene z vejicami.\n# Sestavite funkcijo 'preberiIzdatke', ki dobi seznam zneskov kot niz\n# lo\u010den z vejicami in jih vrne kot seznam celih \u0161tevil.\n# Primer: \n#    >>> preberiIzdatke(\"11,23,1\")\n#    [11, 23, 1]", 
      "solution": "def preberiIzdatke(niz):\n    return list(map(int, niz.split(',')))", 
      "trial": "def trial(source):\n    if check_function('preberiIzdatke', 1):\n        _equal('preberiIzdatke(\"11,23,1\")', [11, 23, 1])\n        _equal('preberiIzdatke(\"15,50,72,68,2\")',[15, 50, 72, 68, 2])\n        _equal('preberiIzdatke(\"10\")', [10])\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 157, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# V datoteki so zapisana imena, v ve\u010dih vrsticah, v vsaki vrstici so lo\u010dena\r\n# z vejicami. Sestavi funkcijo `kolikokratSePojavi(niz,ime)`, ki kot argument\r\n# sprejme z vejicami lo\u010den niz imen in izbrano ime ter vrne \u0161tevilo pojavitev\r\n# tega imena v nizu imen.", 
      "solution": "def kolikokratSePojavi(niz,ime):\r\n    return niz.split(',').count(ime)", 
      "trial": "def trial(source):\r\n    if check_function('kolikokratSePojavi', 2):\r\n        _equal('kolikokratSePojavi(\"Jaka,Luka,Miha,Luka\", \"Jaka\")', 1)\r\n        _equal('kolikokratSePojavi(\"Jaka,Luka,Miha,Luka\", \"Luka\")', 2)\r\n        _equal('kolikokratSePojavi(\"Jaka,Luka,Miha,Luka\", \"Tone\")', 0)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 142, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# V datoteki imamo shranjene rezultate kolokvija v obliki\r\n# Ime Priimek,1a,1b,1c,1d,2a,2b,2c,2d,3a,3b,3c,3d\r\n# vrednosti 1a - 3d predstavljajo to\u010dke za posamezno nalogo (cela \u0161tevila).\r\n# Primer:\r\n# Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1\r\n# Sestavi funkcijo `nabor(niz)`, ki kot parameter dobi niz z vejico\r\n# lo\u010denih vrednosti kot zgoraj, vrne pa nabor s temi vrednostmi. Pri tem\r\n# naj to\u010dke za posamezne naloge spremeni v \u0161tevila (tj. naj jih ne vrne kot\r\n# nize.\r\n#\r\n# Primer: `nabor(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1\")` naj vrne\r\n# `(\"Janez Novak\", 1, 3, 3, 2, 1, 0, 0, 2, 0, 3, 2, 1)`\r\n", 
      "solution": "def nabor(niz):\r\n    s=niz.split(',')\r\n    for i in range(1,len(s)):\r\n        s[i]=int(s[i])\r\n    return tuple(s)", 
      "trial": "def trial(source):\r\n    if check_function('nabor', 1):\r\n        _equal('nabor(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1\")', (\"Janez Novak\", 1, 3, 3, 2, 1, 0, 0, 2, 0, 3, 2, 1))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 173, 
    "model": "problem.part", 
    "fields": {
      "_order": 8, 
      "description": "# Sestavi funkcijo `nizi(ime)`, ki na zaslon izpi\u0161e vse nize, ki se\r\n# nahajajo v datoteki z danim imenom. Nizi so vedno oblike \"...\", kjer\r\n# so ... poljubni znaki, razli\u010dni od '\"'. Lahko predpostavi\u0161, da je\r\n# za\u010detek in konec niza v isti vrstici. Funkcija naj izpi\u0161e vsak niz v\r\n# svojo vrsto. Predpostavi tudi, da nimamo praznih nizov.\r\n", 
      "solution": "def nizi(ime):\r\n    with open(ime) as d:\r\n        for vrstica in d:\r\n            s=vrstica.split('\"')\r\n            for niz in s[1::2]:\r\n                print(niz)\r\n", 
      "trial": "def trial(source):\r\n    if check_function('nizi', 1):\r\n        _makefile(\"_test1.txt\")\r\n        _equal('izpis(nizi, \"_test1.txt\").strip()', \"nizi\\nnenizi\\ncelotna vrstica en sam niz\\nniz na zacetku\\nna koncu\", \"Napa\u010den izpis\")\r\n        _removefiles(\"_test1.txt\")\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 262, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavite funkcijo `najvecIzhodnih(g)`, ki vrne tisto vozli\u0161\u010de\r\n# usmerjenega grafa `g`, iz katerega vodi najve\u010d povezav.\r\n# \u010ce je takih vozli\u0161\u010d ve\u010d, lahko funkcija vrne poljubno izmed njih.", 
      "solution": "def najvecIzhodnih(g):\r\n    max_izhodna = max(len(p) for p in g.values())\r\n    for v, p in g.items():\r\n        if len(p) == max_izhodna:\r\n            return v", 
      "trial": "def trial(source):\r\n    if check_function('najvecIzhodnih', 1):\r\n        _equal('najvecIzhodnih({1: {3}, 2: {1, 3}, 3: set()})', 2)\r\n        _equal('najvecIzhodnih({1: {3}, 2: set(), 3: set()})', 1)\r\n        _equal('najvecIzhodnih({1: {3, 2}, 2: {1}, 3: {1}})', 1)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 143, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavi funkcijo `naloziCSV(ime)`, ki kot parameter dobi ime datoteke,\r\n# v kateri se nahajajo vrstice z vejico lo\u010denimi vrednostimi (kot v prej\u0161nji\r\n# nalogi), vrne pa seznam naborov, za vsako vrstico enega.\r\n", 
      "solution": "def naloziCSV(ime):\r\n    f=open(ime)\r\n    rezultat=[]\r\n    for vrstica in f:\r\n        rezultat.append(nabor(vrstica))\r\n    f.close()\r\n    return rezultat", 
      "trial": "def trial(source):\r\n    if check_function('naloziCSV', 1):\r\n        _makefile(\"_test.csv\")\r\n        _equal('naloziCSV(\"_test.csv\")', [('Janez Novak', 1, 3, 3, 2, 1, 0, 0, 2, 0, 3, 2, 1), ('Ena A', 0, 1, 3, 2, 6, 2, 0, 5, 6, 3, 2, 1), ('Dober Clovek', 3, 0, 1, 2, 0, 1, 5, 4, 3, 7, 8, 1)])\r\n        _removefiles(\"_test.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 206, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavite funkcijo 'dnevniIzdatki', ki kot parameter dobi ime vhodne datoteke in vrne \n# seznam zneskov, ki jih je vodovodar dnevno izdal za material: vsaka\n# vrstica v seznamu je tako vsota zneskov nakupa na dolo\u010den dan.\n# Primer: \n# vhod.txt:\n# 3,4\n# 5,6\n#    >>> dnevniIzdatki(\"vhod.txt\")\n#    [7, 11]", 
      "solution": "def dnevniIzdatki(d):\n    zneski = []\n    with open(d) as f:\n        for vrstica in f:\n            zneski.append(sum(preberiIzdatke(vrstica)))\n    return zneski", 
      "trial": "def trial(source):\n    if check_function('dnevniIzdatki', 1):\n        _makefile0(\"_3b.in\")\n        izdatki = dnevniIzdatki(\"_3b.in\")\n        _equal('dnevniIzdatki(\"_3b.in\")', [138, 33, 8, 269, 105])\n        _removefiles(\"_3b.in\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 254, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavite funkcijo 'kalorijeNaDan', ki kot parameter dobi ime vhodne datoteke in vrne \r\n# seznam kalorij, ki jih je Tina pou\u017eila za vsak dan: za vsako vrstico naj torej se\u0161teje\r\n# vse kalorije.", 
      "solution": "def kalorijeNaDan(d):\r\n    zneski = []\r\n    with open(d) as f:\r\n        for vrstica in f:\r\n            zneski.append(sum(vrniKalorije(vrstica)))\r\n    return zneski", 
      "trial": "def trial(source):\r\n    if check_function('kalorijeNaDan', 1):\r\n        _makefile2(\"_3b.in\")\r\n        _equal('kalorijeNaDan(\"_3b.in\")', [138, 33, 8, 269, 105])\r\n        _removefiles(\"_3b.in\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 174, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavi funkcijo `nizi2(vhod, izhod)`, ki izpi\u0161e vse nize iz vhodne\r\n# datoteke na izhodno datoteko. Nizi se lahko za\u010dnejo in kon\u010dajo na\r\n# razli\u010dnih vrsticah. \u010ce se niz razteza \u010dez ve\u010d vrstic, naj izhodni niz\r\n# vsebuje tudi znake za novo vrstico. \u0160e vedno naj ostale nize izpi\u0161e\r\n# vsakega v svojo vrstico. Predpostavi, da nimamo praznih nizov.\r\n#\r\n# Primer: \u010ce je v vhodni datoteki besedilo\r\n#    V \"tej\" vrstici je \"en zelo zelo\r\n#    dolg niz\", ki se kon\u010da v \"drugi\" vrsti.\r\n# potem mora program v izhodno datoteko zapisati\r\n#    tej\r\n#    en zelo zelo\r\n#    dolg niz\r\n#    drugi\r\n", 
      "solution": "def trial(source):\r\n    if check_function('nizi2', 2):\r\n        _makefile1(\"_test1.txt\")\r\n        nizi2(\"_test1.txt\",\"_test2.txt\")\r\n        _makefile2(\"_test3.txt\")\r\n        _equal('_istedatoteke(\"_test2.txt\",\"_test3.txt\",\"_test1.txt\")',True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1.txt\",\"_test2.txt\",\"_test3.txt\")\r\n    yield\r\n", 
      "trial": "def nizi2(vhod, izhod):\r\n    with open(vhod) as fv, open(izhod, \"w\") as fi:\r\n        vNizu=False\r\n        niz=\"\"\r\n        for vrstica in fv:\r\n            for z in vrstica:\r\n                if z=='\"':\r\n                    vNizu= not vNizu\r\n                    if not vNizu and len(niz)>0: # niz se je pravkar zaklju\u010dil\r\n                        print(niz, file=fi)\r\n                        niz=\"\"\r\n                    continue\r\n                if vNizu:\r\n                    niz+=z\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 126, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavi funkcijo naloga3b, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga3b(vhod,izhod):\r\n    f1=open(vhod)\r\n    f2=open(izhod,\"w\")\r\n    for vrstica in f1:\r\n        nv=\"\"\r\n        for z in vrstica:\r\n            if z == '%':\r\n                break\r\n            nv+=z\r\n        if len(nv) > 0:\r\n            f2.write(nv)\r\n    f1.close()\r\n    f2.close()", 
      "trial": "def trial(source):\r\n    if check_function('naloga3b', 2):\r\n        _makefile(\"_test1b.txt\")\r\n        _makefile2(\"_test3b.txt\")\r\n        naloga3b(\"_test1b.txt\",\"_test2b.txt\")\r\n        _equal('_istedatoteke(\"_test2b.txt\",\"_test3b.txt\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1b.txt\",\"_test2b.txt\",\"_test3b.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 108, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavite funkcijo `je_permutacija(slovar)`, ki vrne True, \u010de dan\r\n# slovar predstavlja permutacijo, in False sicer.", 
      "solution": "def je_permutacija(slovar):\r\n    kljuci = list(slovar.keys())\r\n    vrednosti = list(slovar.values())\r\n    kljuci.sort()\r\n    vrednosti.sort()\r\n    return kljuci == vrednosti == list(range(1, len(kljuci) + 1))", 
      "trial": "def trial(source):\r\n    if check_function('je_permutacija', 1):\r\n        _equal('je_permutacija({1: 3, 2: 4, 3: 2, 4: 1})', True)\r\n        _equal('je_permutacija({1: 3, 2: 2, 3: 2, 4: 1})', False)\r\n        _equal('je_permutacija({1: 3, 2: 4, 4: 1})', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 158, 
    "model": "problem.part", 
    "fields": {
      "_order": 9, 
      "description": "# Sestavi funkcijo `koliko(niz, datoteka), ki kot argument dobi niz\r\n# imen lo\u010den z vejicami, ter ime izhodne datoteke. Na izhodno datoteko za\r\n# vsako ime zapi\u0161ite, kolikokrat se pojavi v nizu imen.\r\n# \u010ce je niz enak \"Jaka,Luka,Miha,Luka\", naj se v izhodno datoteko izpi\u0161e\r\n#     Jaka 1\r\n#     Luka 2\r\n#     Miha 1", 
      "solution": "def koliko(niz,d):\r\n    imena = niz.split(',')\r\n    enkrat_imena = set(imena)\r\n    with open(d, 'w') as f:\r\n        for ime in enkrat_imena:\r\n            print(ime, kolikokratSePojavi(niz, ime), file=f)", 
      "trial": "def trial(source):\r\n    if check_function('koliko', 2):\r\n        _makefile2(\"_test2.csv\")\r\n        koliko(\"Jaka,Luka,Miha,Luka,Miha,Miha\",\"_test1.csv\")\r\n        _equal('_istevseenodatoteke(\"_test1.csv\", \"_test2.csv\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1.csv\",\"_test2.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 175, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Popravi funkcijo `nizi2` tako, da ne upo\u0161teva narekovajev, pred\r\n# katerimi se nahaja znak '\\'. Funkciji naj bo ime `nizi3`.\r\n", 
      "solution": "def trial(source):\r\n    if check_function('nizi3', 2):\r\n        _makefile1(\"_test1.txt\")\r\n        nizi3(\"_test1.txt\",\"_test2.txt\")\r\n        _makefile3(\"_test3.txt\")\r\n        _equal('_istedatoteke(\"_test2.txt\",\"_test3.txt\",\"_test1.txt\")',True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1.txt\",\"_test2.txt\",\"_test3.txt\")\r\n    yield\r\n", 
      "trial": "def nizi3(vhod, izhod):\r\n    with open(vhod) as fv, open(izhod, \"w\") as fi:\r\n        vNizu=False\r\n        ignoriraj=False\r\n        niz=\"\"\r\n        for vrstica in fv:\r\n            for z in vrstica:\r\n                if z=='\\\\':\r\n                    ignoriraj=True\r\n                elif z=='\"' and not ignoriraj:\r\n                    vNizu= not vNizu\r\n                    if not vNizu and len(niz)>0: # niz se je pravkar zaklju\u010dil\r\n                        print(niz, file=fi)\r\n                        niz=\"\"\r\n                    continue\r\n                else:\r\n                    ignoriraj=False # znak ni nagibnica, torej ne ignoriramo naslednjega\r\n                if vNizu:\r\n                    niz+=z\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 255, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavite metodo 'vsotaKalorij', ki kot argumente dobi dve datoteki: vhodno \r\n# (kamor Tina zapisuje svoje podatke) in izhodno. Na izhodno datoteko \r\n# naj za vsako vrstico v vhodni datoteki izpi\u0161e vsoto kalori\u010dnih \r\n# vrednosti hrane tistega dne. \u0160tevila v izhodni datoteki naj bodo\r\n# vsako v svoji vrstici.", 
      "solution": "def vsotaKalorij(v,i):\r\n    with open(v) as f:\r\n        with open(i, \"w\") as g: \r\n            for vrstica in f:\r\n                print(sum(vrniKalorije(vrstica)), file = g)", 
      "trial": "def trial(source):\r\n    if check_function('vsotaKalorij', 2):\r\n        _makefile2(\"_3c.in\")\r\n        _makefile3(\"_3co.out\")\r\n        vsotaKalorij(\"_3c.in\", \"_3c.out\")\r\n        _equal('_istevseenodatoteke(\"_3c.out\", \"_3co.out\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_3c.in\", \"_3c.out\", \"_3co.out\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 109, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavite funkcijo `realno(a, b)`, ki vrne naklju\u010dno realno \u0161tevilo\r\n# na intervalu $(a, b)$.", 
      "solution": "import random\r\n\r\ndef realno(a, b):\r\n    return random.uniform(a, b)", 
      "trial": "def trial(source):\r\n    if check_function('realno', 2):\r\n        if isinstance(realno(1.3, 7.8), float):\r\n            random.seed('a')\r\n            _equal('1.3 <= min([realno(1.3,7.8) for i in range(1000)])', True, 'Va\u0161a funkcija vra\u010da \u0161tevila, manj\u0161a od spodnje meje intervala.')\r\n            _equal('max([realno(1.3,7.8) for i in range(1000)]) <= 7.8', True, 'Va\u0161a funkcija vra\u010da \u0161tevila, ve\u010dja od zgornje meje intervala.')\r\n            _equal('len(set([round(realno(1, 3), 6) for i in range(10000)])) > 9950', True, 'Va\u0161a funkcija ne vra\u010da naklju\u010dnih \u0161tevil')\r\n        else:\r\n            _equal('False', True, 'Va\u0161a funkcija ne vra\u010da realnih \u0161tevil.')\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 144, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavi funkcijo `vsote(vhod, izhod)`, ki kot parametra dobi imeni\r\n# dveh datotek. Iz prve naj prebere vrstice s podatki, ki so lo\u010deni z\r\n# vejicami, nato pa naj izra\u010duna vsoto to\u010dk za vsako vrstico in v drugo\r\n# datoteko shrani podatke `Ime Priimek, vsota`. Za vsako vrstico v vhodni\r\n# datoteki morate shraniti ustrezno vrstico v izhodno datoteko.", 
      "solution": "def vsote(vhod,izhod):\r\n    s=naloziCSV(vhod)\r\n    f=open(izhod,\"w\")\r\n    for student in s:\r\n        print(\"{0},{1}\".format(student[0],sum(student[1:])), file=f)\r\n    f.close()", 
      "trial": "def trial(source):\r\n    if check_function('vsote', 2):\r\n        _makefile(\"_test.csv\")\r\n        _makefile2(\"_test2.csv\")\r\n        vsote(\"_test.csv\",\"_test1.csv\")\r\n        _equal('_istedatoteke(\"_test1.csv\", \"_test2.csv\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test.csv\", \"_test1.csv\",\"_test2.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 263, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavite funkcijo `najvecVhodnih(g)`, ki vrne tisto vozli\u0161\u010de\r\n# usmerjenega grafa `g`, v katero vodi najve\u010d povezav.\r\n# \u010ce je takih vozli\u0161\u010d ve\u010d, lahko funkcija vrne poljubno izmed njih.", 
      "solution": "def najvecVhodnih(g):\r\n    vozlisca = list(g.keys())\r\n    vse_vhodne = []\r\n    for p in g.values():\r\n        vse_vhodne += list(p)\r\n    stopnje = [vse_vhodne.count(v) for v in vozlisca]\r\n    return vozlisca[stopnje.index(max(stopnje))]\r\n    # lahko pa uporabimo rezultat naslednje naloge:\r\n    # return najvecIzhodnih(obrni(g))", 
      "trial": "def trial(source):\r\n    if check_function('najvecVhodnih', 1):\r\n        _equal('najvecVhodnih({1: {3}, 2: {1, 3}, 3: set()})', 3)\r\n        _equal('najvecVhodnih({1: {3}, 2: set(), 3: set()})', 3)\r\n        _equal('najvecVhodnih({1: {3, 2}, 2: {1}, 3: {1}})', 1)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 207, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavite metodo 'izdatkiDatoteka', ki kot argumente dobi dve datoteki: vhodno in izhodno. \n# Na izhodno naj za vsak seznam zneskov na vhodni datoteki izpi\u0161e njihovo vsoto - vsako v \n# svojo vrstico.", 
      "solution": "def izdatkiDatoteka(v,i):\n    with open(v) as f:\n        with open(i, \"w\") as g: \n            for vrstica in f:\n                print(sum(preberiIzdatke(vrstica)), file = g)", 
      "trial": "def trial(source):\n    if check_function('izdatkiDatoteka', 2):\n        _makefile0(\"_3c.in\")\n        _makefile1(\"_3co.out\")\n        izdatkiDatoteka(\"_3c.in\", \"_3c.out\")\n        _equal('_istevseenodatoteke(\"_3c.out\", \"_3co.out\")', True, \"Izhodna datoteka je napa\u010dna\")\n        _removefiles(\"_3c.in\", \"_3c.out\", \"_3co.out\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 127, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavi funkcijo naloga3c, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga3c(vhod,izhod):\r\n    f1=open(vhod)\r\n    f2=open(izhod,\"w\")\r\n    for vrstica in f1:\r\n        nv=\"\"\r\n        nagib=False\r\n        for z in vrstica:\r\n            if z=='%' and not nagib:\r\n                break\r\n            nv+=z\r\n            if z=='\\\\':\r\n                nagib=True\r\n                continue\r\n            else:\r\n                nagib=False\r\n        if len(nv) > 0:\r\n            f2.write(nv)\r\n    f1.close()\r\n    f2.close()", 
      "trial": "def trial(source):\r\n    if check_function('naloga3c', 2):\r\n        _makefile(\"_test1c.txt\")\r\n        _makefile3(\"_test3c.txt\")\r\n        naloga3c(\"_test1c.txt\",\"_test2c.txt\")\r\n        _equal('_istedatoteke(\"_test2c.txt\",\"_test3c.txt\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1c.txt\",\"_test2c.txt\",\"_test3c.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 159, 
    "model": "problem.part", 
    "fields": {
      "_order": 10, 
      "description": "# Sestavi funkcijo `kolikoizdatoteke(vhod,izhod)`, ki kot argument dobi\r\n# ime vhodne datoteke ter ime izhodne datoteke. Na izhodno datoteko za\r\n# vsako ime zapi\u0161ite, kolikokrat se pojavi v vhodni datoteki (pozor:\r\n# vhodna datoteka ima lahko ve\u010d vrstic).", 
      "solution": "def kolikoizdatoteke(v,i):\r\n    with open(v) as f:\r\n        imena = \",\".join([l.strip() for l in f.readlines()])\r\n        imena = imena.replace(' ', '')\r\n        koliko(imena,i)", 
      "trial": "def trial(source):\r\n    if check_function('kolikoizdatoteke', 2):\r\n        _makefile(\"_test.csv\")\r\n        _makefile2(\"_test2.csv\")\r\n        kolikoizdatoteke(\"_test.csv\",\"_test1.csv\")\r\n        _equal('_istevseenodatoteke(\"_test1.csv\", \"_test2.csv\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test.csv\", \"_test1.csv\",\"_test2.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 208, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavite metodo 'povprecniIzdatek', ki kot argumente dobi dve datoteki: vhodno in izhodno. \n# Na izhodno naj za vsak seznam zneskov na vhodni izpi\u0161e \u0161tevilko vrstice ter povpre\u010dni \n# znesek. V zadnjo vrstico pa naj zapi\u0161e povpre\u010dje povpre\u010dnih zneskov.\n# Povpre\u010dja naj bodo zaokro\u017eena na najbli\u017eje celo \u0161tevilo.", 
      "solution": "def povprecniIzdatek(v,i):\n    suma = 0\n    stevilo = 0\n    with open(v) as f:\n        with open(i, \"w\") as g:\n            for vrstica in f:\n                izdatki = preberiIzdatke(vrstica)\n                stevilo += 1\n                suma += round(sum(izdatki) / len(izdatki))\n                print(round(sum(izdatki) / len(izdatki)), file = g)\n            print(round(suma / stevilo), file = g)", 
      "trial": "def trial(source):\n    if check_function('povprecniIzdatek', 2):\n        _makefile0(\"_3d.in\")\n        _makefile2(\"_3do.out\")\n        povprecniIzdatek(\"_3d.in\",\"_3d.out\")\n        _equal('_istedatoteke(\"_3d.out\", \"_3do.out\")', True, \"Izhodna datoteka je napa\u010dna\")\n        _removefiles(\"_3d.in\", \"_3do.out\",\"_3d.out\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 128, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavi funkcijo naloga3d, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga3d(vhod,izhod):\r\n    f1=open(vhod)\r\n    f2=open(izhod,\"w\")\r\n    for vrstica in f1:\r\n        nv=\"\"\r\n        nagib=False\r\n        for z in vrstica:\r\n            if z=='%' and not nagib:\r\n                break\r\n            nv+=z\r\n            if z=='\\\\':\r\n                nagib=not nagib\r\n                continue\r\n            else:\r\n                nagib=False\r\n        if len(nv) > 0:\r\n            f2.write(nv)\r\n    f1.close()\r\n    f2.close()", 
      "trial": "def trial(source):\r\n    if check_function('naloga3a', 2):\r\n        _makefile(\"_test1d.txt\")\r\n        _makefile4(\"_test3d.txt\")\r\n        naloga3d(\"_test1d.txt\",\"_test2d.txt\")\r\n        _equal('_istedatoteke(\"_test2d.txt\",\"_test3d.txt\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1d.txt\",\"_test2d.txt\",\"_test3d.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 283, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavite funkcijo `obrni(g)`, ki vrne slovar, ki predstavlja isti\r\n# graf kot `g`, le da vse povezave v njem ka\u017eejo v drugo smer.", 
      "solution": "def obrni(g):\r\n    obrnjen = dict((v, set()) for v in g.keys())\r\n    for v, p in g.items():\r\n        for w in p:\r\n            obrnjen[w].add(v)\r\n    return obrnjen", 
      "trial": "def trial(source):\r\n    if check_function('obrni', 1):\r\n        _equal('obrni({1: {3}, 2: {1, 3}, 3: set()})', {1: {2}, 2: set(), 3: {1, 2}})\r\n        _equal('obrni({1: {3}, 2: set(), 3: set()})', {1: set(), 2: set(), 3: {1}})\r\n        _equal('obrni({1: {3, 2}, 2: {1}, 3: {1}})', {1: {2, 3}, 2: {1}, 3: {1}})\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 176, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Popravi funkcijo `nizi3` tako, da bo upo\u0161tevala \"\" kot en narekovaj,\r\n# ki je del niza, \u010de se nahaja v nizu. \u0160e vedno pa naj ne upo\u0161teva\r\n# narekovajev, pred katerimi se nahaja znak '\\'. Funkcija naj se imenuje\r\n#`nizi4`.\r\n#\r\n# Primer: \u010ce je v vhodni datoteki vrstica\r\n#    abc \"\" def \"nekaj \"\" in to\" je vse\r\n# potem mora va\u0161a funkcija v izhodno datoteko zapisati\r\n#    nekaj \" in to\r\n", 
      "solution": "def nizi4(vhod, izhod):\r\n    with open(vhod) as fv, open(izhod, \"w\") as fi:\r\n        vNizu=False\r\n        ignoriraj=False\r\n        narekovaj=False\r\n        niz=\"\"\r\n        for vrstica in fv:\r\n            for z in vrstica:\r\n                if z=='\\\\':\r\n                    ignoriraj=True\r\n                    narekovaj=False\r\n                elif z=='\"' and not ignoriraj:\r\n                    if narekovaj: # dvojni narekovaj!\r\n                        narekovaj=False\r\n                        vNizu= not vNizu\r\n                        if vNizu: # ce smo v nizu, dodajmo en narekovaj\r\n                            niz+=z\r\n                        continue\r\n                    narekovaj=True\r\n                    vNizu= not vNizu\r\n                    continue\r\n                else:\r\n                    ignoriraj=False # znak ni nagibnica ali narekovaj\r\n                    narekovaj=False\r\n                if vNizu:\r\n                    niz+=z\r\n                elif len(niz)>0: # nismo ve\u010d v nizu\r\n                    print(niz, file=fi)\r\n                    niz=\"\"\r\n", 
      "trial": "def trial(source):\r\n    if check_function('nizi4', 2):\r\n        _makefile1(\"_test1.txt\")\r\n        nizi4(\"_test1.txt\",\"_test2.txt\")\r\n        _makefile4(\"_test3.txt\")\r\n        _equal('_istedatoteke(\"_test2.txt\",\"_test3.txt\",\"_test1.txt\")',True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test1.txt\",\"_test2.txt\",\"_test3.txt\")\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 160, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavi funkcijo `kolikourejen(vhod, izhod)`, ki kot argument dobi ime\r\n# vhodne datoteke ter ime izhodne datoteke. Na izhodno datoteko za\r\n# vsako ime zapi\u0161ite, kolikokrat se pojavi v vhodni datoteki (pozor:\r\n# vhodna datoteka ima lahko ve\u010d vrstic). Imena naj bodo urejena po\r\n# padajo\u010di frekvenci ponovitev.", 
      "solution": "def kolikourejen(v,i):\r\n    with open(v) as f:\r\n        imena = \",\".join([l.strip() for l in f.readlines()])\r\n    enkrat_imena = set(imena.split(\",\"))\r\n    stevilo = [(ime, kolikokratSePojavi(imena, ime)) for ime in enkrat_imena]\r\n    stevilo.sort(key=lambda p: -p[1])\r\n    with open(i, 'w') as f:\r\n        for ime, s in stevilo:\r\n            print(ime, s, file=f)", 
      "trial": "def trial(source):\r\n    if check_function('kolikourejen', 2):\r\n        _makefile(\"_test.csv\")\r\n        _makefile2(\"_test2.csv\")\r\n        kolikourejen(\"_test.csv\",\"_test1.csv\")\r\n        _equal('_istedatoteke(\"_test1.csv\", \"_test2.csv\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test.csv\", \"_test1.csv\",\"_test2.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 110, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavite funkcijo `tocka(a, b, c, d)`, ki vrne naklju\u010dno to\u010dko na\r\n# pravokotniku $(a, b) \\\\times (c, d)$, predstavljeno z naborom dveh\r\n# realnih \u0161tevil.", 
      "solution": "import random\r\n\r\ndef tocka(a, b, c, d):\r\n    return (realno(a, b), realno(c, d))", 
      "trial": "def trial(source):\r\n    if check_function('tocka', 4):\r\n        random.seed('a')\r\n        if isinstance(tocka(1, 2, 3, 4)[0], float) and isinstance(tocka(1, 2, 3, 4)[1], float):\r\n            _equal('1.3 <= min([tocka(1.3, 7.8, -2.4, 5.3)[0] for i in range(1000)])', True, 'Va\u0161a funkcija vra\u010da to\u010dke levo od izbranega pravokotnika.')\r\n            _equal('-2.4 <= min([tocka(1.3, 7.8, -2.4, 5.3)[1] for i in range(1000)])', True, 'Va\u0161a funkcija vra\u010da to\u010dke pod izbranim pravokotnikom.')\r\n            _equal('max([tocka(1.3, 7.8, -2.4, 5.3)[0] for i in range(1000)]) <= 7.8', True, 'Va\u0161a funkcija vra\u010da to\u010dke desno od izbranega pravokotnika.')\r\n            _equal('max([tocka(1.3, 7.8, -2.4, 5.3)[1] for i in range(1000)]) <= 5.3', True, 'Va\u0161a funkcija vra\u010da to\u010dke nad izbranim pravokotnikom.')\r\n            _equal('len(set([map(round, tocka(0, 0, 1, 1)) for i in range(10000)])) > 9950', True, 'Va\u0161a funkcija ne vra\u010da naklju\u010dnih \u0161tevil')\r\n        else:\r\n            _equal('False', True, 'Va\u0161a funkcija ne vra\u010da parov realnih \u0161tevil.')\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 145, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavi funkcijo `rezultati(vhod, izhod)`, ki kot parametra dobi imeni\r\n# dveh datotek. Iz prve naj prebere vrstice s podatki, v drugo pa naj\r\n# shrani originalne podatke, skupaj z vsotami (dodano na koncu), v zadnji\r\n# vrstici pa naj doda \u0161e povpre\u010dne ocene po posameznih stolpcih, zaokro\u017eene\r\n# na dve decimalni mesti. Ime v tej vrstici naj bo `Povprecen Student`.\r\n# V izhodni datoteki naj bodo vrstice urejene po priimkih (razen zadnje\r\n# vrstice, v kateri so povpre\u010dja). Ne pozabite na povpre\u010dje vsot!", 
      "solution": "def rezultati(vhod, izhod):\r\n    s=naloziCSV(vhod)\r\n    f=open(izhod,\"w\")\r\n    # Izra\u010dunamo vsote po vrsticah:\r\n    N=len(s)\r\n    for i in range(N):\r\n        s[i]=s[i]+(sum(s[i][1:]),)\r\n    # Sortiramo po priimkih\r\n    s.sort(key=lambda x: x[0].split(' ')[1])\r\n    # Izra\u010dunamo povpre\u010dja po stolpcih\r\n    M=len(s[0])\r\n    popv=[\"Povprecen Student\"]+[round(sum(s[i][j] for i in range(N))/N,2) for j in range(1,M)]\r\n    s.append(tuple(popv))\r\n    # Zapi\u0161emo podatke\r\n    for vrstica in s:\r\n        print(','.join(str(x) for x in vrstica),file=f)\r\n    f.close()", 
      "trial": "def trial(source):\r\n    if check_function('naloziCSV', 1):\r\n        _makefile(\"_test.csv\")\r\n        _makefile3(\"_test2.csv\")\r\n        rezultati(\"_test.csv\",\"_test1.csv\")\r\n        _equal('_istedatoteke(\"_test1.csv\", \"_test2.csv\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_test.csv\", \"_test1.csv\",\"_test2.csv\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 256, 
    "model": "problem.part", 
    "fields": {
      "_order": 11, 
      "description": "# Sestavite metodo 'povprecjeKalorij', ki kot argumente dobi dve \r\n# datoteki: vhodno in izhodno. Na izhodno datoteko naj za vsako vrstico \r\n# na vhodni datoteki izpi\u0161e \u0161tevilko vrstice (\u0161teti se za\u010dno z ena), \r\n# ter povpre\u010dno kalori\u010dno vrednost hrane, ki jo je Tina tisti dan zau\u017eila. \r\n# V zadnjo vrstico pa naj zapi\u0161e povpre\u010dje dnevno pou\u017eitih kalorij.", 
      "solution": "def povprecjeKalorij(v,i):\r\n    suma = 0\r\n    stevilo = 0\r\n    with open(v) as f:\r\n        with open(i, \"w\") as g:\r\n            for vrstica in f:\r\n                izdatki = vrniKalorije(vrstica)\r\n                stevilo += 1\r\n                suma += round(sum(izdatki) / len(izdatki))\r\n                print(round(sum(izdatki) / len(izdatki)), file = g)\r\n            print(round(suma / stevilo), file = g)", 
      "trial": "def trial(source):\r\n    if check_function('povprecjeKalorij', 2):\r\n        _makefile2(\"_3d.in\")\r\n        _makefile4(\"_3do.out\")\r\n        povprecjeKalorij(\"_3d.in\",\"_3d.out\")\r\n        _equal('_istedatoteke(\"_3d.out\", \"_3do.out\")', True, \"Izhodna datoteka je napa\u010dna\")\r\n        _removefiles(\"_3d.in\", \"_3do.out\",\"_3d.out\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 129, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Sestavi funkcijo naloga4a, tako kot zahteva besedilo naloge.", 
      "solution": "from math import sqrt,acos\r\ndef norm(v):\r\n    return sqrt(sum(x**2 for x in v))\r\n\r\ndef naloga4a(v,w):\r\n    n1=norm(v)\r\n    n2=norm(w)\r\n    if n1>0 and n2>0:\r\n        return acos((v[0]*w[0]+v[1]*w[1])/(n1*n2))\r\n    else:\r\n        return 0", 
      "trial": "def trial(source):\r\n    if check_function('naloga4a', 2):\r\n        _equal('naloga4a((1,0),(0,0))',0)\r\n        _equal('round(naloga4a((1,0),(0,1)),5)',1.5708)\r\n        _equal('round(naloga4a((1,0),(-1,0)),5)',3.14159)\r\n        _equal('round(naloga4a((1,0),(0,-1)),5)',1.5708)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 161, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Zvezna porazdelitev slu\u010dajne spremenljivke ima porazdelitveno funkcijo\r\n#\r\n# F(x). Ozna\u010di pravilne trditve, ki veljajo za vsako zvezno porazdelitev.\r\n#\r\n# 1) F(x) je absolutno zvezna. \t\r\n#\r\n# 2) F(x) je padajo\u010da funkcija \t\r\n#\r\n# 3) Ko x te\u017ei k +\\infty , F(x) te\u017ei k 1 \t\r\n#\r\n# 4) Ko x te\u017ei k -\\infty , F(x) te\u017ei k 0 \t\r\n#\r\n# 5) F(x) je monotona \t\r\n#\r\n# 6) F(0) = 1/2 \t\r\n#\r\n# 7) F(0) = 0\r\n#\r\n# Sestavite funkcijo naloga13, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 7, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga13():\r\n    return {1,3,4,5}", 
      "trial": "def trial(source):\r\n    if check_function('naloga13', 0):\r\n        _equal('md5(str(naloga13()).encode()).hexdigest()', 'cd4ba60543a1806596ee2d8290285c7d', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 111, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Sestavite funkcijo `vUniji(x, y, krogi)`, ki vrne True, \u010de to\u010dka\r\n# $(x, y)$ le\u017ei v vsaj enem krogu v danem seznamu `krogi`, in False\r\n# sicer. Ta seznam je sestavljen iz trojic $(x_i, y_i, r_i)$, ki\r\n# predstavljajo kroge s sredi\u0161\u010di $(x_i, y_i)$ in radiji $r_i$.", 
      "solution": "def vUniji(x, y, krogi):\r\n    for (xi, yi, ri) in krogi:\r\n        if (x - xi) ** 2 + (y - yi) ** 2 <= ri**2:\r\n            return True\r\n    return False", 
      "trial": "def trial(source):\r\n    if check_function('vUniji', 3):\r\n        _equal('vUniji(2, 3, [])', False)\r\n        _equal('vUniji(2, 2, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', True)\r\n        _equal('vUniji(2, 5, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', True)\r\n        _equal('vUniji(5, 3, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 209, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Sestavi funkcijo 'nakljucno', ki vrne naklju\u010dno realno \u0161tevilo na intervalu [a,b).\n# \u0160tevili a in b naj sprejme kot svoja argumenta.\n# Primer:\n#    >>> nakljucno(1, 3)\n#    2.9870806222977304", 
      "solution": "import random\ndef nakljucno(a, b):\n    return random.random() * (b-a) + a", 
      "trial": "def trial(source):\n    if check_function('nakljucno', 2):\n        _equal('nakljucno({0}, {1}) >= {0} and nakljucno({0}, {1}) < {1}'.format(7,8), True, \"Odgovor je napa\u010den\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 146, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# S katerimi ukazi ustvarimo prazno mno\u017eico?\r\n#\r\n# 1) p=()\r\n#\r\n# 2) p=(,)\r\n#\r\n# 3) p={}\r\n#\r\n# 4) p={0}; p.remove(0)\r\n#\r\n# 5) p=set()\r\n#\r\n#\r\n# Sestavite funkcijo naloga13, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 5, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga13():\r\n    return {4,5}\r\n", 
      "trial": "def trial(source):\r\n    if check_function('naloga13', 0):\r\n        pass\r\n        #_equal('md5(str(naloga13()).encode()).hexdigest()', '039376c7eafa923fae4dc28382d1d08c')#, \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 257, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Sestavi funkcijo 'karta', ki vrne naklju\u010dno karto. Karte so oblike 'XY', kjer\r\n# je X eden izmed 'A', 'B', 'C', 'D', Y pa 1, 2, 3, 4, 5, 6, 7, 8, ali 9.\r\n# Primer:\r\n#    >>> karta()\r\n#    'B3'", 
      "solution": "import random\r\ndef karta():\r\n    X = random.choice(['A', 'B', 'C', 'D'])\r\n    Y = random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9])\r\n    return X + str(Y)", 
      "trial": "def trial(source):\r\n    if check_function('karta', 0):\r\n        _equal(\"karta()[0] in ['A', 'B', 'C', 'D'] and karta()[1] in ['1', '2', '3', '4', '5', '6', '7', '8', '9']\", True, \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 177, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Ladja pluje v re\u010dno pristani\u0161\u010de. Na poti ima nekaj dvi\u017enih mostov, ki\r\n# so odprti le nekaj \u010dasa vsako uro (sicer pa mora ladja pred njimi \u010dakati).\r\n# Vsak most se odpre to\u010dno ob uri, nato je dolo\u010deno \u0161tevilo minut (med 1 in 59)\r\n# odprt, nato pa se zapre. Za vsak most imamo podano \u0161tevilo minut, ko je most odprt.\r\n#\r\n# Primer: \u010de je podatek za nek most 17, potem je most odprt v \u010dasu 0-17, v \u010dasu\r\n# 18-59 pa je zaprt.\r\n#\r\n# Sestavi funkcijo `cakam(most, cas)`, ki sprejme \u010das odprtja nekega mosta ter\r\n# \u010das prihoda ladje, vrne pa, koliko \u010dasa mora ladja \u010dakati. Prvi podatek\r\n# je celo \u0161tevilo med 1 in 59 (vklju\u010dno), drugi pa celo \u0161tevilo med 0 in 59.\r\n# Predpostavi\u0161 lahko, da sta podani vrednosti veljavni.\r\n", 
      "solution": "def cakam(most, cas):\r\n    return 0 if cas <= most else 60-cas\r\n", 
      "trial": "def trial(source):\r\n    if check_function('cakam', 2):\r\n        for i in [randint(15,50) for k in range(20)]:\r\n            _equal('cakam({0},{1})'.format(i,i), 0)\r\n            _equal('cakam({0},{1})'.format(i,i-5), 0)\r\n            _equal('cakam({0},{1})'.format(i,i-10), 0)\r\n            _equal('cakam({0},{1})'.format(i,i+10), 50-i)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 284, 
    "model": "problem.part", 
    "fields": {
      "_order": 12, 
      "description": "# Simon in Greta sta mlad zaljubljen par, ki pri\u010dakuje svojega prvega\r\n# otroka. Skrbni sorodniki jima po elektronski po\u0161ti po\u0161iljajo datoteke,\r\n# v katerih jima pi\u0161ejo, kaj vse NUJNO rabita.\r\n# Vsaka datoteka je sestavljena iz vrstic, v katerih pi\u0161e: ime predmeta,\r\n# cena predmeta (zaokro\u017eeno na evre), nujnost (od 1 do 10, kjer je 10\r\n# najbolj nujno).\r\n#\r\n# Primer nekaj vrstic:\r\n#     avtomati\u010dno brisalo ritke,231,10\r\n#     ljubezen,0,1\r\n#     ortopedsko oblikovana duda,15,7\r\n# Predpostavite lahko, da v imenu ni vejic, da okoli vejic ni\r\n# presledkov, ter da sta v vsaki vrstici natanko dve vejici.\r\n#\r\n# Sestavite funkcijo `pretvori(vrstica)`, ki iz dane vrstice ustvari\r\n# trojico `(ime, cena, nujnost)`, pri \u010demer naj bosta `cena` in\r\n# `nujnost` \u0161tevili.", 
      "solution": "def pretvori(vrstica):\r\n    besede = vrstica.split(\",\")\r\n    return (besede[0], int(besede[1]), int(besede[2]))", 
      "trial": "def trial(source):\r\n    if check_function('pretvori', 1):\r\n        _equal('pretvori(\"avtomati\u010dno brisalo ritke,231,10\")', (\"avtomati\u010dno brisalo ritke\", 231, 10))\r\n        _equal('pretvori(\"ljubezen,0,1\")', (\"ljubezen\", 0, 1))\r\n        _equal('pretvori(\"ortopedsko oblikovana duda,15,7\")', (\"ortopedsko oblikovana duda\", 15, 7))\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 258, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Sestavi funkcijo 'roka', ki kot parameter dobi mno\u017eico 5 kart, vrne pa\r\n# mno\u017eico 5 naklju\u010dnih kart, razli\u010dnih od podanih 5 kart.\r\n# Primer:\r\n#    >>> roka({'A8', 'A5', 'B4', 'B5', 'C7'})\r\n#    {'C9', 'B7', 'D2', 'A6', 'C4'}", 
      "solution": "def roka(karte):\r\n    vrni = set()\r\n    while len(vrni) != 5:\r\n        k = karta()\r\n        if k not in karte:\r\n            vrni.add(k)\r\n    return vrni", 
      "trial": "def trial(source):\r\n    if check_function('roka', 1):\r\n        karte = {'C9', 'B7', 'D2', 'A6', 'C4'}\r\n        out = roka(karte)\r\n        _equal('len({0})'.format(str(out)), 5)\r\n        for k in out:\r\n            _equal('\"{0}\" not in {1}'.format(k, karte), True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 178, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Ladja pride pred i-ti most ob naklju\u010dnem \u010dasu v njegovem\r\n# enournem ciklu. Sestavi funkcijo `kolikoCakam(mostovi, i, cas)`, ki sprejme\r\n# seznam odpiralnih \u010dasov mostov in \u010das, ob katerem ladja pride do i-tega\r\n# mosta, ter vrne, koliko minut bo morala po\u010dakati, da se i-ti most odpre.\r\n# Predpostavi\u0161 lahko, da je 1 <= i <= len(mostovi). Prvi element seznama\r\n# ustreza mostu \u0161t. 1.\r\n", 
      "solution": "def kolikoCakam(mostovi, i, cas):\r\n    return cakam(mostovi[i-1], cas)\r\n", 
      "trial": "def trial(source):\r\n    if check_function('kolikoCakam', 3):\r\n        _equal('kolikoCakam([59, 30, 17, 45], 3, 17)',0)\r\n        _equal('kolikoCakam([59, 30, 17, 45], 1, 17)',0)\r\n        _equal('kolikoCakam([59, 30, 17, 45], 1, 59)',0)\r\n        _equal('kolikoCakam([59, 30, 17, 45], 2, 35)',25)\r\n        _equal('kolikoCakam([59, 30, 17, 45], 4, 46)',14)\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 112, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Sestavite funkcijo `vPreseku(x, y, krogi)`, ki vrne True, \u010de to\u010dka\r\n# $(x, y)$ le\u017ei v vseh krogih v danem seznamu `krogi`, in False\r\n# sicer.", 
      "solution": "def vPreseku(x, y, krogi):\r\n    for (xi, yi, ri) in krogi:\r\n        if (x - xi) ** 2 + (y - yi) ** 2 > ri**2:\r\n            return False\r\n    return True", 
      "trial": "def trial(source):\r\n    if check_function('vPreseku', 3):\r\n        _equal('vPreseku(2, 3, [])', True)\r\n        _equal('vPreseku(2, 2, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', True)\r\n        _equal('vPreseku(2, 5, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', False)\r\n        _equal('vPreseku(5, 3, [(2, 2, 3), (1, 1, 4), (2, 0, 3)])', False)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 210, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Sestavi funkcijo 'nakljucnaTocka', ki vrne naklju\u010dno to\u010dko v pravokotniku [a,b) x [c,d)\n# (to\u010dko naj vrne kot nabor). \u0160tevila a, b, c in d naj sprejme kot \n# argumente metode.\n# Primer:\n#    >>> nakljucnaTocka(0,1,0,1)\n#    (0.1429732365608365, 0.6141558734157921)", 
      "solution": "def nakljucnaTocka(a, b, c, d):\n    return (nakljucno(a,b), nakljucno(c,d))", 
      "trial": "def trial(source):\n    if check_function('nakljucnaTocka', 4):\n        _equal('nakljucnaTocka(2,3,0,1)[0]<3 and nakljucnaTocka(2,3,0,1)[1]<1 and nakljucnaTocka(2,3,0,1)[0]>=2 and nakljucnaTocka(2,3,0,1)[1]>=0', True, \"Odgovor je napa\u010den\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 147, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Pri klasi\u010dni definiciji verjetnosti nastopajo naslednji pojmi:\r\n#\r\n# 1) Vsi izidi \t\r\n#\r\n# 2) Ugodni izidi \t\r\n#\r\n# 3) Sigma algebra \t\r\n#\r\n# 4) Bernoullijevo zaporedje \t\r\n#\r\n# 5) Dol\u017eina intervala\r\n#\r\n# 6) Fibonaccijevo zaporedje\r\n#\r\n# 7) Nemogo\u010d dogodek\r\n#\r\n# 8) Zadetek\r\n#\r\n#\r\n# Sestavite funkcijo naloga14, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 8, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga14():\r\n    return {1,2}", 
      "trial": "def trial(source):\r\n    if check_function('naloga14', 0):\r\n        pass\r\n        #_equal('md5(str(naloga14()).encode()).hexdigest()', '190cda75e2bd9dc669b09abe9f1131c5', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 285, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Sestavite funkcijo `preberi(imeDatoteke)`, ki vrstice datoteke\r\n# pretvori v ustrezen seznam trojic.\r\n# Na primer, iz zgornje datoteke bi dobili seznam:\r\n# `[(\"avtomati\u010dno brisalo ritke\", 231, 10), (\"ljubezen\", 0, 1), (\"ortopedsko oblikovana duda\", 15, 7)]`", 
      "solution": "def preberi(imeDatoteke):\r\n    seznam = []\r\n    with open(imeDatoteke) as f:\r\n        for vrstica in f:\r\n            seznam.append(pretvori(vrstica))\r\n    return seznam", 
      "trial": "def trial(source):\r\n    import os\r\n    if check_function('preberi', 1):\r\n        with open(\"_seznam.txt\", \"w\") as f:\r\n            print(\"avtomati\u010dno brisalo ritke,231,10\", file=f)\r\n            print(\"ljubezen,0,1\", file=f)\r\n            print(\"ortopedsko oblikovana duda,15,7\", file=f)\r\n        _equal('preberi(\"_seznam.txt\")', [(\"avtomati\u010dno brisalo ritke\", 231, 10), (\"ljubezen\", 0, 1), (\"ortopedsko oblikovana duda\", 15, 7)])\r\n        os.remove(\"_seznam.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 162, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# S katerimi ukazi ustvarimo prazen nabor?\r\n#\r\n# 1) p={}\r\n#\r\n# 2) p=(,)\r\n#\r\n# 3) p=()\r\n#\r\n# 4) p={,}\r\n#\r\n# 5) p=set()\r\n#\r\n# 6) p=tuple()\r\n#\r\n# 7) p=dict()\r\n#\r\n# Sestavite funkcijo naloga14, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 7, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga14():\r\n    return {3,6}", 
      "trial": "def trial(source):\r\n    if check_function('naloga14', 0):\r\n        _equal('md5(str(naloga14()).encode()).hexdigest()', '75d34c54a7d0d1f7d8b543a9c84b8f4d', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 130, 
    "model": "problem.part", 
    "fields": {
      "_order": 13, 
      "description": "# Sestavi funkcijo naloga4b, tako kot zahteva besedilo naloge.", 
      "solution": "import random\r\ndef naloga4b():\r\n    return (random.random(), random.random())", 
      "trial": "def trial(source):\r\n    if check_function('naloga4b', 0):\r\n        _equal('type(naloga4b())',tuple,\"Funkcija ne vra\u010da nabora\")\r\n        _equal('len(naloga4b())',2,\"Funkcija ne vra\u010da nabora dol\u017eine 2\")\r\n        _equal('len(set(naloga4b() for i in range(1000))) > 950',True,\"To\u010dke niso naklju\u010dne\")\r\n        _equal('0<=naloga4b()[0]<1 and 0<=naloga4b()[1]<1',True, \"To\u010dke ne le\u017eijo v enotskem kvadratu\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 131, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavi funkcijo naloga15, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga4c(trik):\r\n    v1=(trik[1][0]-trik[0][0],trik[1][1]-trik[0][1])\r\n    v2=(trik[2][0]-trik[0][0],trik[2][1]-trik[0][1])\r\n    v3=(trik[1][0]-trik[2][0],trik[1][1]-trik[2][1])\r\n    print(naloga4a(v1,v2)  , naloga4a(v3,v2) , naloga4a(v1,v3))\r\n    if naloga4a(v1,v2) < pi/2 and naloga4a(v3,v2) < pi/2 and naloga4a(v1,v3) < pi/2:\r\n        return True\r\n    else:\r\n        return False", 
      "trial": "def trial(source):\r\n    if check_function('naloga4c', 1):\r\n        _equal('naloga4c([(0,0), (1,0), (0,1)])',False)\r\n        _equal('naloga4c([(0,0), (1,0), (0.5,1)])',True)\r\n        _equal('naloga4c([(0,0), (1,0), (0.5,.3)])',False)\r\n        _equal('naloga4c([(-1,-1), (0,1), (1,-1)])',True)        \r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 113, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavite funkcijo `pravokotnik(krogi)`, ki poi\u0161\u010de najmanj\u0161i pravokotnik,\r\n# ki vsebuje unijo vseh krogov iz danega seznama `krogi`. Pravokotnik\r\n# naj vrne kot nabor $(x_{min},y_{min},x_{max},y_{max})$, torej\r\n# najorej koordinati ogli\u0161\u010da spodaj levo, nato pa koordinati ogli\u0161\u010da zgoraj\r\n# desno", 
      "solution": "def pravokotnik(krogi):\r\n    a = min(xi - ri for (xi, _, ri) in krogi)\r\n    b = max(xi + ri for (xi, _, ri) in krogi)\r\n    c = min(yi - ri for (_, yi, ri) in krogi)\r\n    d = max(yi + ri for (_, yi, ri) in krogi)\r\n    return (a,c,b,d)", 
      "trial": "def trial(source):\r\n    if check_function('pravokotnik', 1):\r\n        _equal('pravokotnik([(0, 0, 1)])', (-1,-1,1,1), \"Enotski krog (0, 0, 1) je vsebovan v pravokotniku z ogli\u0161\u010di (-1,-1) in (1,1)\")\r\n        _equal('pravokotnik([(0, 0, 1), (2, 2, 2)])', (-1,-1,4,4), \"Kroga (0, 0, 1) in (2, 2, 2) sta vsebovana v pravokotniku z ogli\u0161\u010di (-1,-1) in (4,4).\")\r\n        _equal('pravokotnik([(-1, 1, 1), (2, -2, 1)])', (-2,-3,3,2), \"Kroga (-1, 1, 1) in (2, -2, 1) sta vsebovana v pravokotniku z ogli\u0161\u010di (-2,-3) in (3,2).\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 148, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Na kak\u0161en na\u010din lahko nalo\u017eimo konstanto e (osnovo naravnega logaritma)?\r\n#\r\n# 1) from time import e \t\r\n#\r\n# 2) from os import e\t\r\n#\r\n# 3) from math import e\r\n#\r\n# 4) import e\r\n#\r\n# 5) from cmath import e\r\n#\r\n# 6) from math import * \t\r\n#\r\n# 7) import math\r\n#\r\n# 8) from random import e\r\n#\r\n# 9) Konstanta e se ne nahaja v standardni knji\u017enici\r\n#\r\n# 10) from math import exp\r\n#\r\n# 11) import e from math\r\n#\r\n#\r\n# Sestavite funkcijo naloga15, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 11, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico).", 
      "solution": "def naloga15():\r\n    return {3, 5, 6}", 
      "trial": "def trial(source):\r\n    if check_function('naloga15', 0):\r\n        pass\r\n        #_equal('md5(str(naloga15()).encode()).hexdigest()', '2fbb033eaf09004b738b14061b4856f6', \"Odgovor je napa\u010den\")\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 163, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# S katero funkcijo si lahko pomagamo, \u010de \u017eelimo me\u0161ati karte?\r\n#\r\n# 1) randomize iz modula random\r\n#\r\n# 2) choice iz modula random\r\n#\r\n# 3) randomcards iz modula random \t\r\n#\r\n# 4) random iz modula random\r\n#\r\n# 5) shift iz modula math\r\n#\r\n# 6) seed iz modula random\r\n#\r\n# 7) shuffle iz modula random\r\n#\r\n# Sestavite funkcijo naloga15, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 7, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga15():\r\n    return {1,3,7}", 
      "trial": "def trial(source):\r\n    if check_function('naloga15', 0):\r\n        _equal('md5(str(naloga15()).encode()).hexdigest()', 'ae2c66a5f437e6b37bdc5340f83cf14b', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 211, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavi funkcijo 'nadGrafom', ki kot parametra dobi funkcijo f in to\u010dko (x,y), vrne\n# pa naj True, \u010de to\u010dka le\u017ei nad grafom funkcije in False sicer.\n# Primer:\n#    >>> nadGrafom(math.cos, (0,2))\n#    True", 
      "solution": "def nadGrafom(f, t):\n    (x,y) = t\n    if y > f(x): \n        return True\n    return False\n\nimport math", 
      "trial": "def trial(source):\n    import math\n    if check_function('nadGrafom', 2):\n        _equal('nadGrafom(math.sin, (1, 0.3))', False, \"Odgovor je napa\u010den\")\n        _equal('nadGrafom(math.sin, (1, 1))', True, \"Odgovor je napa\u010den\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 179, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavi funkcijo `cakanja`, ki sprejme poljubno \u0161tevilo\r\n# odpiralnih \u010dasov mostov, nato pa naklju\u010dno iz\u017ereba n \u0161tevil\r\n# med 0 in 59, ki predstavljajo minuto prihoda ladje k vskemu izmed\r\n# mostov (n je \u0161tevilo podanih mostov). Funkcija naj vrne nabor\r\n# dol\u017eine n, ki predstavlja \u010das \u010dakanja ladje pred posameznim mostom.\r\n", 
      "solution": "def cakanja(*mostovi):\r\n    n=len(mostovi)\r\n    casi=[randint(0,59) for i in range(n)]\r\n    return tuple(cakam(mostovi[i], casi[i]) for i in range(n))\r\n", 
      "trial": "def trial(source):\r\n    if check_function('cakanja', 0):\r\n        _equal('type(cakanja(30))', tuple, \"Funkcija ne vra\u010da naborov\")\r\n        _equal('len(cakanja(30,20,10))', 3, \"Funkcija ne vra\u010da nabora prave dol\u017eine\")\r\n        _equal('len(cakanja(10,30,20, 5, 4, 1))', 6, \"Funkcija ne vra\u010da nabora prave dol\u017eine\")\r\n        _equal('sum([cakanja(59)[0] for i in range(100)])', 0, \"Funkcija vra\u010da napa\u010dne vrednosti\")\r\n        for i,j,k in [(randint(1,59), randint(1,59), randint(1,59)) for x in range(10)]:\r\n            _equal('min([x for l in range(100) for x in cakanja({},{},{})])'.format(i,j,k),0, \"Funkcija vra\u010da napa\u010dne vrednosti\")\r\n            _equal('max([x for l in range(1000) for x in cakanja({},{},{})])'.format(i,j,k),113-min(i+54,j+54,k+54), \"Funkcija vra\u010da napa\u010dne vrednosti\")\r\n            _equal('len(set([cakanja({})[0] for l in range(1000)]))'.format(i), 60-i, \"Funkcija ne vra\u010da naklju\u010dnih vrednosti\")\r\n\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 259, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavi funkcijo 'premaga', ki kot parametra dobi dve mno\u017eici 5-ih kart in vrne\r\n# True, \u010de prva mno\u017eica premaga drugo in False sicer. Neka mno\u017eica kart\r\n# premaga drugo, \u010de je njena vrednost ve\u010dja. Vrednost izra\u010dunamo tako,\r\n# da se\u0161tejemo vrednosti vseh \u0161tevk in vsoto delimo s \u0161tevilom razli\u010dnih\r\n# \u010drk. Tako je npr. vrednost mno\u017eice kart {'A1', 'D3', 'B7', 'A8', 'A2'}\r\n# enaka (1+3+7+8+2)/3 = 7.0\r\n# Primer:\r\n#    >>> premaga({'A8', 'A5', 'B4', 'B5', 'C7'}, {'C9', 'B7', 'D2', 'A6', 'C4'})\r\n#    True", 
      "solution": "def _vrednost(karte):\r\n    suma = 0\r\n    crke = set()\r\n    for k in karte:\r\n        suma += int(k[1])\r\n        crke.add(k[0])\r\n    return suma / len(crke)\r\n\r\ndef premaga(k1, k2):\r\n    return _vrednost(k1) > _vrednost(k2)", 
      "trial": "def trial(source):\r\n    if check_function('premaga', 2):\r\n        _equal(\"premaga({'A8', 'A5', 'B4', 'B5', 'C7'}, {'C9', 'B7', 'D2', 'A6', 'C4'})\", True)\r\n        _equal(\"premaga({'C9', 'B7', 'D2', 'A6', 'C4'}, {'A8', 'A5', 'B4', 'B5', 'C7'})\", False)\r\n        _equal(\"premaga({'C1', 'B1', 'C3', 'C5', 'D1'}, {'D6', 'D3', 'A2', 'B9', 'B7'})\", False)\r\n        \r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }, 
  {
    "pk": 286, 
    "model": "problem.part", 
    "fields": {
      "_order": 14, 
      "description": "# Sestavite funkcijo `sestej(imeDatoteke)`, ki iz datoteke prebere vrstice,\r\n# nato pa izra\u010duna vsoto vrednosti vseh predmetov. Pozor: nekateri predmeti se\r\n# lahko pojavijo ve\u010dkrat, z razli\u010dnimi cenami. V tem primeru upo\u0161tevajte\r\n# najni\u017ejo ceno. Funkcija naj vrne vsoto.\r\n#\r\n# Na primer, iz datoteke\r\n#     ortopedsko oblikovana duda,18,7\r\n#     avtomati\u010dno brisalo ritke,231,10\r\n#     ortopedsko oblikovana duda,15,7\r\n#     ljubezen,0,1\r\n#     ortopedsko oblikovana duda,21,7\r\n#     ljubezen,1,1\r\n# bi dobili vsoto `246` (231+15+0).", 
      "solution": "def sestej(imeDatoteke):\r\n    seznam=preberi(imeDatoteke)\r\n    predmeti=dict()\r\n    for el in seznam:\r\n        v=predmeti.get(el[0])\r\n        if v!= None:\r\n            if el[1] >= v: continue\r\n        predmeti[el[0]]=el[1]\r\n    \r\n    return sum(predmeti.values())", 
      "trial": "def trial(source):\r\n    import os\r\n    if check_function('sestej', 1):\r\n        with open(\"_seznam.txt\", \"w\") as f:\r\n            print(\"ortopedsko oblikovana duda,18,4\", file=f)\r\n            print(\"avtomati\u010dno brisalo ritke,231,10\", file=f)\r\n            print(\"ortopedsko oblikovana duda,15,7\", file=f)\r\n            print(\"ljubezen,0,1\", file=f)\r\n            print(\"ortopedsko oblikovana duda,21,5\", file=f)\r\n            print(\"ljubezen,1,1\", file=f)\r\n        _equal('sestej(\"_seznam.txt\")', 246)\r\n        _removefiles(\"_seznam.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 212, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavi funkcijo 'ploscina', ki kot parametre dobi funkcijo f, kraji\u0161\u010di intervala\n# a in b, zgornjo mejo M za funkcijo f na intervalu a, b ter \u0161tevilo\n# ponovitev N. Nato naj s pomo\u010djo Monte Carlo integracije izra\u010duna\n# pribli\u017eek za dolo\u010den integral funkcije f na intervalu [a,b) tako, da\n# generira N naklju\u010dnih to\u010dk v pravokotniku [a,b)x[0,M) in izra\u010duna\n# razmerje med \u0161tevilom to\u010dk pod grafom funkcije f in N. Plo\u0161\u010dina \n# pod grafom funkcije je nato to razmerje krat plo\u0161\u010dina pravokotnika [0,M).\n# Primer: \n#    >>> ploscina(lambda x: x, 0, 2, 2, 1000)\n#    1.016", 
      "solution": "def ploscina(f, a, b, M, N):\n    pod = 0\n    for i in range(N):\n        tocka = nakljucnaTocka(a,b,0,M)\n        if not nadGrafom (f, tocka):\n            pod += 1\n    koncna = pod / N * M * (b-a)\n    return pod / N * M * (b-a)", 
      "trial": "def trial(source):\n    if check_function('ploscina', 5):\n        _equal('abs(ploscina(lambda x: x, 0, 2, 2, 100000)-2)<0.1', True, \"Odgovor je napa\u010den\")\n        _equal('abs(ploscina(math.sin, 0, math.pi/2, 1, 100000)-1)<0.1', True, \"Odgovor je napa\u010den\")\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 20
    }
  }, 
  {
    "pk": 287, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavite funkcijo `poSkupinah(vhod,izhod)`, ki iz datoteke `vhod`\r\n# prebere vrstice (kot v prej\u0161njih nalogah), nato pa izra\u010duna vsoto\r\n# vrednosti predmetov posamezne nujnosti. Podobno kot prej se\r\n# nekateri predmeti lahko pojavijo ve\u010dkrat, z razli\u010dnimi cenami in razli\u010dnimi\r\n# nujnostmi. Kot prej upo\u0161tevajte najni\u017ejo ceno. \u010ce je takih ve\u010d, vzemite\r\n# najvi\u0161jo nujnost. V datoteko izhod nato zapi\u0161ite rezultate `nujnost,vsota`,\r\n# urejene padajo\u010de po nujnosti.\r\n#\r\n# Na primer, iz datoteke\r\n#     ortopedsko oblikovana duda,18,7\r\n#     avtomati\u010dno brisalo ritke,231,10\r\n#     ortopedsko oblikovana duda,15,4\r\n#     ljubezen,0,1\r\n#     ortopedsko oblikovana duda,15,7\r\n#     ljubezen,1,1\r\n#     plenice,17,7\r\n# bi v izhodni datoteki dobili vrstice\r\n#     10,231\r\n#     7,32\r\n#     1,0", 
      "solution": "def poSkupinah(vhod,izhod):\r\n    seznam=preberi(vhod)\r\n    predmeti=dict()\r\n    for el in seznam:\r\n        v=predmeti.get(el[0])\r\n        if v!=None:\r\n            if el[1] > v[0]: continue\r\n            elif el[1] == v[0] and el[2]<=v[1]: continue\r\n        predmeti[el[0]]=(el[1],el[2])\r\n    nujnosti=dict()\r\n    for (c,n) in predmeti.values():\r\n        nujnosti[n]=nujnosti.get(n,0)+c\r\n    sNujnosti=list(nujnosti.keys())\r\n    sNujnosti.sort(reverse=True)\r\n    with open(izhod,\"w\") as f:\r\n        for x in sNujnosti:\r\n            print(\"{0},{1}\".format(x,nujnosti[x]),file=f)", 
      "trial": "def trial(source):\r\n    import os\r\n    if check_function('poSkupinah', 2):\r\n        with open(\"_seznam.txt\", \"w\") as f:\r\n            print(\"ortopedsko oblikovana duda,18,7\", file=f)\r\n            print(\"avtomati\u010dno brisalo ritke,231,10\", file=f)\r\n            print(\"ortopedsko oblikovana duda,15,4\", file=f)\r\n            print(\"ljubezen,0,1\", file=f)\r\n            print(\"ortopedsko oblikovana duda,15,7\", file=f)\r\n            print(\"ljubezen,1,1\", file=f)\r\n            print(\"plenice,17,7\", file=f)\r\n        with open(\"_seznam1.txt\",\"w\") as f:\r\n            print(\"10,231\",file=f)\r\n            print(\"7,32\",file=f)\r\n            print(\"1,0\",file=f)\r\n        poSkupinah(\"_seznam.txt\",\"_seznam2.txt\")\r\n        try:\r\n            _equal('_istedatoteke(\"_seznam1.txt\",\"_seznam2.txt\")',True,\"Napa\u010dna izhodna datoteka\")\r\n        except:\r\n            _equal('False',True,\"Napaka pri preverjanju izhodne datoteke\")\r\n        _removefiles(\"_seznam.txt\",\"_seznam1.txt\",\"_seznam2.txt\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 22
    }
  }, 
  {
    "pk": 149, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Katere trditve veljajo za slu\u010dajno spremenljivko randint(1,100)?\r\n#\r\n# 1) Zaloga vrednosti je (1,100) \t\r\n#\r\n# 2) Zaloga vrednosti je [1,100) \t\r\n#\r\n# 3) Spremenljivka je enakomerno porazdeljena. \t\r\n#\r\n# 4) Spremenljivka je normalno porazdeljena. \t\r\n#\r\n# 5) Zaloga vrednosti je [1,100]\r\n#\r\n# 6) Zaloga vrednosti so naravna \u0161tevila med 1 in 100\r\n#\r\n# 7) Zaloga vrednosti so naravna \u0161tevila med 1 in 99\r\n#\r\n# 8) Zaloga vrednosti so cela \u0161tevila med 1 in 100\r\n#\r\n# 9) Zaloga vrednosti so cela \u0161tevila med 1 in 99\r\n#\r\n# 10) Ta funkcija ne obstaja\r\n#\r\n#\r\n# Sestavite funkcijo naloga16, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 10, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico).", 
      "solution": "def naloga16():\r\n    return {3, 6, 8}", 
      "trial": "def trial(source):\r\n    if check_function('naloga16', 0):\r\n        pass\r\n        #_equal('md5(str(naloga16()).encode()).hexdigest()', 'ce3f059fdf1baedaf5367dbc9dc995a8', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 17
    }
  }, 
  {
    "pk": 164, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Katere trditve veljajo za slu\u010dajno spremenljivko random()?\r\n#\r\n# 1) Zaloga vrednosti je (0,1) \t\r\n#\r\n# 2) Zaloga vrednosti je [0,1)\r\n#\r\n# 3) Spremenljivka je enakomerno porazdeljena.\r\n#\r\n# 4) Spremenljivka je normalno porazdeljena.\r\n#\r\n# 5) Zaloga vrednosti je [0,1]\r\n#\r\n# 6) Zaloga vrednosti je (0,1]\r\n#\r\n# 7) Zaloga vrednosti so cela \u0161tevila\r\n#\r\n# Sestavite funkcijo naloga16, ki kot rezultat vrne mno\u017eico pravilnih\r\n# odgovorov (teh je lahko od 0 do 7, \u010de noben odgovor ni pravilen, naj\r\n# funkcija vrne prazno mno\u017eico)", 
      "solution": "def naloga16():\r\n    return {2,3}", 
      "trial": "def trial(source):\r\n    if check_function('naloga16', 0):\r\n        _equal('md5(str(naloga16()).encode()).hexdigest()', '5ad06bc3b78920bcf496ed9a814cf4db', \"Odgovor je napa\u010den\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 18
    }
  }, 
  {
    "pk": 132, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavi funkcijo naloga4d, tako kot zahteva besedilo naloge.", 
      "solution": "def naloga4d(n):\r\n    st=0\r\n    for i in range(n):\r\n        trik=[naloga4b(),naloga4b(),naloga4b()]\r\n        if naloga4c(trik):\r\n            st+=1\r\n    return st/n", 
      "trial": "def trial(source):\r\n    if check_function('naloga4d', 1):\r\n        _equal('0<naloga4d(100)<1',True)\r\n        _equal('5<len(set(naloga4d(100) for i in range(200))) < 25',True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 16
    }
  }, 
  {
    "pk": 114, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavite funkcijo `ploscina(krogi, N)`, ki na slede\u010d na\u010din izra\u010duna\r\n# pribli\u017eek plo\u0161\u010dine unije krogov iz danega seznama `krogi`.\r\n# Izbere si `N` to\u010dk v najmanj\u0161em pravokotniku, ki vsebuje vse dane\r\n# kroge. Nato pre\u0161teje \u0161tevilo to\u010dk, ki le\u017eijo v vsaj enem od krogov,\r\n# ter to \u0161tevilo deli z `N` in mno\u017ei s plo\u0161\u010dino pravokotnika.", 
      "solution": "def ploscina(krogi, N):\r\n    (a,c,b,d)=pravokotnik(krogi)\r\n    notri = 0\r\n    for i in range(N):\r\n        (x, y) = tocka(a, b, c, d)\r\n        if vUniji(x, y, krogi): notri += 1\r\n    return (b - a) * (d - c) * notri / N", 
      "trial": "def trial(source):\r\n    if check_function('ploscina', 2):\r\n        _equal('3 < ploscina([(0, 0, 1)], 1000) < 3.3', True, \"Plo\u0161\u010dina enotskega kroga (0, 0, 1) bi morala biti pribli\u017eno pi.\")\r\n        _equal('12 < ploscina([(0, 0, 2)], 1000) < 13.2', True, \"Plo\u0161\u010dina enotskega kroga (0, 0, 2) bi morala biti pribli\u017eno 4 pi.\")\r\n        _equal('6 < ploscina([(0, 0, 1), (2, 2, 1)], 1000) < 6.6', True, \"Plo\u0161\u010dina krogov (0, 0, 1) in (2, 2, 1) bi morala biti pribli\u017eno 2 pi.\")\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 14
    }
  }, 
  {
    "pk": 180, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavi funkcijo `povprecno`, ki pove, koliko je povpre\u010dni skupni\r\n# pri\u010dakovani \u010das \u010dakanja ladje pred mostovi za dane odpiralne \u010dase.\r\n# Sprejme naj \u0161tevilo iteracij N ter poljubno \u0161tevilo odpiralnih \u010dasov\r\n# mostov. Nato naj N-krat naklju\u010dno iz\u017ereba prihode ladje k mostovom ter\r\n# nazadnje vrne povpre\u010dni skupni \u010dakalni \u010das teh N-iteracij. Skupni \u010dakalni\r\n# \u010das je vsota vseh posameznih \u010dakalnih \u010dasov. Predpostavi\u0161 lahko, da je N>0.\r\n", 
      "solution": "def povprecno(N, *mostovi):\r\n    cas = 0\r\n    for i in range(N):\r\n        cas += sum(cakanja(*mostovi))\r\n    return cas/N\r\n", 
      "trial": "def trial(source):\r\n    if check_function('povprecno', 1):\r\n        _equal('sum([povprecno(59) for i in range(100)])', 0, \"Funkcija vra\u010da napa\u010dne vrednosti\")\r\n        for i in [randint(5,50) for _ in range(5)]:\r\n            _equal('len(set([povprecno(100,{}) for l in range(50)]))>25'.format(i), True, \"Funkcija ne vra\u010da naklju\u010dnih vrednosti\")\r\n        for i,j,k,l in [(randint(10,50), randint(10,50), randint(10,50), randint(10,50)) for x in range(10)]:\r\n            _equal('_jeblizu(povprecno(100,{0},{1},{2},{3}),{4},.2)'.format(i,j,k,l, 118-i-j-k-l+(i*i+j*j+k*k+l*l+i+j+k+l)/120),True, \"Funkcija vra\u010da napa\u010dne vrednosti\")\r\n    yield\r\n", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 19
    }
  }, 
  {
    "pk": 260, 
    "model": "problem.part", 
    "fields": {
      "_order": 15, 
      "description": "# Sestavi funkcijo' verjetnostZmage', ki s pomo\u010djo metode Monte Carlo izra\u010duna verjetnost,\r\n# da zmagamo z neko mno\u017eico kart. Funkcija kot parametra dobi mno\u017eico\r\n# 5 kart in \u0161tevilo ponovitev N, nato pa N krat generira 5 naklju\u010dnih\r\n# kart, razli\u010dnih od podanih in pre\u0161teje, kolikokrat podani nabor premaga\r\n# naklju\u010den nabor. Funkcija naj vrne verjetnost, da zmagamo (tj. razmerje\r\n# med \u0161tevilom zmag in \u0161t. poskusov).\r\n# Primer:\r\n#    >>> verjetnostZmage({'D6', 'D3', 'A2', 'B9', 'B7'}, 1000)\r\n#    0.659", 
      "solution": "def verjetnostZmage(karte, N):\r\n    zmagam = 0\r\n    for i in range(N):\r\n        nasprotnik = roka(karte)\r\n        if premaga(karte, nasprotnik):\r\n            zmagam += 1\r\n    return zmagam / N", 
      "trial": "def trial(source):\r\n    if check_function('verjetnostZmage', 2):\r\n        _equal(\"abs(verjetnostZmage({'D6', 'D3', 'A2', 'B9', 'B7'}, 1000)-0.68) < 0.2\", True)\r\n        _equal(\"abs(verjetnostZmage({'B4', 'C9', 'A5', 'A7', 'A6'}, 1000)-0.82) < 0.1\", True)\r\n    yield", 
      "secret": "6adf97f83acf6453d4a6a4b1070f3754", 
      "problem": 21
    }
  }
]