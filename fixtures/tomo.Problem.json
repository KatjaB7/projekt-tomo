[
  {
    "pk": 300, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Floyd-Warshallov algoritem", 
      "timestamp": "2013-01-07 11:31:31", 
      "author": 1, 
      "problem_set": 90, 
      "preamble": ""
    }
  }, 
  {
    "pk": 97, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Smre\u010dice", 
      "timestamp": "2013-02-25 00:45:43", 
      "author": 1, 
      "problem_set": 37, 
      "preamble": ""
    }
  }, 
  {
    "pk": 150, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Volitve", 
      "timestamp": "2012-04-16 12:30:21", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": "def izpis(f,*args):\n    import io, sys\n    old_stdout = sys.stdout\n    new_stdout = io.StringIO()\n    sys.stdout = new_stdout\n    f(*args)\n    sys.stdout = old_stdout\n    return new_stdout.getvalue()\n\ndef _makefile(ime):\n    with open(ime, \"w\") as f:\n        print('Sami \"nizi\" in \"nenizi\"', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('\"celotna vrstica en sam niz\"', file=f)\n        print('\"niz na zacetku\" in \"na koncu\"', file=f)\n\ndef _makefile1(ime):\n    with open(ime, \"w\") as f:\n        print('Sami \"nizi\" in \\\\\"nenizi\\\\\", pa \"do\\\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en \"kratek\\\\\"', file=f)\n        print('spet \\\\\"niz na zacetku', file=f)\n        print('in \"na koncu\"spet\\\\\"', file=f)\n        print('in \"niz\"\"do niza\" pa \\\\\"\"kratek\"\\\\\"', file=f)\n\ndef _makefile2(ime):\n    with open(ime, \"w\") as f:\n        print('nizi\\nnenizi\\\\\\ndo\\\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\\nkratek\\\\', file=f)\n        print('niz na zacetku', file=f)\n        print('in \\nspet\\\\', file=f)\n        print('niz\\ndo niza\\n\\\\', file=f)\n        \ndef _makefile3(ime):\n    with open(ime, \"w\") as f:\n        print('nizi', file=f)\n        print('do\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\n        print('na koncu\\nniz\\ndo niza\\nkratek', file=f)\n\ndef _makefile4(ime):\n    with open(ime, \"w\") as f:\n        print('nizi', file=f)\n        print('do\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\n        print('na koncu\\nniz\"do niza\\nkratek', file=f)\n        \ndef _istedatoteke(ena,dva,original=None):\n    with open(ena) as f1, open(dva) as f2:\n        n1=f1.read().strip()\n        n2=f2.read().strip()\n        if n1 != n2:\n            if original != None:\n                print(\"Vhodna datoteka:\\n\"+'-'*50)\n                with open(original) as f3:\n                    print(f3.read())\n                print('-'*50)\n            print(\"Rezultat tvoje funkcije:\")\n            print(n1)\n            print(\"=\"*50+\"\\nPravilno:\")\n            print(n2)\n            return False\n        return True\n\ndef _jeblizu(a, b, eps=.1):\n    if b == 0:\n        return abs(a) < eps\n    else:\n        return abs(1-a/b) < eps\n    \ndef _removefiles(*ime):\n    import os\n    for i in ime:\n        try:\n            os.remove(i)\n        except:\n            pass\n\nfrom random import randint"
    }
  }, 
  {
    "pk": 257, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Rekurzivno urejanje z zlivanjem", 
      "timestamp": "2012-10-16 09:14:50", 
      "author": 1, 
      "problem_set": 79, 
      "preamble": ""
    }
  }, 
  {
    "pk": 51, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Obi\u010dajni postopek iskanja elementa v urejeni tabeli z bisekcijo\ndeluje tudi, \u010de se elementi v tabeli ponavljajo, na primer\n\n    a = [1, 2, 2, 5, 6, 7, 7, 7, 8, 9, 10]\n\nV tem primeru bisekcija najde eno od pojavitev elementa. V\u010dasih\npa \u017eelimo poiskati *obmo\u010dje*, na katerem se pojavlja dani element.\nZa zgornjo tabelo `a` bi bilo obmo\u010dje za `7` podtabela `a[5:8]`.", 
      "language": 2, 
      "title": "Bisekcija na ponovljenih elementih", 
      "timestamp": "2011-11-23 14:40:34", 
      "author": 19, 
      "problem_set": 15, 
      "preamble": ""
    }
  }, 
  {
    "pk": 175, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Ford-Fulkersonov algoritem", 
      "timestamp": "2012-03-02 13:14:14", 
      "author": 1, 
      "problem_set": 63, 
      "preamble": "class Omrezje:\n\n    def __init__(self):\n        self.povezave = {}\n        self.tok = {}\n\n    def __repr__(self):\n        return \"\\n\".join(['{0}: {1} -{2}--{3}- {4}'.format(i, p[0], p[1], p[2], p[3]) for i, p in self.tok.items()])\n\n    def dodajTocko(self, tocka):\n        self.povezave[tocka] = set()\n\n    def dodajPovezavo(self, povezava, zacetek, konec, kapaciteta):\n        self.tok[povezava] = ((zacetek, kapaciteta, 0, konec))\n        self.povezave[zacetek].add(povezava)\n        self.povezave[konec].add(povezava)\n\nprimer = Omrezje()\nfor i in [1, 2, 3, 4, 5, 6]:\n    primer.dodajTocko(i)\nfor i, (z, k, kap) in enumerate([(1, 2, 6), (2, 3, 3), (3, 4, 10), (1, 5, 4), (5, 6, 2), (6, 4, 1), (2, 6, 5), (5, 3, 1)]):\n    primer.dodajPovezavo(i, z, k, kap)"
    }
  }, 
  {
    "pk": 33, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "\u010ce vektorju nastavimo dimenzije, postane matrika, kjer gredo elementi\nnajprej od zgoraj navzdol, nato pa od leve proti desni.\n    \n    x <- 1 : 100\n    dim(x) <- c(5, 20) # x naj bo matrika dimenzije 5 \u00d7 20\n    x\n    dim(x) <- c(10, 10) # x naj bo matrika dimenzije 10 \u00d7 10\n    x\n\nMatrike na\u010deloma sestavljamo z ukazom `matrix`, ki sprejme vektor\nkomponent ter \u0161tevilo vrstic in stolpcev.\n\n    matrix(1 : 100, 10, 10)\n    matrix(1 : 10, 20, 5) # spet velja cikli\u010dno dopolnjevanje\n\nPodatki se na\u010deloma polnijo po stolpcih, s parametrom `byrow=TRUE` pa jih\nlahko polnimo tudi po vrsticah.\n\n    matrix(1 : 10, 20, 5, byrow=TRUE)\n    \nDo elementov dostopamo tako kot poprej, le da indekse lo\u010dimo z vejicami\n\n    x[10, 5]            # element v 10. vrstici in 5. stolpcu\n    x[c(4, 6), c(5, 9)] # elementi v 4. in 6. vrstici ter 5. in 9. stolpcu\n    x[4 : 6, 5 : 9]     # elementi od 4. do 6. vrstice ter od 5. do 9. stolpca\n    c(x[4, 5], x[6, 9]) # elementa v 4. vrstici in 5. stolpcu\n                        # ter v 6. vrstici in 9. stoplcu.\n    \n\u010ce indeksa ne podamo, vzamemo vse elemente\n\n    x[5, ] # vsi elementi v 5. vrstici\n    x[, 6] # vsi elementi v 6. stoplcu\n    \nUkaza `row` in `col` vrneta matriko indeksov vrstic in stolpcev.\nUkaza sta uporabna predvsem v indeksnih vektorjih\n\n    x[row(x) %in% c(2, 3, 5, 7)] # vsi elementi v 2., 3., 5. in 7. vrstici\n    x[row(x) == col(x)]          # vsi elementi na diagonali\n    x[row(x) == col(x) + 1]      # vsi elementi pod diagonalo\n    x[row(x) == col(x) - 1]      # vsi elementi nad diagonalo\n    \nSeveda spreminjanje dimenzij ni najbolj pameten na\u010din ustvarjanja matrik\nVe\u010d vektorjev enake dol\u017eine lahko zlo\u017eimo v matriko po vrsticah z ukazom\n`rbind` ali po stolpcih z ukazom `cbind`.\n\n    ocene <- rbind(Miha = c(mat = 5, sjk = 3, fiz = 3),\n                   Maja = c(mat = 4, sjk = 5, fiz = 4))\n    ocene[\"Miha\", \"mat\"]\n    \nPozor: veljajo imena stolpcev prvega vnosa:\n\n    ocene <- rbind(Miha = c(mat = 5, sjk = 3, fiz = 3),\n                   Maja = c(kem = 4, bio = 5, geo = 4))\n    \n\u010ce ukaz `rbind` (ali `cbind`) uporabimo na spremenljivkah, se njihova imena\nuporabijo za imena stolpcev.\n    \n    visine <- c(168, 197, 162, 174, 195, 167, 175, 159, 172, 182, 181, 176)\n    mase <- c(84, 70, 48, 74, 64, 73, 84, 88, 68, 71, 63, 68)\n    podatki <- cbind(visine, mase)\n\n\n\u010ce je komponenta matrike odvisna le od koordinat, si lahko pomagamo s\nfunkcijo `outer`. \n\nPo\u0161tevanko tako dobimo z ukazom\n\n    outer(1 : 10, 1 : 10, \"*\") # simbole predstavimo z nizi\n    \nmatriko binomskih koeficientov pa z\n\n    outer(0 : 10, 0 : 10, choose)\n\nFunkcija, ki jo kli\u010demo, mora delovati na vektorjih,\nvendar ve\u010d o tem naslednji\u010d.", 
      "language": 1, 
      "title": "Matrike", 
      "timestamp": "2011-11-23 14:34:53", 
      "author": 1, 
      "problem_set": 8, 
      "preamble": ""
    }
  }, 
  {
    "pk": 212, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 2", 
      "timestamp": "2012-03-27 08:57:32", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def _makefile0(fname, ime, vrednost):\r\n    with open(fname, \"w\") as f:\r\n        print(ime, file=f)\r\n        print(vrednost, file=f)\r\n\r\ndef _makefile1(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"a\", file=f)\r\n        print(\"0\", file=f)\r\n        print(\"b\", file=f)\r\n        print(\"1\", file=f)\r\n        print(\"c\", file=f)\r\n        print(\"2\", file=f)\r\n\r\n\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"2,35,18,5,78\", file=f)\r\n        print(\"13,20\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"15,84,2,4,5,16,78,44,21\", file=f)\r\n        print(\"10,5,50,40\", file=f)\r\n\r\ndef _makefile3(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"138\", file=f)\r\n        print(\"33\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"269\", file=f)\r\n        print(\"105\", file=f)\r\n\r\n\r\n\r\ndef _makefile4(ime):\r\n    with open(ime, \"w\") as f:                                                                                                                                                                     \r\n        print(\"1 28\", file=f)\r\n        print(\"2 16\", file=f)\r\n        print(\"3 8\", file=f)\r\n        print(\"4 30\", file=f)\r\n        print(\"5 26\", file=f)\r\n        print(\"22\", file=f)\r\n\r\n\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n\r\n\r\n"
    }
  }, 
  {
    "pk": 93, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "**Opomba:** Tomo ne more preveriti pravilnosti va\u0161ih re\u0161itev, zato\r\nbo re\u0161itve vedno sprejel kot pravilne.", 
      "language": 2, 
      "title": "Simulirano ohlajanje", 
      "timestamp": "2012-01-12 14:15:23", 
      "author": 19, 
      "problem_set": 35, 
      "preamble": ""
    }
  }, 
  {
    "pk": 154, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Borzni problem", 
      "timestamp": "2012-04-16 12:56:48", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": "def _makefile0(ime):\n    with open(ime, \"w\") as f:\n        print(\"2,35,18,5,78\", file=f)\n        print(\"13,20\", file=f)\n        print(\"8\", file=f)\n        print(\"15,84,2,4,5,16,78,44,21\", file=f)\n        print(\"10,5,50,40\", file=f)\n\ndef _makefile1(ime):\n    with open(ime, \"w\") as f:\n        print(\"138\", file=f)\n        print(\"33\", file=f)\n        print(\"8\", file=f)\n        print(\"269\", file=f)\n        print(\"105\", file=f)\n\n\n\ndef _makefile2(ime):\n    with open(ime, \"w\") as f:                                                                                                                                                                     \n        print(\"28\", file=f)\n        print(\"16\", file=f)\n        print(\"8\", file=f)\n        print(\"30\", file=f)\n        print(\"26\", file=f)\n        print(\"22\", file=f)\n\ndef _istevseenodatoteke(ena,dva):\n    with open(ena) as f1, open(dva) as f2:\n        vrste1 = [l.strip() for l in f1.readlines()]\n        vrste1.sort()\n        vrste2 = [l.strip() for l in f2.readlines()]\n        vrste2.sort()\n        if vrste1 == vrste2:\n            return True\n        else:\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\n            print(vrste1)\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\n            print(vrste2)\n\ndef _istedatoteke(ena,dva):\n    with open(ena) as f1, open(dva) as f2:\n        vrste1 = f1.read().strip()\n        vrste2 = f2.read().strip()\n        if vrste1 == vrste2:\n            return True\n        else:\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\n            print(vrste1)\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\n            print(vrste2)\n    \ndef _removefiles(*ime):\n    import os\n    for i in ime: os.remove(i)"
    }
  }, 
  {
    "pk": 166, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Tukaj re\u0161ujete prvo nalogo.", 
      "language": 2, 
      "title": "Naloga1", 
      "timestamp": "2012-02-10 13:12:40", 
      "author": 86, 
      "problem_set": 59, 
      "preamble": "class Permutacija:\r\n    pass"
    }
  }, 
  {
    "pk": 170, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Seznami", 
      "timestamp": "2012-02-17 10:04:32", 
      "author": 1, 
      "problem_set": 60, 
      "preamble": ""
    }
  }, 
  {
    "pk": 173, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Naloge na Tomotu re\u0161ujete tako, da v datoteko vpi\u0161ete re\u0161itev in\r\npritisnete tipko `F5`. S tem se va\u0161 program nalo\u017ei v konzolo in za\u017eenejo\r\nse testi, ki preverijo pravilnost re\u0161itve.", 
      "language": 2, 
      "title": "Oddajanje re\u0161itev", 
      "timestamp": "2012-02-20 09:02:44", 
      "author": 1, 
      "problem_set": 61, 
      "preamble": ""
    }
  }, 
  {
    "pk": 83, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Izra\u010dunajmo dolo\u010deni integral funkcije $\\sin x$ na intervalu $[0, \\pi]$.\r\n\r\nNajprej nari\u0161imo graf, nato pa izberimo $1000$ naklju\u010dnih to\u010dk v\r\npravokotniku $[0, \\pi] \\times [0, 1]$.\r\nTocke pod grafom nari\u0161imo z zeleno, tiste izven grafa pa z modro barvo.\r\n\r\n    x <- runif(1000, 0, pi)\r\n    y <- runif(1000, 0, 1)\r\n\r\n    curve(sin, 0, pi)\r\n    pod.grafom <- y < sin(x)\r\n    points(x[pod.grafom], y[pod.grafom], col = \"green\")\r\n    points(x[!pod.grafom], y[!pod.grafom], col = \"blue\")\r\n\r\nRazmerje med plo\u0161\u010dino pod grafom in plo\u0161\u010dino pravokotnika, je pribli\u017eno\r\nenako razmerju med \u0161tevilom tock pod grafom ter \u0161tevilom vseh to\u010dk.\r\nPlo\u0161\u010dina pravokotnika je enaka pi \u00d7 1 = pi, in pribli\u017eek je:\r\n\r\n    # Ker se TRUE obna\u0161a kot 1, FALSE pa kot 0, lahko razmerje to\u010dk pod\r\n    # grafom dobimo kar iz povpre\u010dja.\r\n    razmerje.tock <- mean(pod.grafom)\r\n    ploscina <- pi * 1\r\n    razmerje.tock * ploscina\r\n    integrate(sin, 0, pi)", 
      "language": 1, 
      "title": "Dolo\u010deni integrali", 
      "timestamp": "2012-11-28 09:27:47", 
      "author": 1, 
      "problem_set": 30, 
      "preamble": ""
    }
  }, 
  {
    "pk": 217, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Namen te naloge je narisati Kochovo sne\u017einko. Ve\u010d o njej zveste na strani\n[Kochova sne\u017einka](http://sl.wikipedia.org/wiki/Kochova_sne%C5%BEinka\n\nModul za delo z \u017eelvo se imenuje `turtle`, uvozili pa ga bomo pod imenom\n`T` z ukazom `import turtle as T`, da ne bomo rabili vsaki\u010d pisati turtle.", 
      "language": 2, 
      "title": "Kochova sne\u017einka", 
      "timestamp": "2012-05-27 23:52:28", 
      "author": 162, 
      "problem_set": 68, 
      "preamble": "import turtle as T"
    }
  }, 
  {
    "pk": 124, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Nabori", 
      "timestamp": "2012-04-26 09:55:30", 
      "author": 1, 
      "problem_set": 47, 
      "preamble": ""
    }
  }, 
  {
    "pk": 75, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 1, 
      "title": "Risanje grafov", 
      "timestamp": "2011-12-12 21:33:26", 
      "author": 1, 
      "problem_set": 27, 
      "preamble": ""
    }
  }, 
  {
    "pk": 176, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "V Pythonu definiramo funkcijo takole:\r\n\r\n    def ime_funkcije(x,y,...,z):\r\n        ukaz\r\n        ukaz\r\n        ...\r\n        ukaz\r\n\r\nRezultat vrnemo z ukazom `return`.", 
      "language": 2, 
      "title": "Preproste funkcije", 
      "timestamp": "2012-03-05 09:19:00", 
      "author": 19, 
      "problem_set": 64, 
      "preamble": "import math"
    }
  }, 
  {
    "pk": 36, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Bisekcija z dvema tabelama", 
      "timestamp": "2012-10-18 11:14:20", 
      "author": 19, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 28, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "V Pythonu definiramo funkcijo takole:\n\n    def ime_funkcije(x,y,...,z):\n        ukaz\n        ukaz\n        ...\n        ukaz\n\nRezultat vrnemo z ukazom `return`.", 
      "language": 2, 
      "title": "Preproste funkcije", 
      "timestamp": "2012-11-05 16:40:33", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": "import math"
    }
  }, 
  {
    "pk": 21, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Osnovne vektorje pi\u0161emo kot `c(x1, x2, ...)`\r\n\r\n     c(1, 2, 3, 4, 5, 6, 7)\r\n\r\nV resnici je `c` ukaz, ki ve\u010d vektorjev stakne v enega, in zgornji zapis\r\npredstavlja le stikanje ve\u010d vektorjev dol\u017eine 1.\r\n\r\n     c(c(1, 2, 3), c(4, 5, 6))\r\n\r\nZa ustvarjanje novih vektorjev nam je na voljo veliko ukazov\r\n\r\n     1 : 10        # \u0161tevila od 1 do 10\r\n     10 : 1        # \u0161tevila od 10 do 1\r\n     seq(1, 10, 2) # \u0161tevila od 1 do 10 z razmakom 2\r\n     rep(5, 10)    # 10 kopij \u0161tevila 5\r\n\r\n\u010ce izpis vektorja sega \u010dez rob okna, nam \u0161tevilka v oglatih oklepajih na\r\nza\u010detku vsake vrstice pove trenutni indeks. Sedaj veste, kaj pomeni `[1]`.\r\n\r\n     1 : 100\r\n\r\nObi\u010dajne matemati\u010dne operacije brez sprememb delujejo tudi na vektorjih.\r\n\r\n     2 * (1 : 10)\r\n     3 + rep(5, 10)\r\n     1 : 5 + seq(50, 10, -10)\r\n     1 : 10 ^ 2\r\n     (-5 : 5) > 0\r\n\r\n\u010ce je en vektor kraj\u0161i od drugega, se cikli\u010dno dopolni do dalj\u0161e dol\u017eine.\r\nV primeru, ko dalj\u0161a dol\u017eina ni ve\u010dkratnik kraj\u0161e, dobimo opozorilo.\r\n\r\n     c(1, 2, 3, 4) + c(10, 20)\r\n     c(1, 2, 3, 4) + c(10, 20, 10, 20)\r\n     c(1, 2, 3, 4) + c(10, 20, 30)\r\n\r\nR pozna ogromno funkcij, ki delujejo na vektorjih. Kaj po\u010dnejo?\r\n\r\n     sum(1 : 36)\r\n     prod(1 : 10)\r\n     mean(c(4, 3, 2, 4, 3, 3, 5))", 
      "language": 1, 
      "title": "Osnovni gradniki vektorjev", 
      "timestamp": "2012-10-22 10:46:36", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 60, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Preiskovanje dreves", 
      "timestamp": "2012-11-22 12:11:41", 
      "author": 1, 
      "problem_set": 20, 
      "preamble": "class Drevo:\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        if args:\r\n            self.prazno = False\r\n            self.vsebina = args[0]\r\n            self.levo = kwargs.get('levo', Drevo())\r\n            self.desno = kwargs.get('desno', Drevo())\r\n        else:\r\n            self.prazno = True\r\n\r\n    def __repr__(self, zamik = ''):\r\n        if self.prazno:\r\n          return 'Drevo()'.format(zamik)\r\n        elif self.levo.prazno and self.desno.prazno:\r\n          return 'Drevo({1})'.format(zamik, self.vsebina)\r\n        else:\r\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\r\n            format(\r\n              zamik,\r\n              self.vsebina,\r\n              self.levo.__repr__(zamik + '             '),\r\n              self.desno.__repr__(zamik + '              ')\r\n            )\r\n\r\n    def __eq__(self, other):\r\n        return ((self.prazno and other.prazno) or\r\n                (not self.prazno and not other.prazno and\r\n                 self.vsebina == other.vsebina and\r\n                 self.levo == other.levo and\r\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 219, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Vrednost funkcije $\\sin(x)$ lahko izra\u010dunamo s pomo\u010djo Taylorjeve vrste\r\n$$\\sin(x) =\\sum_{i=0}^\\infty \\frac{(-1)^i x^{2i+1}}{(2i+1)!}=x-\\frac{x^3}{3!} + \\frac{x^5}{5!}-\\cdots$$\r\nVrsta seveda konvergira hitreje, \u010de je $|x|<1$, vendar konvergira za\r\nvse vrednosti $x$.", 
      "language": 2, 
      "title": "Sinus", 
      "timestamp": "2012-07-27 12:14:34", 
      "author": 1, 
      "problem_set": 70, 
      "preamble": "from math import pi"
    }
  }, 
  {
    "pk": 69, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "[Slovenska obve\u0161\u010devalno-varnostna agencija](http://sova.gov.si/)\nvas je najela, da sestavite filter, s katerim bodo pregledovali\nelektronsko po\u0161to nekaterih sumljivih oseb (seveda samo v skladu\ns svojimi pristojnostmi).", 
      "language": 2, 
      "title": "\u0160pijona\u017ea", 
      "timestamp": "2012-11-27 09:44:09", 
      "author": 1, 
      "problem_set": 24, 
      "preamble": "import re"
    }
  }, 
  {
    "pk": 89, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Semafor", 
      "timestamp": "2012-01-04 22:30:43", 
      "author": 19, 
      "problem_set": 33, 
      "preamble": ""
    }
  }, 
  {
    "pk": 310, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Tabele", 
      "timestamp": "2013-02-04 07:55:04", 
      "author": 1, 
      "problem_set": 92, 
      "preamble": ""
    }
  }, 
  {
    "pk": 87, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 1, 
      "title": "Povpre\u010dna velikost dru\u017eine", 
      "timestamp": "2013-01-09 08:16:06", 
      "author": 1, 
      "problem_set": 32, 
      "preamble": "# Najprej je treba naloziti paketa za delo z zemljevidi.\r\nlibrary(sp)\r\nlibrary(maptools)\r\n\r\n# Funkcija, ki podatke preuredi glede na vrstni red v zemljevidu\r\npreuredi <- function(podatki, zemljevid) {\r\n  return(podatki[order(rownames(podatki)), ][rank(zemljevid$OB_UIME), ])\r\n}"
    }
  }, 
  {
    "pk": 306, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Za vse podnaloge definirajmo polinom:\n$$p(x) = x^5 - 7 x^4 + 10 x^3 + 3 x^2 - 9 x + 2$$", 
      "language": 2, 
      "title": "Newtonova metoda", 
      "timestamp": "2013-01-18 13:22:52", 
      "author": 1, 
      "problem_set": 91, 
      "preamble": ""
    }
  }, 
  {
    "pk": 94, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Slovarji", 
      "timestamp": "2012-02-07 09:24:15", 
      "author": 1, 
      "problem_set": 36, 
      "preamble": ""
    }
  }, 
  {
    "pk": 223, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Permutacijo lahko v Pythonu predstavimo s seznamom ciklov. Tako seznam\r\n`[[2, 4, 5], [1, 3]]` predstavlja permutacijo, ki slika 1 v 3, 2 v 4,\r\n3 v 1, 4 v 5 in 5 v 2.", 
      "language": 2, 
      "title": "Permutacije", 
      "timestamp": "2012-07-06 11:31:46", 
      "author": 1, 
      "problem_set": 71, 
      "preamble": ""
    }
  }, 
  {
    "pk": 283, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Sklad", 
      "timestamp": "2012-11-29 09:38:36", 
      "author": 1, 
      "problem_set": 88, 
      "preamble": ""
    }
  }, 
  {
    "pk": 282, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "_Levenshteinova razdalja_ med dvema nizoma je definirana kot najmanj\u0161e\n\u0161tevilo sprememb, potrebnih da pretvorimo en niz v drugega, pri \u010demer so\ndovoljene spremembe: vstavljanje, brisanje, ali zamenjava enega znaka.", 
      "language": 2, 
      "title": "Levenshteinova razdalja", 
      "timestamp": "2012-11-27 08:16:01", 
      "author": 1, 
      "problem_set": 87, 
      "preamble": ""
    }
  }, 
  {
    "pk": 280, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "[Sudoku](http://sl.wikipedia.org/wiki/Sudoku) je igra za enega\nigralca, v kateri je treba s \u0161tevili od 1 do 9 zapolniti delno\nizpolnjeno tabelo dimenzije $9 \\times 9$ tako, da se v vsakem\nstolpcu, vrstici in podkvadratu dimezije $3 \\times 3$ vsako \u0161tevilo\npojavi natanko enkrat.\n\nSudoku predstavimo z dvodimenzionalno tabelo `t`, torej s tabelo tabel,\npri \u010demer je `t[i][j]` polje v `i`-ti vrstici in `j`-tem stolpcu.\nPrazna polja predstavimo z vrednostjo `None`.", 
      "language": 2, 
      "title": "Sudoku", 
      "timestamp": "2012-11-19 10:14:29", 
      "author": 86, 
      "problem_set": 86, 
      "preamble": ""
    }
  }, 
  {
    "pk": 302, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Najkraj\u0161e poti dane dol\u017eine", 
      "timestamp": "2013-01-07 12:47:06", 
      "author": 1, 
      "problem_set": 82, 
      "preamble": ""
    }
  }, 
  {
    "pk": 291, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 1, 
      "title": "Polinomi", 
      "timestamp": "2012-12-07 20:13:27", 
      "author": 1, 
      "problem_set": 89, 
      "preamble": ""
    }
  }, 
  {
    "pk": 309, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "_Pozor:_ naloge _niso_ opremljene s testi.\r\nZa re\u0161itev pravilnost morate poskrbeti sami.", 
      "language": 1, 
      "title": "Monte Carlo", 
      "timestamp": "2013-02-11 12:07:58", 
      "author": 1, 
      "problem_set": 17, 
      "preamble": ""
    }
  }, 
  {
    "pk": 4, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Razdalje med to\u010dkami", 
      "timestamp": "2011-12-01 11:58:15", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 66, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Izjeme", 
      "timestamp": "2011-12-04 07:11:07", 
      "author": 1, 
      "problem_set": 18, 
      "preamble": ""
    }
  }, 
  {
    "pk": 63, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "[Sudoku](http://sl.wikipedia.org/wiki/Sudoku) je igra za enega\r\nigralca, v kateri je treba s \u0161tevili od 1 do 9 zapolniti delno\r\nizpolnjeno tabelo dimenzije $9 \\times 9$ tako, da se v vsakem\r\nstolpcu, vrstici in podkvadratu dimezije $3 \\times 3$ vsako \u0161tevilo\r\npojavi natanko enkrat.\r\n\r\nSudoku predstavimo z dvodimenzionalno tabelo `t`, t.j. s tabelo tabel,\r\npri \u010demer je `t[i][j]` polje v `i`-ti vrstici in `j`-tem stolpcu.\r\nPrazna polja predstavimo z vrednostjo `None`.", 
      "language": 2, 
      "title": "Sudoku", 
      "timestamp": "2011-11-24 10:55:16", 
      "author": 86, 
      "problem_set": 21, 
      "preamble": ""
    }
  }, 
  {
    "pk": 99, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Osnovne operacije", 
      "timestamp": "2013-02-25 04:01:38", 
      "author": 1, 
      "problem_set": 39, 
      "preamble": "import random\nimport math\n\ndef izvedi(source, d):\n    import io, sys\n    old_stdout = sys.stdout\n    new_stdout = io.StringIO()\n    sys.stdout = new_stdout\n    exec(source, d)\n    sys.stdout = old_stdout\n    return (d, new_stdout.getvalue())\n\na=5\nb=4"
    }
  }, 
  {
    "pk": 249, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Skoraj linearna funkcija", 
      "timestamp": "2012-09-05 11:43:14", 
      "author": 1, 
      "problem_set": 77, 
      "preamble": ""
    }
  }, 
  {
    "pk": 183, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Najprej si bomo pogledali, kako lahko v Pythonu implementiramo\nlogi\u010dne operatorje, ki jih Python nima neposredno vklju\u010denih.", 
      "language": 2, 
      "title": "Osnovni logi\u010dni operatorji", 
      "timestamp": "2012-03-09 14:59:47", 
      "author": 162, 
      "problem_set": 66, 
      "preamble": ""
    }
  }, 
  {
    "pk": 106, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Krogi in trikotniki", 
      "timestamp": "2012-03-14 13:37:08", 
      "author": 1, 
      "problem_set": 41, 
      "preamble": ""
    }
  }, 
  {
    "pk": 254, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Na\u010deloma za predstavitev matrik v Pythonu uporabimo modul\n[array](http://docs.python.org/py3k/library/array.html),\na mi jih bomo predstavili kar s seznami seznamov.\n[Hilbertovo matriko](http://sl.wikipedia.org/wiki/Hilbertova_matrika)\nbi tako zapisali s seznamom `[[1, 1/2], [1/2, 1/3]]`.\n\nPredpostavite lahko, da imajo vse matrike vsaj en element in\nda imajo vsi podseznami enako dol\u017eino, ne smete pa predpostaviti,\nda so vse matrike kvadratne.", 
      "language": 2, 
      "title": "Matrike", 
      "timestamp": "2012-10-01 12:27:45", 
      "author": 19, 
      "problem_set": 78, 
      "preamble": "_mat = [[i ** 2 + 3 * j for i in range(8)] for j in range(8)]"
    }
  }, 
  {
    "pk": 162, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Nepopolna \u0161tevila", 
      "timestamp": "2012-06-04 08:46:52", 
      "author": 1, 
      "problem_set": 58, 
      "preamble": ""
    }
  }, 
  {
    "pk": 48, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Datumi", 
      "timestamp": "2012-10-24 13:30:17", 
      "author": 1, 
      "problem_set": 14, 
      "preamble": ""
    }
  }, 
  {
    "pk": 59, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "V tej nalogi je graf podan z mno\u017eico vozli\u0161\u010d, ki jih ozna\u010dimo kar s\n\u0161tevili $0, 1, 2, \\ldots, n-1$, in povezavami $e_0, \\ldots, e_{m-1}$\nmed vozli\u0161\u010di, pri \u010demer ima vsaka povezava *za\u010detek*, *konec* ter\n*dol\u017eino* ali *ceno*. Lahko si na primer predstavljamo, da so\nvozli\u0161\u010da mesta in povezave ceste med njimi. Ukvarjali se bomo z\nnalogo, kako poiskati ceno najkraj\u0161e poti med dvema vozli\u0161\u010dema v\ntakem grafu. Ve\u010d o nalogi si lahko preberete v \u010dlanku [Shortest path\nproblem](http://en.wikipedia.org/wiki/Shortest_path_problem).\n\nV Pythonu lahko predstavimo graf na ve\u010d na\u010dinov:\n\n1. **Matrika razdalj** $D = [d_{ij}]_{0 \\leq i,j < n}$ velikosti $n\n\\times n$, kjer je $d_{i,j} = \\infty$ cena povezave, ki vodi od\nvozli\u0161\u010da $i$ do vozli\u0161\u010da $j$. \u010ce take povezave ni, nastavimo\n$d_{i,j} = \\infty$, v Pythonu se $\\infty$ dobi s `float('inf')`. \u010ce\nje graf *simetri\u010den*, se pravi da povezave niso usmerjene, potem je\n$D$ simetri\u010dna matrika. Z matriko razdalj lahko predstavimo samo\n*enostavne* grafe, to so taki, pri katerih imam med dvema vozli\u0161\u010dema\nnajve\u010d eno povezavo.\n\n2. **Seznam sosedov** $[(i_1, j_1, d_1), \\ldots, (i_m, j_m, d_m)]$,\nkjer trojka $(i,j,d)$ pomeni, da od vozli\u0161\u010da $i$ do vozli\u0161\u010da $j$\nvodi povezava s ceno $d$.\n\n3. **Slovar sosedov**, ki vsako vozli\u0161\u010de $i$ preslika v seznam parov\n$[(j_1, d_1), \\ldots, (j_k, d_k)]$, pri \u010demer par $(j,d)$ pove, da\nod $i$ do $j$ vodi povezava s ceno $d$.\n\nZa namene te naloge definiramo konstanto `inf`, ki predstavlja neskon\u010dnost:\n\n    inf = float('inf')", 
      "language": 2, 
      "title": "Najkraj\u0161a pot v grafu", 
      "timestamp": "2011-11-23 14:55:23", 
      "author": 19, 
      "problem_set": 19, 
      "preamble": "inf = float('inf')"
    }
  }, 
  {
    "pk": 72, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Datumi", 
      "timestamp": "2012-12-14 14:57:42", 
      "author": 19, 
      "problem_set": 26, 
      "preamble": ""
    }
  }, 
  {
    "pk": 216, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Osnovna rekurzija", 
      "timestamp": "2012-05-21 12:50:45", 
      "author": 1, 
      "problem_set": 40, 
      "preamble": ""
    }
  }, 
  {
    "pk": 109, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Delne vsote vrst", 
      "timestamp": "2012-03-14 09:53:33", 
      "author": 1, 
      "problem_set": 42, 
      "preamble": ""
    }
  }, 
  {
    "pk": 25, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Najprej poglejte lekcijo [Urejanje z izbiranjem](http://vimeo.com/30661029).\r\nPozor, video vsebuje re\u0161itev naloge. \u010ce \u017eelite nalogo re\u0161iti samostojno,\r\nvideo prekinite takoj, ko razumete, kako deluje algoritem.\r\n\r\n_Pa \u0161e to_: re\u0161itev iz videa _ne_ deluje pravilno!", 
      "language": 2, 
      "title": "Urejanje z izbiranjem", 
      "timestamp": "2012-10-24 09:48:20", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 79, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Preiskovanje dreves", 
      "timestamp": "2011-12-15 11:24:06", 
      "author": 19, 
      "problem_set": 29, 
      "preamble": "class Drevo:\n\n    def __init__(self, *args, **kwargs):\n        if args:\n            self.prazno = False\n            self.vsebina = args[0]\n            self.levo = kwargs.get('levo', Drevo())\n            self.desno = kwargs.get('desno', Drevo())\n        else:\n            self.prazno = True\n\n    def __repr__(self, zamik = ''):\n        if self.prazno:\n          return 'Drevo()'.format(zamik)\n        elif self.levo.prazno and self.desno.prazno:\n          return 'Drevo({1})'.format(zamik, self.vsebina)\n        else:\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\n            format(\n              zamik,\n              self.vsebina,\n              self.levo.__repr__(zamik + '             '),\n              self.desno.__repr__(zamik + '              ')\n            )\n\n    def __eq__(self, other):\n        return ((self.prazno and other.prazno) or\n                (not self.prazno and not other.prazno and\n                 self.vsebina == other.vsebina and\n                 self.levo == other.levo and\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 275, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "\u010ce \u017eelite funkcijo `f` uporabiti na vseh komponentah vektorja `x`,\nuporabite ukaz `sapply(x, f)`. Na primer `sapply(1 : 20, fibonacci)`\nvrne vektor prvih dvajsetih Fibonaccijevih \u0161tevil.\n\nUkaz `mapply(f, x, y, ...)` deluje podobno, le da funkcija `f` lahko\nsprejme ve\u010d argumentov. Ukaz nato vrne rezultat vektor\n`f(x[1], y[1], ...)`, `f(x[2], y[2], ...)`, `f(x[3], y[3], ...)`, \u2026\nTako bi lahko s pomo\u010djo funkcije `gcd` paroma izra\u010dunali najve\u010dji skupni\ndelitelj komponent dveh vektorjev.\n\nNavadno funkcijo lahko spremenimo v vektorsko s funkcijo `Vectorize`.\n(To je funkcija vi\u0161jega reda, ki sprejme funkcijo in vrne funkcijo.)\n\n    vektorski.fibonacci <- Vectorize(fibonacci)\n    vektorski.fibonacci(1 : 100)\n    vektorski.gcd <- Vectorize(gcd)\n    vektorski.gcd(c(15, 40, 7, 16), c(20, 90, 15, 28))\n\nPi\u0161emo lahko tudi kar\n\n    fibonacci <- Vectorize(fibonacci) # sedaj fibonacci dela na vektorjih\n    fibonacci(1 : 100)", 
      "language": 1, 
      "title": "Uporaba \u017ee obstoje\u010dih funkcij", 
      "timestamp": "2012-11-11 21:32:14", 
      "author": 1, 
      "problem_set": 84, 
      "preamble": "prastevilo <- function(n) {\n  if(n == 1)\n    return(FALSE)\n  i <- 2\n  while(i * i <= n) {\n    if(n %% i == 0)\n      return(FALSE)\n    i <- i + 1\n  }\n  return(TRUE)\n}"
    }
  }, 
  {
    "pk": 205, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-03-27 08:51:36", 
      "author": 1, 
      "problem_set": 67, 
      "preamble": "_slovar = {'\u010c': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': '\u0160', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': '\u010c', 'V': 'N', 'Z': '\u017d', '\u0160': 'S', '\u017d': 'D'}\r\n_neslovar = {'\u010c': 'A', 'A': 'O', 'C': 'Z', 'B': 'N', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': '\u0160', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': '\u010c', 'V': 'N', 'Z': '\u017d', '\u0160': 'S', '\u017d': 'D'}\r\n_neslovar2 = {'X': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': 'W', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': 'X', 'V': 'N', 'Z': 'Y', 'W': 'S', 'Y': 'D'}\r\n\r\n\r\ndef _preveriinverz(a, b):\r\n    try:\r\n        for x in a:\r\n            if b[a[x]] != x:\r\n                return False\r\n        return True\r\n    except:\r\n        return False\r\n\r\ndef _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1\", file=f)\r\n        print(\"Ena A,0,1,3,2,6,2,0,5,6,3,2,1\", file=f)\r\n        print(\"Dober Clovek,3,0,1,2,0,1,5,4,3,7,8,1\", file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Janez Novak,18\", file=f)\r\n        print(\"Ena A,31\", file=f)\r\n        print(\"Dober Clovek,35\", file=f)\r\n\r\n\r\ndef _makefile3(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Ena A,0,1,3,2,6,2,0,5,6,3,2,1,31\", file=f)\r\n        print(\"Dober Clovek,3,0,1,2,0,1,5,4,3,7,8,1,35\", file=f)\r\n        print(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1,18\", file=f)\r\n        print(\"Povprecen Student,1.33,1.33,2.33,2.0,2.33,1.0,1.67,3.67,3.0,4.33,4.0,1.0,28.0\", file=f)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        return f1.read().strip() == f2.read().strip()\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)"
    }
  }, 
  {
    "pk": 204, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "V vsaki vrstici datoteke imamo shranjene rezultate kolokvija v obliki\r\n`Ime Priimek,N1,N2,N3,N4,N5`, kjer (cela \u0161tevila) od `N1` do `N5`\r\npredstavljajo to\u010dke za posamezno nalogo, npr: `Janez Novak,1,3,3,0,2`.", 
      "language": 2, 
      "title": "Kolokviji", 
      "timestamp": "2012-05-16 15:11:48", 
      "author": 1, 
      "problem_set": 49, 
      "preamble": ""
    }
  }, 
  {
    "pk": 245, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Skoraj linearna funkcija", 
      "timestamp": "2012-09-05 09:34:47", 
      "author": 1, 
      "problem_set": 76, 
      "preamble": ""
    }
  }, 
  {
    "pk": 117, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Obra\u010danje seznamov", 
      "timestamp": "2012-03-27 09:47:28", 
      "author": 1, 
      "problem_set": 44, 
      "preamble": ""
    }
  }, 
  {
    "pk": 115, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Oklepaji so pravilno gnezdeni, \u010de oklepaji in zaklepaji nastopajo v\nparih in \u0161tevilo zaklepajev nikoli ne prese\u017ee \u0161tevila oklepajev, ko\njih \u0161tejemo od leve proti desni.", 
      "language": 2, 
      "title": "Gnezdenje oklepajev", 
      "timestamp": "2012-03-22 11:22:52", 
      "author": 1, 
      "problem_set": 43, 
      "preamble": ""
    }
  }, 
  {
    "pk": 46, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Za vajo si bomo ogledali razporeditev `HairEyeColor`.\r\nV pomo\u010di si oglejte, kaj je shranjeno v njej.", 
      "language": 1, 
      "title": "HairEyeColor", 
      "timestamp": "2012-11-05 10:53:44", 
      "author": 1, 
      "problem_set": 13, 
      "preamble": ""
    }
  }, 
  {
    "pk": 64, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Z ukazom `runif(n, min = 0, max = 1)` ustvarimo vektor `n` realnih \u0161tevil med\r\n`min` in `max`, izbranih glede na enakomerno porazdelitev.\r\n\r\n    runif(10) # 10 naklju\u010dnih realnih \u0161tevil med 0 in 1\r\n    runif(30, -2, 2) # 30 naklju\u010dnih realnih \u0161tevil med -2 in 2\r\n    z <- runif(10000, -1, 1) # 10000 \u0161tevil med -1 in 1\r\n    hist(z) # pripadajo\u010di histogram\r\n\r\nZ ukazom `rnorm(n, mean = 0, sd = 1)` ustvarimo vektor `n` realnih \u0161tevil,\r\nizbranih glede na normalno porazdelitev (\"po Gaussu\") z matemati\u010dnim\r\nupanjem `mean` in standardnim odklonom `sd`.\r\n\r\n    z <- rnorm(10000) # 10000 \u0161tevil po standardni normalni razporeditvi\r\n    hist(z)\r\n\r\nZ ukazom `sample(x, n, replace = FALSE, prob = NULL)` ustvarimo\r\nvektor `n` naklju\u010dno izbranih elementov vektorja x.\r\n\r\n* \u010de je `x` eno samo \u0161tevilo, se izbira dela na vektorju `1 : x`;\r\n* \u010de \u0161tevila `n` ne podamo, se za `n` vzame kar velikost vektorja `x`, torej\r\ndobimo njegovo permutacijo;\r\n* s parametrom `replace = TRUE` izbiramo z vra\u010danjem (\u010de je `n` ve\u010dji od\r\ndol\u017eine vektorja `x` je ta izbira obvezna);\r\n* s parametrom `prob` lahko nastavimo vektor ute\u017ei izbire pripadajo\u010dih\r\nkomponent.\r\n\r\nPrimeri:\r\n\r\n    sample(1 : 39, 7) # naklju\u010dna kombinacija pri lotu\r\n    sample(39, 7) # pisali bi lahko tudi tako\r\n    sample(5) # naklju\u010dna permutacija \u0161tevil od 1 do 5\r\n    sample(5, 10, replace = TRUE) # izmed \u0161tevil od 1 do 5 izberemo 10 \u0161tevil\r\n    sample(5, 10) # \u010de izbiramo brez ponavljanja, dobimo napako\r\n    z <- sample(6, 600, replace = TRUE) # 600 metov kocke\r\n    tabulate(z) # \u0161tevila ponovitev\r\n    z <- sample(6, 600, replace = TRUE, prob = c(3, 2, 2, 2, 2, 1))\r\n    tabulate(z) # \u0161tevila ponovitev pri ute\u017eeni kocki", 
      "language": 1, 
      "title": "Naklju\u010dni vektorji", 
      "timestamp": "2012-11-14 08:50:17", 
      "author": 1, 
      "problem_set": 22, 
      "preamble": ""
    }
  }, 
  {
    "pk": 227, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Eksponentna funkcija je definirana z vrsto\r\n$$e^x = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!}+\\cdots$$\r\nVrsta konvergira za vsak $x$, seveda pa konvergira hitreje, \u010de je\r\n$|x|<1$.", 
      "language": 2, 
      "title": "Eksponentna funkcija", 
      "timestamp": "2012-07-27 12:14:27", 
      "author": 1, 
      "problem_set": 69, 
      "preamble": ""
    }
  }, 
  {
    "pk": 242, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Postaje", 
      "timestamp": "2012-08-27 09:32:37", 
      "author": 1, 
      "problem_set": 75, 
      "preamble": ""
    }
  }, 
  {
    "pk": 232, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Pove\u010dini soda \u0161tevila", 
      "timestamp": "2012-07-11 11:25:16", 
      "author": 1, 
      "problem_set": 72, 
      "preamble": ""
    }
  }, 
  {
    "pk": 16, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Funkcije definiramo z\n\n    ime.funkcije <- function(argumenti) {\n      definicija\n    }\n\nNa\u010deloma je vrednost funkcije enaka vrednosti zadnjega izraza v njeni\ndefiniciji. \u010ce pa \u017eelimo, pa lahko rezultat funkcije vrnemo z ukazom\n`return(rezultat)`. Ukaz `return` vrne rezultat ter kon\u010da izvajanje\nfunkcije.\n\nNa primer, kvadratno funkcijo bi definirali kot\n\n    kvadrat <- function(x) {\n      x ^ 2\n    }\n\nlahko pa tudi kot\n\n    kvadrat <- function(x) {\n      return(x ^ 2)\n    }\n\nFunkcije lahko sprejmejo tudi ve\u010d argumentov, na primer:\n\n    povprecje <- function(x, y) {\n      (x + y) / 2\n    }\n\nTako kot v Pythonu so nekateri argumenti lahko tudi neobvezni.\nDolo\u010dimo jih s tem, da jim pripi\u0161emo privzeto vrednost, na primer:\n\n    eksponentna <- function(x, baza = exp(1)) {\n      baza ^ x\n    }\n\nTake funkcije lahko kli\u010demo:\n\n1. kot obi\u010dajno: `eksponentna(3, 2)` vrne `8`;\n2. brez neobveznih argumentov: `eksponentna(3)` vrne `20.08554`;\n3. s poimenovanimi argumenti: `eksponentna(2, baza = 3)` vrne `9`.", 
      "language": 1, 
      "title": "Funkcije", 
      "timestamp": "2012-10-22 10:27:37", 
      "author": 1, 
      "problem_set": 4, 
      "preamble": ""
    }
  }, 
  {
    "pk": 132, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 2", 
      "timestamp": "2012-05-12 23:21:53", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def rnds(S):\r\n    if abs(sum(S) -1) > 0.0001:\r\n        raise ValueError('Vsota verjetnosti ni 1!!!')\r\n    y=random.random()\r\n    F=0\r\n    for i in range(len(S)+1):\r\n        if F >= y:\r\n            break\r\n        F+=S[i]\r\n    return i-1 if i > 0 else 0\r\n\r\ndef rndd(S):\r\n    if abs(sum(S.values()) -1) > 0.0001:\r\n        raise ValueError('Vsota verjetnosti ni 1!!!')\r\n    y=random.random()\r\n    F=0\r\n    for x in S:\r\n        F+=S[x]\r\n        if F >= y:\r\n            break\r\n    return x"
    }
  }, 
  {
    "pk": 127, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 1", 
      "timestamp": "2012-05-04 09:30:39", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "import random\r\nfrom time import clock\r\nimport inspect\r\n\r\nkarte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0161kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n\r\ndef unija(s):\r\n    x=set()\r\n    for i in s:\r\n        x=x.union(i)\r\n    return x\r\n\r\ndef jeenakomerna(f,a,b):\r\n    '''Preveri, da f vraca enakomerno porazdeljene vrednosti na intervalu [a,b)'''\r\n    s=[f(a,b) for i in range(1000)]\r\n    M=sum(s)/1000\r\n    V=sum([(x-M)**2/1000 for x in s])\r\n    # Povprecje enakomerno porazdeljene spr. je (a+b)/2, varianca je (b-a)^2/12\r\n    if abs((M-(a+b)/2))>0.1 or abs(V-(b-a)**2/12)>0.2:\r\n        return False\r\n    else:\r\n        return True\r\n\r\ndef nakljucna(f,*args):\r\n    random.seed(1)\r\n    return [f(*args) for i in range(10)]\r\n\r\ndef izpis(f,*args):\r\n    import io, sys\r\n    old_stdout = sys.stdout\r\n    new_stdout = io.StringIO()\r\n    random.seed(1)\r\n    sys.stdout = new_stdout\r\n    f(*args)\r\n    sys.stdout = old_stdout\r\n    return new_stdout.getvalue()"
    }
  }, 
  {
    "pk": 234, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Naravni logaritem lahko izra\u010dunamo s pomo\u010djo naslednje vrste\r\n$$\r\n\\ln(1+x) = x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+...,\r\n$$\r\nki pa \u017eal konvergira samo za $|x|<1$.", 
      "language": 2, 
      "title": "Logaritmi", 
      "timestamp": "2012-07-27 12:13:52", 
      "author": 162, 
      "problem_set": 73, 
      "preamble": "ln10=2.302585092994046"
    }
  }, 
  {
    "pk": 76, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Izjeme", 
      "timestamp": "2011-12-15 10:13:48", 
      "author": 19, 
      "problem_set": 28, 
      "preamble": ""
    }
  }, 
  {
    "pk": 53, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Pri re\u0161evanju naloge si pomagajte z video lekcijami:\n\n* [RA\u010cFIZ-2011-11-10-06 Par najbli\u017ejih to\u010dk](http://vimeo.com/32434672) \n* [RA\u010cFIZ-2011-11-10-07 Par najbli\u017ejih to\u010dk, faza deli](http://vimeo.com/32434810)\n* [RA\u010cFIZ-2011-11-10-08 Par najbli\u017ejih to\u010dk, faza vladaj](http://vimeo.com/32435158)\n* [RA\u010cFIZ-2011-11-10-09 Par najbli\u017ejih to\u010dk, \u010dasovna zahtevnost](http://vimeo.com/32435263)\n* [RA\u010cFIZ-2011-11-10-10 Par najbli\u017ejih to\u010dk, izbolj\u0161ava](http://vimeo.com/32435495)\n\nDane imamo to\u010dke $t_1 = (x_1, y_1), \\ldots, t_n = (x_n, y_n)$ v ravnini.\nPoiskati \u017eelimo dve to\u010dki $t_i$ in $t_j$, da bo razdalja med njima minimalna.\nTo lahko re\u0161imo z metodo deli in vladaj, glej\n[opis na Wikipediji](http://en.wikipedia.org/wiki/Closest_pair_of_points_problem).\n\nV nadaljevanju naloge privzemimo, da so to\u010dke $t_1, \\ldots, t_n$ shranjene\nv tabeli `t` kot pari koordinat `(x_i, y_i)`.", 
      "language": 2, 
      "title": "Najbli\u017eji to\u010dki v ravnini", 
      "timestamp": "2012-12-10 17:07:53", 
      "author": 19, 
      "problem_set": 16, 
      "preamble": ""
    }
  }, 
  {
    "pk": 238, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "Vrsta\r\n$$\r\n\\frac{2}{1\\cdot 3} + \\frac{2}{2\\cdot 4} + \\frac{2}{3\\cdot 5}\r\n                   + \\frac{2}{4\\cdot 6} + \\cdots\r\n$$\r\nkonvergira, ima pa \u0161e to lepo lastnost, da lahko njeno vsoto zelo\r\nenostavno izra\u010dunamo.", 
      "language": 2, 
      "title": "Konvergenca vrste", 
      "timestamp": "2012-07-27 12:13:55", 
      "author": 162, 
      "problem_set": 74, 
      "preamble": ""
    }
  }, 
  {
    "pk": 296, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Matrike", 
      "timestamp": "2012-12-10 13:34:46", 
      "author": 1, 
      "problem_set": 83, 
      "preamble": ""
    }
  }, 
  {
    "pk": 224, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Pri var\u010devanju na obroke na za\u010detku vpla\u010damo nek znesek, nato pa vsak\r\nmesec dopla\u010dujemo mese\u010dne obroke. Zaradi enostavnosti predpostavimo, da\r\nso vpla\u010dila vedno prvi dan v mesecu, vrednost var\u010devalnega ra\u010duna pa se\r\nvedno ra\u010duna ob koncu meseca. Denar, ki ga imamo na var\u010devalnem ra\u010dunu,\r\nse obrestuje po fiksni obrestni meri.", 
      "language": 2, 
      "title": "Var\u010devanje na obroke", 
      "timestamp": "2012-06-09 22:21:06", 
      "author": 1, 
      "problem_set": 71, 
      "preamble": ""
    }
  }, 
  {
    "pk": 228, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Vsak niz je sestavljen iz znakov, ki jim lahko priredimo \u0161tevila na razli\u010dne na\u010dine.\r\nNapisana je funkcija `prirediStevilo(c)`, ki znaku `c` priredi polo\u017eaj \u010drke\r\n`c` v slovenski abecedi, oz. 0, \u010de ta znak ni \u010drka slovenske abecede.", 
      "language": 2, 
      "title": "Numerologija", 
      "timestamp": "2012-07-27 12:14:27", 
      "author": 1, 
      "problem_set": 69, 
      "preamble": "def prirediStevilo(c):\r\n    \"\"\"\u010de je c znak na\u0161e abecede, funkcija vrne polo\u017eaj znaka c v na\u0161i abecedi, sicer vrne 0\"\"\"\r\n    c = c.upper()    \r\n    return 1+\"ABC\u010cDEFGHIJKLMNOPRS\u0160TUVZ\u017d\".find(c)"
    }
  }, 
  {
    "pk": 294, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Iskalna drevesa", 
      "timestamp": "2012-12-10 13:29:25", 
      "author": 1, 
      "problem_set": 83, 
      "preamble": "class IskalnoDrevo:\n    def __init__(self, vrednosti=[]):\n        self.prazno = True\n        for x in vrednosti:\n            self.vstavi(x)\n\n    def __repr__(self):\n        if self.prazno:\n            return \"IskalnoDrevo()\"\n        else:\n            opis = str(self.vsebina)\n            if not self.levo.prazno: opis += \", levo={0}\".format(self.levo)\n            if not self.desno.prazno: opis += \", desno={0}\".format(self.desno)\n            return \"IskalnoDrevo({0})\".format(opis)\n\n    def vstavi(self, x):\n        if self.prazno:\n            self.prazno = False\n            self.vsebina = x\n            self.levo = IskalnoDrevo()\n            self.desno = IskalnoDrevo()\n        elif x < self.vsebina:\n            self.levo.vstavi(x)\n        else:\n            self.desno.vstavi(x)"
    }
  }, 
  {
    "pk": 128, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 2", 
      "timestamp": "2012-05-04 09:30:43", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "import random\r\nfrom time import clock\r\nimport inspect\r\n\r\nkarte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0161kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n\r\ndef unija(s):\r\n    x=set()\r\n    for i in s:\r\n        x=x.union(i)\r\n    return x\r\n\r\ndef jeenakomerna(f,a,b):\r\n    '''Preveri, da f vraca enakomerno porazdeljene vrednosti na intervalu [a,b)'''\r\n    s=[f(a,b) for i in range(1000)]\r\n    M=sum(s)/1000\r\n    V=sum([(x-M)**2/1000 for x in s])\r\n    # Povprecje enakomerno porazdeljene spr. je (a+b)/2, varianca je (b-a)^2/12\r\n    if abs((M-(a+b)/2))>0.1 or abs(V-(b-a)**2/12)>0.2:\r\n        return False\r\n    else:\r\n        return True\r\n\r\ndef nakljucna(f,*args):\r\n    random.seed(1)\r\n    return [f(*args) for i in range(10)]\r\n\r\ndef izpis(f,*args):\r\n    import io, sys\r\n    old_stdout = sys.stdout\r\n    new_stdout = io.StringIO()\r\n    random.seed(1)\r\n    sys.stdout = new_stdout\r\n    f(*args)\r\n    sys.stdout = old_stdout\r\n    return new_stdout.getvalue()"
    }
  }, 
  {
    "pk": 209, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-03-27 08:53:13", 
      "author": 1, 
      "problem_set": 67, 
      "preamble": "def _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Luka,Jaka\", file=f)\r\n        print(\"Luka\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Miha 3\", file=f)\r\n        print(\"Luka 2\", file=f)\r\n        print(\"Jaka 1\", file=f)\r\n\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n"
    }
  }, 
  {
    "pk": 293, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Premike pri [Monopoliju](http://en.wikipedia.org/wiki/Monopoly_(game))\r\nlahko simuliramo z matriko $P$ velikosti 41 \u00d7 41, v kateri komponenta\r\n$p_{ij}$ ustreza verjetnosti, da se v naslednji potezi premaknemo\r\nz $i$. na $j$. polje. Polj je v resnici 41, saj sta spodaj levo dve\r\npolji:\r\n\r\n* je\u010da, kamor figurica pride po posebnih pravilih in iz katere mora\r\n  tudi pobegniti ter\r\n* obisk je\u010de, kamor figurica pride z obi\u010dajnimi pravili z enega\r\n  od prej\u0161njih polj in s katerega v naslednji potezi tudi odide.\r\n\r\n![igralna plo\u0161\u010da](http://imgur.com/IMOyMl.jpg)\r\n\r\nNamen te doma\u010de naloge bo izra\u010dunati matriko $P$, saj lahko iz te\r\nmatrike ugotovimo, katera polja so najbolj obiskana in se jih zato\r\nspla\u010da lastiti.", 
      "language": 1, 
      "title": "Monopoli", 
      "timestamp": "2013-01-16 11:35:47", 
      "author": 1, 
      "problem_set": 17, 
      "preamble": "imena.polj <- c(\r\n  \"Go\", \"Mediterranean Avenue\", \"Community Chest\", \"Baltic Avenue\",\r\n  \"Income Tax\", \"Reading Railroad\", \"Oriental Avenue\", \"Chance\",\r\n  \"Vermont Avenue\", \"Connecticut Avenue\", \"Visiting Jail\",\r\n  \"St. Charles Place\", \"Electric Company\", \"States Avenue\",\r\n  \"Virginia Avenue\", \"Pennsylvania Railroad\", \"St. James Place\",\r\n  \"Community Chest\", \"Tennessee Avenue\", \"New York Avenue\", \"Free Parking\",\r\n  \"Kentucky Avenue\", \"Chance\", \"Indiana Avenue\", \"Illinois Avenue\",\r\n  \"B & O Railroad\", \"Atlantic Avenue\", \"Ventnor Avenue\", \"Water Works\",\r\n  \"Marvin Gardens\", \"Go To Jail\", \"Pacific Avenue\", \"North Carolina Avenue\",\r\n  \"Community Chest\", \"Pennsylvania Avenue\", \"Short Line\", \"Chance\",\r\n  \"Park Place\", \"Luxury Tax\", \"Boardwalk\",\r\n  \"In Jail\"\r\n)"
    }
  }, 
  {
    "pk": 80, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Spreminjanje dreves", 
      "timestamp": "2011-12-15 11:26:26", 
      "author": 19, 
      "problem_set": 29, 
      "preamble": "class Drevo:\n\n    def __init__(self, *args, **kwargs):\n        if args:\n            self.prazno = False\n            self.vsebina = args[0]\n            self.levo = kwargs.get('levo', Drevo())\n            self.desno = kwargs.get('desno', Drevo())\n        else:\n            self.prazno = True\n\n    def __repr__(self, zamik = ''):\n        if self.prazno:\n          return 'Drevo()'.format(zamik)\n        elif self.levo.prazno and self.desno.prazno:\n          return 'Drevo({1})'.format(zamik, self.vsebina)\n        else:\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\n            format(\n              zamik,\n              self.vsebina,\n              self.levo.__repr__(zamik + '             '),\n              self.desno.__repr__(zamik + '              ')\n            )\n\n    def __eq__(self, other):\n        return ((self.prazno and other.prazno) or\n                (not self.prazno and not other.prazno and\n                 self.vsebina == other.vsebina and\n                 self.levo == other.levo and\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 235, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Statisti\u010dna analiza", 
      "timestamp": "2012-07-27 12:13:52", 
      "author": 162, 
      "problem_set": 73, 
      "preamble": "import math\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)"
    }
  }, 
  {
    "pk": 17, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Krmilni stavki v R-ju se obna\u0161ajo podobno kot v Pythonu.\r\nPogojni stavek napi\u0161emo kot:\r\n\r\n    if(pogoj) {\r\n      ukazi, ki se izvedejo, \u010de pogoj dr\u017ei\r\n    } else {\r\n      ukazi, ki se izvedejo, \u010de pogoj ne dr\u017ei\r\n    }\r\n\r\nZanka `while` prav tako deluje podobno kot v Pythonu:\r\n\r\n    while(pogoj) {\r\n      ukazi, ki se izvajajo, dokler pogoj dr\u017ei\r\n    }\r\n\r\nPoleg zanke `while` R pozna tudi zanko `repeat`, ki se obna\u0161a tako kot\r\nzanka `while`, v kateri je pogoj vedno enak `TRUE`.\r\n\u010ce \u017eelimo zaustaviti izvajanje zanke `repeat`, uporabimo ukaz `break`,\r\nki se obna\u0161a tako kot v Pythonu, ali pa ukaz `return`.\r\n\u010ce \u017eelimo sko\u010diti na naslednji korak trenutne zanke, pa uporabimo\r\nukaz `next`, ki se obna\u0161a tako kot `continue` v Pythonu.\r\n\r\n    prastevilo <- function(n) {\r\n      i <- 2\r\n      while(i < n) {\r\n        if(n %% i == 0)\r\n          return(FALSE)\r\n        i <- i + 1\r\n      }\r\n      return(TRUE)\r\n    }", 
      "language": 1, 
      "title": "Krmilni stavki", 
      "timestamp": "2012-10-22 10:22:31", 
      "author": 1, 
      "problem_set": 4, 
      "preamble": ""
    }
  }, 
  {
    "pk": 102, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Fibonaccijevo zaporedje", 
      "timestamp": "2012-05-21 13:03:48", 
      "author": 1, 
      "problem_set": 40, 
      "preamble": ""
    }
  }, 
  {
    "pk": 22, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Do komponent vektorjev dostopamo z indeksi tako, da v oglatih\r\noklepajih za vektorjem lahko na\u0161tejemo vektor \u017eelenih indeksov.\r\n\r\n    x <- 20 : 30\r\n    x[c(1, 2, 7)] # 1., 2. in 7. element\r\n    x[c(1, 2, 7, 5, 1)] # 1., 2., 7., 5. in 1. element\r\n    \r\nFunkcija `order` vrne vektor mest, na katera spadajo posamezne\r\nkomponente v vektorju, urejenem po velikosti. Po korakih izvedite\r\nspodnje tri ukaze. Kaj je rezultat zadnjega?\r\n\r\n    y <- c(3, 7, 1, 5, 9)\r\n    order(y)\r\n    y[order(y)]\r\n    \r\n\u010ce so indeksi negativni, na\u0161tejemo ne\u017eelene elemente.\r\n\r\n    x[c(-1, -2, -7)] # Vsi elementi razen 1., 2. in 7. elementa\r\n    \r\n\u010ce podamo vektor logi\u010dnih vrednosti, se izberejo tisti elementi, kjer je\r\npripadajo\u010da vrednost enaka `TRUE`.\r\n\r\n    x[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE)]\r\n    \r\nNamen logi\u010dnih vektorjev v indeksih je izbor elementov, ki zado\u0161\u010dajo\r\ndanemu pogoju.\r\n\r\n    x %% 3 # vektor ostankov pri deljenju s 3 \r\n    x %% 3 == 0 # vektor, ki je TRUE tam, kjer je ostanek pri deljenju s 3 enak 0\r\n    x[x %% 3 == 0] # \u0161tevila, ki so deljiva s 3\r\n    x[x %% 5 == 1] # \u0161tevila, ki dajo pri deljenju s 5 ostanek 1\r\n    x[x %% 3 == 0 | x %% 5 == 1] # \u0161tevila, ki zado\u0161\u010dajo vsaj enemu pogoju", 
      "language": 1, 
      "title": "Indeksi", 
      "timestamp": "2012-11-07 12:55:12", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 73, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Definirajte razred `Ulomek`, s katerim predstavimo ulomek. \u0160tevec in\nimenovalec sta celi \u0161tevili, pri \u010demer je morebiten negativen\npredznak vedno v \u0161tevcu. Ulomki naj bodo vedno okraj\u0161ani.", 
      "language": 2, 
      "title": "Ulomki", 
      "timestamp": "2011-12-08 11:54:46", 
      "author": 19, 
      "problem_set": 26, 
      "preamble": ""
    }
  }, 
  {
    "pk": 182, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Goldberg-Tarjanov algoritem", 
      "timestamp": "2012-03-09 11:57:32", 
      "author": 1, 
      "problem_set": 63, 
      "preamble": "class Omrezje:\n\n    def __init__(self):\n        self.povezave = {}\n        self.tok = {}\n\n    def __repr__(self):\n        return \"\\n\".join(['{0}: {1} -{2}--{3}- {4}'.format(i, p[0], p[1], p[2], p[3]) for i, p in self.tok.items()])\n\n    def dodajTocko(self, tocka):\n        self.povezave[tocka] = set()\n\n    def dodajPovezavo(self, povezava, zacetek, konec, kapaciteta):\n        self.tok[povezava] = ((zacetek, kapaciteta, 0, konec))\n        self.povezave[zacetek].add(povezava)\n        self.povezave[konec].add(povezava)\n\nprimer = Omrezje()\nfor i in [1, 2, 3, 4, 5, 6]:\n    primer.dodajTocko(i)\nfor i, (z, k, kap) in enumerate([(1, 2, 6), (2, 3, 3), (3, 4, 10), (1, 5, 4), (5, 6, 2), (6, 4, 1), (2, 6, 5), (5, 3, 1)]):\n    primer.dodajPovezavo(i, z, k, kap)"
    }
  }, 
  {
    "pk": 239, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Skladi\u0161\u010de", 
      "timestamp": "2012-07-27 12:13:55", 
      "author": 162, 
      "problem_set": 74, 
      "preamble": "def _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)"
    }
  }, 
  {
    "pk": 90, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Prostoro\u010dno risanje", 
      "timestamp": "2012-01-04 22:34:16", 
      "author": 19, 
      "problem_set": 33, 
      "preamble": ""
    }
  }, 
  {
    "pk": 70, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Latov\u0161\u010dina je jezik, ki je zelo podoben sloven\u0161\u010dini. Razlika je\r\nsamo v tem, da pri latov\u0161\u010dini vsakemu samoglasniku sledi \u010drka p\r\nin \u0161e enkrat isti samoglasnik.", 
      "language": 2, 
      "title": "Latov\u0161\u010dina", 
      "timestamp": "2011-12-04 08:27:29", 
      "author": 1, 
      "problem_set": 24, 
      "preamble": "import re"
    }
  }, 
  {
    "pk": 88, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Zgornji postopek ponovite na kak\u0161ni drugi tabeli (lahko tudi na ve\u010d\r\ntabelah hkrati). Nekaj idej:\r\n\r\n- \u0161tevilo rojstev na 1000 prebivalcev\r\n- povpre\u010dna starost v ob\u010dini\r\n- dele\u017e \u0161tudentov\r\n- dele\u017e tujcev\r\n- \u2026\r\n\r\nPazite, da boste izbrali podatke iz zadnjih let, saj se \u0161tevilo\r\nob\u010din v Sloveniji spreminja. \u010ce vas zanimajo starej\u0161i podatki,\r\nlahko na spletni u\u010dilnici najdete zemljevid s 193 ob\u010dinami.\r\n\r\nV primeru, da nekaterih podatkov ni, bo v CSV datoteki vnos prazen ali\r\npa bo namesto \u0161tevilke znak `-`. V tem primeru bo R celoten stolpec\r\npretvoril v nize. \u0160tevila dobite nazaj z ukazom `as.numeric`.\r\nPretvorba lahko javi opozorila, saj se manjajo\u010dih vnosov ne bo dalo\r\npretvoriti v \u0161tevilo. V tem primeru bo `R` vnos pretvoril v `NA`,\r\nkar je primerna predstavitev manjkajo\u010dega podatka.", 
      "language": 1, 
      "title": "Va\u0161 izbor", 
      "timestamp": "2012-01-02 21:50:27", 
      "author": 1, 
      "problem_set": 32, 
      "preamble": ""
    }
  }, 
  {
    "pk": 220, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Naj bo $A$ matriko velikosti $n \\times n$ z elementi $a_{ij}$.\r\n_Permanento_ $\\|A\\|$ matrike $A$ definiramo podobno kot determinanto,\r\nle da pri ra\u010dunanju determinante izmenjujemo predznake poddeterminant,\r\npri permanenti pa povsod vzamemo pozitiven predznak. Na primer, \u010de\r\n$$\r\n  \\begin{Vmatrix} 9 & 8 & 7 \\\\ 6 & 5 & 4 \\\\ 3 & 2 & 1 \\end{Vmatrix} =\r\n  9 \\cdot \\begin{Vmatrix} 5 & 4 \\\\ 2 & 1 \\end{Vmatrix} +\r\n  8 \\cdot \\begin{Vmatrix} 6 & 4 \\\\ 3 & 1 \\end{Vmatrix} +\r\n  7 \\cdot \\begin{Vmatrix} 6 & 5 \\\\ 3 & 2 \\end{Vmatrix} =\r\n  9 \\cdot (5 \\cdot 1 + 4 \\cdot 2) +\r\n  8 \\cdot (6 \\cdot 1 + 4 \\cdot 3) +\r\n  7 \\cdot (6 \\cdot 2 + 5 \\cdot 3) = 450\r\n$$", 
      "language": 2, 
      "title": "Permanenta", 
      "timestamp": "2012-07-27 12:14:34", 
      "author": 1, 
      "problem_set": 70, 
      "preamble": "# funkcija kopiraj(mat) ustvari novo kopijo matrike mat\r\ndef kopiraj(mat):\r\n    return [vrstica[:] for vrstica in mat]"
    }
  }, 
  {
    "pk": 54, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Vsi elementi vektorjev v R-ju morajo biti istega tipa. \u010ce pa \u017eelimo\r\nsestaviti ve\u010d podatkov razli\u010dnih tipov, napi\u0161emo seznam, na primer:\r\n\r\n    list(1, 2, \"abc\")\r\n    c(1, 2, \"abc\") # \u010de napi\u0161emo vektor, se elementi pretvorijo na skupen tip\r\n\r\n\u010ce \u017eelimo, lahko nekatere komponente seznama tudi poimenujemo:\r\n\r\n    list(a = 1, b = 2, c = \"abc\")\r\n\r\nDo elementov dostopamo z ukazom `x[[i]]`, kjer je `i` indeks elementa.\r\n\u010ce je nek element poimenovan z nizom `\"ime\"`, lahko do njega dostopamo z\r\nukazom `x[[\"ime\"]]` ali pa kar z ukazom `x$ime`.\r\nPodobno lahko elemente seznamov spreminjamo z ukazoma `x[[i]] <- v` ali\r\n`x$ime <- v`.\r\n\r\n    x <- list(a = 1, b = 2, c = \"abc\")\r\n    x[[3]]\r\n    x[[\"c\"]]\r\n    x$c\r\n    x$c <- \"juhuhu\"\r\n    x\r\n\r\nPozor: `x[[i]]` ni enako kot `x[i]`. V prvem primeru dobimo `i`-ti element, v\r\ndrugem pa podseznam, ki vsebuje `i`-ti element.\r\n\r\nLinearni problem v standardni obliki\r\n$$\\begin{align}\r\n    A \\vec{x} &\\leq \\vec{b} \\\\\r\n    \\max \\vec{f}^T \\vec{x} & \\\\\r\n    \\vec{x} &\\geq 0\r\n\\end{align}$$\r\nre\u0161ujemo s simpleksno metodo tako, da vpeljemo dopolnilne\r\nspremenljivke $\\vec{y}$ ter nastavimo slovar\r\n$$\\begin{align}\r\n    \\vec{y} &= \\vec{b} - A \\vec{x} \\\\\r\n    z &= \\vec{f}^T \\vec{x}\r\n\\end{align}$$\r\nki ga postopno preoblikujemo z zamenjavo baznih in nebaznih spremenljivk.\r\n\r\nNa vsakem koraku izberemo nebazno spremenljivko $x_i$, za katero je\r\npripadajo\u010di koeficient $f_i$ pozitiven, ter jo izrazimo s tisto\r\nbazno spremenljivko $y_j$, katere pripadajo\u010da ena\u010dba najbolj omejuje $x_i$.\r\nS tem $x_i$ vstopi v bazo, $y_j$ pa izstopi iz nje.\r\n\r\nPostopek v splo\u0161nem kon\u010damo, ko so vsi koeficienti $f_i$ negativni, saj\r\nje maksimum tedaj dose\u017een natanko takrat, ko so vse nebazne spremenljivke\r\nenake $0$.\r\n\r\nSlovarje v R-ju predstavimo s seznami z naslednjimi komponentami:\r\n\r\n* matriko `A`,\r\n* vektorjem `b`,\r\n* vektorjem `f`,\r\n* \u0161tevilom `v`, ki predstavlja vrednost funckionala $z$ (in je na za\u010detku 0),\r\n* vektorjem `bazne`, ki predstavlja imena baznih spremenljivk in\r\n* vektorjem `nebazne`, ki predstavlja imena nebaznih spremenljivk.", 
      "language": 1, 
      "title": "Simpleksna metoda", 
      "timestamp": "2012-11-19 13:44:25", 
      "author": 1, 
      "problem_set": 8, 
      "preamble": "# Primeri \u0161tirih slovarjev z lanskih predavanj.\r\n\r\n# Slovar za primer linearnega problema pri grafi\u010dnem re\u0161evanju\r\nslovar.1 <- list(\r\n  A = -matrix(c(1, 2, 5, 4), nrow=2, ncol=2, byrow=TRUE),\r\n  b = c(6, 20), f = c(1, 1), v = 0,\r\n  bazne = c(\"y1\", \"y2\"), nebazne = c(\"x1\", \"x2\")\r\n)\r\n\r\n# Slovar za primer problema kmeta \r\nslovar.2 <- list(\r\n  A = -matrix(c(1, 1, 1, 3, 4, 5, 10, 15, 12), nrow=3, ncol=3, byrow=TRUE),\r\n  b = c(50, 250, 600), f = c(3, 5, 4), v = 0,\r\n  bazne = c(\"y1\", \"y2\", \"y3\"), nebazne = c(\"x1\", \"x2\", \"x3\")\r\n)\r\n\r\n# Slovar za \u0161e en primer linearnega problema\r\nslovar.3 <- list(\r\n  A = -matrix(c(2, 0, 0, 6, -4, 2, 4, 3, -1), nrow=3, ncol=3, byrow=TRUE),\r\n  b = c(1, 3, 2), f = c(8, -1, 2), v = 0,\r\n  bazne = c(\"y1\", \"y2\", \"y3\"), nebazne = c(\"x1\", \"x2\", \"x3\")\r\n)\r\n\r\n# Slovar za primer neomejenega linearnega problema\r\nslovar.4 <- list(\r\n  A = -matrix(c(2, -1, 1, 2, 0, -1), nrow=2, ncol=3, byrow=TRUE),\r\n  b = c(2, 0), f = c(1, 1, 1), v = 0,\r\n  bazne = c(\"y1\", \"y2\"), nebazne = c(\"x1\", \"x2\", \"x3\")\r\n)\r\n\r\n# Naslednja funkcija dani slovar zapi\u0161e v malo preglednej\u0161i obliki.\r\n# Uporabite jo, da vidite, kako se spreminjajo va\u0161i slovarji.\r\npredstavi <- function(slovar) {\r\n  matrika <- rbind(cbind(slovar$b, slovar$A), c(slovar$v, slovar$f))\r\n  colnames(matrika) <- c(\"\", slovar$nebazne)\r\n  rownames(matrika) <- c(slovar$bazne, \"z\")\r\n  return(matrika[order(rownames(matrika)), order(colnames(matrika))])\r\n}"
    }
  }, 
  {
    "pk": 65, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Seznam, v katerem so vsi elementi vektorji enakih dol\u017ein, lahko ozna\u010dimo\r\nza razpredelnico. Ta se obna\u0161a kot me\u0161anica med seznamom in matriko.\r\nRazpredelnico ozna\u010dimo z ukazom `data.frame`\r\n\r\n    x <- list(crke = letters[1 : 10], stevilke = 101 : 110) # neozna\u010den seznam\r\n    x # seznam, ki ni ozna\u010den kot razpredelnica\r\n\r\n    y <- data.frame(x) # seznam, ki je ozna\u010den kot razpredelnica\r\n    y <- data.frame(crke = letters[1 : 10], stevilke = 101 : 110) # podobno\r\n    y # razpredelnica se izpi\u0161e druga\u010de kot seznam\r\n    y$stevilke # y se obna\u0161a kot seznam\r\n    y[3, ] # y se obna\u0161a kot matrika\r\n    y[y$stevilke %% 3 == 0, ] # ali kot eno in drugo", 
      "language": 1, 
      "title": "Razpredelnice", 
      "timestamp": "2012-11-19 13:43:16", 
      "author": 1, 
      "problem_set": 22, 
      "preamble": ""
    }
  }, 
  {
    "pk": 260, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Iterativno urejanje z zlivanjem", 
      "timestamp": "2012-10-25 14:07:05", 
      "author": 1, 
      "problem_set": 79, 
      "preamble": ""
    }
  }, 
  {
    "pk": 163, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Lojzku je dolg\u010das, zato se igra z velikimi praznimi \u0161katlami, ki se\r\nnahajajo v skladi\u0161\u010du, v katerem dela. Dimenzije \u0161katel so shranjene v\r\nseznamu  trojic. Na primer, trojica `(50, 100, 100)` predstavlja\r\n\u0161katlo, ki je visoka 50 cm ter \u0161iroka in dolga 100 cm.", 
      "language": 2, 
      "title": "\u0160katle", 
      "timestamp": "2012-07-27 12:15:38", 
      "author": 1, 
      "problem_set": 58, 
      "preamble": ""
    }
  }, 
  {
    "pk": 231, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Neuravnote\u017eenost", 
      "timestamp": "2012-07-11 09:59:01", 
      "author": 1, 
      "problem_set": 72, 
      "preamble": "class Drevo:\n    def __init__(self, *args, **kwargs):\n        if args:\n            self.prazno = False\n            self.vsebina = args[0]\n            self.levo = kwargs.get('levo', Drevo())\n            self.desno = kwargs.get('desno', Drevo())\n        else:\n            self.prazno = True\n\n    def __repr__(self):\n        if self.prazno:\n            return \"Drevo()\"\n        else:\n            opis = str(self.vrednost)\n            if not self.levo.prazno: opis += \", levo={0}\".format(self.levo)\n            if not self.desno.prazno: opis += \", desno={0}\".format(self.desno)\n            return \"Drevo({0})\".format(opis)"
    }
  }, 
  {
    "pk": 151, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Predstavniki ekvivalen\u010dnih razredov", 
      "timestamp": "2012-05-04 11:25:27", 
      "author": 1, 
      "problem_set": 47, 
      "preamble": ""
    }
  }, 
  {
    "pk": 284, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Vrsta", 
      "timestamp": "2012-11-29 09:38:39", 
      "author": 1, 
      "problem_set": 88, 
      "preamble": ""
    }
  }, 
  {
    "pk": 271, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Vzemimo neurejeno tabelo $A = [a_0, a_1, \\dots, a_{n - 1}]$. \u010ce bi radi\r\nle pribli\u017eno videli, kako so razporejeni elementi, lahko ustvarimo\r\n_skico_ velikosti $m$. Zaradi enostavnosti privzemimo, da velja\r\n$n = k \\cdot m$ za neko naravno \u0161tevilo $k$.\r\n\r\nSikca je urejena tabela $[s_0, s_1, \\dots, s_{m - 1}]$, za katero velja,\r\nda bi v tabeli $A$, \u010de bi jo uredili po velikosti, element $s_i$ le\u017eal\r\nnekje med $k \\cdot i$. in $k \\cdot (i + 1) - 1$. mestom.\r\n\r\nRecimo, da je $A = [1, 2, \\dots, 16]$. Potem bi bila skica velikosti $4$\r\nlahko recimo $[1, 5, 9, 13]$, $[4, 8, 12, 16]$, $[1, 6, 10, 16]$, ali\r\npa katerakoli tabela $[s_0, s_1, s_2, s_3]$, za katero bi veljalo\r\n$1 \\le s_0 \\le 4, 5 \\le s_1 \\le 8, 9 \\le s_2 \\le 12, 13 \\le s_3 \\le 16$.\r\nSkica velikosti $2$ pa bi bila katerakoli tabela $[s_0, s_1]$, za\r\nkatero bi veljalo $1 \\le s_0 \\le 8$ in $9 \\le s_1 \\le 16$.\r\nSkica velikosti $1$ bi bila tabela $[s_0]$, kjer je $s_0$ poljuben\r\nelement $A$, skica velikosti $16$ pa kar tabela $A$.\r\n\r\nSkico lahko seveda vedno dobimo tako, da tabelo $A$ najprej uredimo,\r\nnato jo razdelimo na dele, ki vsebujejo po $k$ elementov, na koncu pa iz\r\nvsakega takega dela izberemo po enega predstavnika. Vendar je tako\r\nurejanje zamudno, saj je njegova zahtevnost enaka $O(n \\log n)$.", 
      "language": 2, 
      "title": "Skica tabele", 
      "timestamp": "2013-01-07 12:46:52", 
      "author": 1, 
      "problem_set": 82, 
      "preamble": ""
    }
  }, 
  {
    "pk": 107, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "\u0160tevke", 
      "timestamp": "2012-03-12 09:55:43", 
      "author": 1, 
      "problem_set": 41, 
      "preamble": ""
    }
  }, 
  {
    "pk": 208, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "V datoteki so zapisana imena v ve\u010dih vrsticah, v vsaki vrstici pa so\nlo\u010dena z vejicami, na primer: `Jaka,Luka,Miha,Luka,Anja`.", 
      "language": 2, 
      "title": "Imena", 
      "timestamp": "2012-05-14 06:30:42", 
      "author": 1, 
      "problem_set": 49, 
      "preamble": ""
    }
  }, 
  {
    "pk": 301, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Pregled v globino", 
      "timestamp": "2013-01-07 12:17:01", 
      "author": 1, 
      "problem_set": 90, 
      "preamble": "def dfs(g, pre=None, post=None):\n    obiskano = {v: False for v in g}\n    def obisci(v):\n        obiskano[v] = True\n        if pre: pre(v)\n        for w in g[v]:\n            if not obiskano[w]: obisci(w)\n        if post: post(v)\n    for v in g:\n        obisci(v)"
    }
  }, 
  {
    "pk": 114, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Sprehodi", 
      "timestamp": "2012-03-22 11:22:49", 
      "author": 1, 
      "problem_set": 43, 
      "preamble": ""
    }
  }, 
  {
    "pk": 45, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Za vajo si bomo zopet ogledali razporeditev `Titanic`.", 
      "language": 1, 
      "title": "Titanic", 
      "timestamp": "2011-11-23 14:34:31", 
      "author": 1, 
      "problem_set": 13, 
      "preamble": ""
    }
  }, 
  {
    "pk": 167, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Tukaj re\u0161ujete 2. nalogo.", 
      "language": 2, 
      "title": "Naloga2", 
      "timestamp": "2012-02-10 13:12:40", 
      "author": 86, 
      "problem_set": 59, 
      "preamble": "class IskalnoDrevo():\r\n\r\n    def __init__(self, vsebina = []):\r\n        self.prazno = True\r\n        for n in vsebina:\r\n            self.dodaj(n)\r\n\r\n    def __repr__(self, zamik = ''):\r\n        if self.prazno:\r\n          return 'IskalnoDrevo()'.format(zamik)\r\n        elif self.levo.prazno and self.desno.prazno:\r\n          return 'IskalnoDrevo({1})'.format(zamik, self.vsebina)\r\n        else:\r\n          return 'IskalnoDrevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\r\n            format(\r\n              zamik,\r\n              self.vsebina,\r\n              self.levo.__repr__(zamik + '             '),\r\n              self.desno.__repr__(zamik + '              ')\r\n            )\r\n\r\n    def pravilno(self, minimum=None, maksimum=None):\r\n        if self.prazno:\r\n            return True\r\n        elif minimum and self.vsebina < minimum:\r\n            return False\r\n        elif maksimum and self.vsebina > maksimum:\r\n            return False\r\n        else:\r\n            return (self.levo.pravilno(minimum, self.vsebina) and\r\n                    self.desno.pravilno(self.vsebina, maksimum))\r\n\r\n    def dodaj(self, podatek):\r\n        if self.prazno:\r\n            self.prazno = False\r\n            self.vsebina = podatek\r\n            self.levo = IskalnoDrevo()\r\n            self.desno = IskalnoDrevo()\r\n        elif self.vsebina > podatek:\r\n            self.levo.dodaj(podatek)\r\n        elif self.vsebina < podatek:\r\n            self.desno.dodaj(podatek)"
    }
  }, 
  {
    "pk": 276, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Seveda R pozna tudi ogromno funkcij, namenjenih za delo z vektorji.\nPoleg tega, da skoraj vse vgrajene funkcije, ki smo jih spoznali,\ns pomo\u010djo cikli\u010dnega dopolnjevanja delujejo tudi na vektorjih, obstajajo\nfunkcije, ki so smiselne \u0161ele, ko jih uporabite na vektorjih.\n\nNa primer, `sum(x)` izra\u010duna vsoto \u010dlenov `x`, `prod(x)` njihov zmno\u017eek,\n`mean(x)` njihovo povpre\u010dje, `sd(x)` njihov standardni odklon, `min(x)`\nnajmanj\u0161i \u010dlen, `max(x)` najve\u010dji \u010dlen, `range(x)` pa oba.\n\nOglejte si, kaj delajo funkcije `cumsum`, `cumprod`, `cummin`, `cummax`,\n`pmin` in `pmax`.\n\nUporabna je tudi funkcija `ifelse(p, x1, x2)`, ki deluje podobno kot\npogojni stavek, vendar ne izvaja ukazov, temve\u010d vra\u010da vrednosti\n(saj je funkcija in ne krmilni stavek). Zato lahko `ifelse` deluje tudi\nna vektorjih. V tem primeru iz vektorja `x1` izbira \u010dlene na mestih,\nkjer je `p` enak `TRUE`, iz `x2` pa tam, kjer je `p` enak `FALSE`.\nNa primer `ifelse(c(TRUE, FALSE, TRUE), c(1, 3, 5), c(2, 4, 6))`\nvrne vektor `c(1, 4, 5)`.\n\nPri delu z logi\u010dnimi vektorji pogosto uporabljamo tudi `all` in\b`any`.\nUkaz `all(x)` vrne `TRUE` natanko takrat, ko so vsi \u010dleni vektorja `x`\nenaki `TRUE`, ukaz `any(x)` pa takrat, ko je vsaj en \u010dlen `x` enak `TRUE`.", 
      "language": 1, 
      "title": "Funkcije za delo z vektorji", 
      "timestamp": "2012-11-14 09:09:32", 
      "author": 1, 
      "problem_set": 84, 
      "preamble": "prastevilo <- function(n) {\n  if(n == 1)\n    return(FALSE)\n  i <- 2\n  while(i * i <= n) {\n    if(n %% i == 0)\n      return(FALSE)\n    i <- i + 1\n  }\n  return(TRUE)\n}"
    }
  }, 
  {
    "pk": 92, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Tokrat boste v R-ju posku\u0161ali napisati \u010dimbolj\u0161i pribli\u017eek orodja\n[Gapminder](http://www.gapminder.org/), ki smo si ga ogledali na\nprvih vajah.", 
      "language": 1, 
      "title": "Gapminder", 
      "timestamp": "2013-01-02 09:44:07", 
      "author": 1, 
      "problem_set": 27, 
      "preamble": ""
    }
  }, 
  {
    "pk": 118, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Pomno\u017eevanje seznamov", 
      "timestamp": "2012-03-27 09:47:28", 
      "author": 1, 
      "problem_set": 44, 
      "preamble": ""
    }
  }, 
  {
    "pk": 26, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Najprej poglejte lekcijo [Urejanje z vstavljanjem](http://vimeo.com/30669299).\r\nPozor, video vsebuje re\u0161itev naloge, zato ga nehajte gledati takoj,\r\nko razumete, kako algoritem deluje.", 
      "language": 2, 
      "title": "Urejanje z vstavljanjem", 
      "timestamp": "2012-10-24 09:48:20", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 250, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Ozna\u010dba registrske tablice se za\u010dne z dvo\u010drkovno okraj\u0161avo kraja, ki ji\r\nsledi zvezdica, tej pa pet \u010drke ali \u0161tevilk ter pomi\u0161ljaj, na primer:\r\n`\"MB*56-TR2\".", 
      "language": 2, 
      "title": "Registrske tablice", 
      "timestamp": "2013-01-15 20:20:34", 
      "author": 1, 
      "problem_set": 77, 
      "preamble": ""
    }
  }, 
  {
    "pk": 61, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Spreminjanje dreves", 
      "timestamp": "2011-11-24 12:30:46", 
      "author": 1, 
      "problem_set": 20, 
      "preamble": "class Drevo:\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        if args:\r\n            self.prazno = False\r\n            self.vsebina = args[0]\r\n            self.levo = kwargs.get('levo', Drevo())\r\n            self.desno = kwargs.get('desno', Drevo())\r\n        else:\r\n            self.prazno = True\r\n\r\n    def __repr__(self, zamik = ''):\r\n        if self.prazno:\r\n          return 'Drevo()'.format(zamik)\r\n        elif self.levo.prazno and self.desno.prazno:\r\n          return 'Drevo({1})'.format(zamik, self.vsebina)\r\n        else:\r\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\r\n            format(\r\n              zamik,\r\n              self.vsebina,\r\n              self.levo.__repr__(zamik + '             '),\r\n              self.desno.__repr__(zamik + '              ')\r\n            )\r\n\r\n    def __eq__(self, other):\r\n        return ((self.prazno and other.prazno) or\r\n                (not self.prazno and not other.prazno and\r\n                 self.vsebina == other.vsebina and\r\n                 self.levo == other.levo and\r\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 122, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Nakupi", 
      "timestamp": "2012-04-16 12:58:39", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": ""
    }
  }, 
  {
    "pk": 171, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Cikli", 
      "timestamp": "2012-02-17 10:07:27", 
      "author": 1, 
      "problem_set": 60, 
      "preamble": "class Cikel:\r\n    def __init__(self, sez=[]):\r\n        self.prazen = True\r\n        for x in sez:\r\n            self.dodaj(x)\r\n            self = self.naslednji\r\n   \r\n    def __repr__(self):\r\n        if self.prazen:\r\n            return \"()\"\r\n        else:\r\n            x = self\r\n            vrednosti = [str(self.vrednost)]\r\n        while x.naslednji != self:\r\n            x = x.naslednji\r\n            vrednosti.append(str(x.vrednost))\r\n        return \"({0})\".format(\", \".join(vrednosti))\r\n \r\n    def dodaj(self, x):\r\n        if self.prazen:\r\n            self.prazen = False\r\n            self.vrednost = x\r\n            self.naslednji = self\r\n        else:\r\n            naslednji = Cikel([x])\r\n            self.naslednji, naslednji.naslednji = naslednji, self.naslednji"
    }
  }, 
  {
    "pk": 95, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Iskalna drevesa", 
      "timestamp": "2012-02-07 09:27:44", 
      "author": 1, 
      "problem_set": 36, 
      "preamble": "class IskalnoDrevo:\r\n    def __init__(self, vrednosti=[]):\r\n        self.prazno = True\r\n        for x in vrednosti:\r\n            self.vstavi(x)\r\n\r\n    def __repr__(self):\r\n        if self.prazno:\r\n            return \"IskalnoDrevo()\"\r\n        else:\r\n            opis = str(self.vrednost)\r\n            if not self.levo.prazno: opis += \", levo={0}\".format(self.levo)\r\n            if not self.desno.prazno: opis += \", desno={0}\".format(self.desno)\r\n            return \"IskalnoDrevo({0})\".format(opis)\r\n\r\n    def vstavi(self, x):\r\n        if self.prazno:\r\n            self.prazno = False\r\n            self.vrednost = x\r\n            self.levo = IskalnoDrevo()\r\n            self.desno = IskalnoDrevo()\r\n        elif x < self.vrednost:\r\n            self.levo.vstavi(x)\r\n        else:\r\n            self.desno.vstavi(x)"
    }
  }, 
  {
    "pk": 218, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Namen te naloge je narisati Hilbertovo krivuljo. Njena posebnost je ta,\nda v limiti povsem zapolni za\u010detni kvadrat. Hausdorffova dimenzija limitne\nkrivulje je torej 2. Ve\u010d podrobnosti najdete na Wiki strani\n[Hilbertova krivulja](http://sl.wikipedia.org/wiki/Hilbertova_krivulja)", 
      "language": 2, 
      "title": "Hilbertova krivulja", 
      "timestamp": "2012-05-27 22:38:18", 
      "author": 162, 
      "problem_set": 68, 
      "preamble": "import turtle as T\n\n# Za hitrej\u0161e risanje\nT.ht()\nT.speed(0)\nT.tracer(0)"
    }
  }, 
  {
    "pk": 174, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "S tipko `F5` lahko va\u0161 program nalo\u017eite v konzolo. Nato lahko v konzoli\r\nnapi\u0161ete poljuben izraz, Python pa ga bo izra\u010dunal.", 
      "language": 2, 
      "title": "Interaktivna konzola", 
      "timestamp": "2012-02-20 09:02:44", 
      "author": 1, 
      "problem_set": 61, 
      "preamble": "# Spodnje vrstice definirajo funkcijo `c` na naravnih \u0161tevilih. Definicije\r\n# vam zaenkrat \u0161e ni potrebno razumeti.\r\ndef c(n):\r\n    if n == 1:\r\n        return n\r\n    elif n % 2 == 0:\r\n        return c(n // 2)\r\n    else:\r\n        return c(3 * n + 1)"
    }
  }, 
  {
    "pk": 184, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "V izjavni logiki velja, da lahko poljuben logi\u010dni izraz zapi\u0161emo samo\nz uporabo operacij *in*, *ali* in *ne* (torej, konjunkcije, disjunkcije\nin negacije).\nIzka\u017ee se, da s samo enim izmed teh dveh ne moremo sestaviti poljubne\nizjave, ravno tako ni dovolj, \u010de imamo samo operaciji *in* in *ali*.\nVseeno pa obstajajo operacije, ki imajo to lastnost, da lahko z njimi\nizrazimo zgornje tri operacije in torej lahko zapi\u0161emo poljubno\nlogi\u010dno izjavo samo z uporabo te ene operacije.", 
      "language": 2, 
      "title": "Napredni logi\u010dni operatorji", 
      "timestamp": "2012-03-11 21:55:29", 
      "author": 162, 
      "problem_set": 66, 
      "preamble": ""
    }
  }, 
  {
    "pk": 52, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Bisekcija z dvema tabelama", 
      "timestamp": "2011-11-23 14:40:35", 
      "author": 19, 
      "problem_set": 15, 
      "preamble": ""
    }
  }, 
  {
    "pk": 177, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Razdalje med to\u010dkami", 
      "timestamp": "2012-03-04 16:51:44", 
      "author": 1, 
      "problem_set": 64, 
      "preamble": ""
    }
  }, 
  {
    "pk": 77, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Otroci se igrajo iz\u0161tevanko tako, da se postavijo v krog, nato pa po vrsti\r\nizlo\u010dajo vsakega $k$-tega. Na primer, \u010de se Ana, Bine, Cene, Darko, Eva in\r\nFerenc postavijo v krog v tem vrstnem redu ter za\u010dnejo iz\u0161tevati pri Ani s\r\npreskakovanjem po 4, dobimo vrstni red: Darko, Bine, Ana, Cene, Ferenc, Eva.", 
      "language": 2, 
      "title": "Iz\u0161tevanka", 
      "timestamp": "2011-12-15 11:21:15", 
      "author": 19, 
      "problem_set": 28, 
      "preamble": ""
    }
  }, 
  {
    "pk": 29, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Aritmetika", 
      "timestamp": "2012-11-05 01:06:47", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 307, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Datoteke", 
      "timestamp": "2013-01-16 17:44:13", 
      "author": 1, 
      "problem_set": 91, 
      "preamble": "with open(\"test1.txt\", \"w\") as testna_f:\n    print(\"Prijatlji! odrodile\", file=testna_f)\n    print(\"so trte vince nam sladk\u00f3,\", file=testna_f)\n    print(\"ki nam o\u017eivlja \u017eile,\", file=testna_f)\n    print(\"srce razj\u00e1sni in oko,\", file=testna_f)\n    print(\"ki utopi\", file=testna_f)\n    print(\"vse skrbi,\", file=testna_f)\n    print(\"v potrtih prsih up budi!\", file=testna_f)\n\nwith open(\"test2.txt\", \"w\") as testna_f:\n    print(\"Nazadnje \u0161e, prijatlji,\", file=testna_f)\n    print(\"kozarce zase vzdignimo,\", file=testna_f)\n    print(\"ki smo zato se zbratli,\", file=testna_f)\n    print(\"ker dobro v srcu mislimo;\", file=testna_f)\n    print(\"d\u00f3kaj dni\", file=testna_f)\n    print(\"naj \u017eiv\u00ed\", file=testna_f)\n    print(\"vsak, kar nas dobrih je ljudi!\", file=testna_f)"
    }
  }, 
  {
    "pk": 34, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Vektorji in matrike v R-ju se ne ustavijo pri dveh dimenzijah. O objektih\nvi\u0161jih dimenzij govorimo kot o razporeditvah. Postopek je enak.\n    \nPrvi dve dimenziji se poka\u017eeta v matri\u010dni obliki, za vse nadaljnje pri\nizpisu na\u0161tejemo vse mo\u017enosti.\n\n    x <- 1 : 100\n    dim(x) <- c(10, 5, 2)\n    x\n    \n    dim(x) <- c(5, 5, 2, 2)\n    x\n    \nDo komponent dostopamo na enak na\u010din kot prej.\n\n    x[4, , 1, ]      # elementi v 4. vrstici in indeksom 1. v 3. dimenziji.\n    x[, 2 : 4, , -2] # elementi od 2. do 4. stolpca in z\n                     # indeksom razli\u010dnim od 2 v 4. dimenziji.\n    x[, , , 1] <- -x[, , , 1] # negiraj elemente z indeksom 1 v 4. dimenziji\n    \nV spremenljivki `Titanic` so shranjeni podatki o pre\u017eivelih potnikih na\nTitaniku. Razporeditev je \u0161tiridimenzionalna.\nPoglejte, kaj opisuje katera dimenzija?\n    \n    Titanic[, \"Male\", , \"No\"] # \u0160tevila mo\u0161kih, ki niso pre\u017eiveli.\n    sum(Titanic[\"Crew\", , ,]) # Velikost celotne posadke", 
      "language": 1, 
      "title": "Razporeditve", 
      "timestamp": "2011-11-23 14:35:18", 
      "author": 1, 
      "problem_set": 8, 
      "preamble": ""
    }
  }, 
  {
    "pk": 100, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Koti", 
      "timestamp": "2013-02-25 04:08:28", 
      "author": 1, 
      "problem_set": 39, 
      "preamble": "import random\nimport math\n\ndef izvedi(source, d):\n    import io, sys\n    old_stdout = sys.stdout\n    new_stdout = io.StringIO()\n    sys.stdout = new_stdout\n    exec(source, d)\n    sys.stdout = old_stdout\n    return (d, new_stdout.getvalue())\n\n(stopinje1,minute1, sekunde1, stopinje2, minute2,sekunde2) = (14,43,15,55,21,57)\n(kot, ura, minuta) = (2.185, 17, 47)"
    }
  }, 
  {
    "pk": 248, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Ozna\u010dba registrske tablice se za\u010dne z dvo\u010drkovno okraj\u0161avo kraja, ki ji\nsledi zvezdica, tej pa pet \u010drke ali \u0161tevilk ter pomi\u0161ljaj, na primer:\n`\"MB*56-TR2\".", 
      "language": 2, 
      "title": "Registrske tablice", 
      "timestamp": "2012-09-05 09:34:40", 
      "author": 1, 
      "problem_set": 76, 
      "preamble": ""
    }
  }, 
  {
    "pk": 84, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Ra\u010dunanje dolo\u010denih integralov ni edina plo\u0161\u010dina, ki jo lahko ocenimo\r\nz metodo Monte Carlo. Na podoben na\u010din lahko izra\u010dunamo tudi druge\r\nplo\u0161\u010dine, na primer plo\u0161\u010dino kroga.\r\n\r\n     plot(c(-1, 1), c(-1, 1), type = \"n\")\r\n     krog(0, 0, 1)\r\n\r\n     x <- runif(1000, -1, 1)\r\n     y <- runif(1000, -1, 1)\r\n     v.krogu <- x^2 + y^2 < 1\r\n     \r\n     points(x[v.krogu], y[v.krogu], col = \"green\")\r\n     points(x[!v.krogu], y[!v.krogu], col = \"blue\")\r\n     \r\n     razmerje.tock <- sum(v.krogu) / 1000\r\n     ploscina <- 4\r\n     razmerje.tock * ploscina", 
      "language": 1, 
      "title": "Plo\u0161\u010dine", 
      "timestamp": "2011-12-19 22:17:35", 
      "author": 1, 
      "problem_set": 30, 
      "preamble": "krog <- function(x0, y0, r) {\r\n  t <- seq(0, 2 * pi, 0.01)\r\n  x <- x0 + r * cos(t)\r\n  y <- y0 + r * sin(t)\r\n  lines(x, y)\r\n}"
    }
  }, 
  {
    "pk": 8, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "*Nepopolnost* \u0161tevila je absolutna razlika med \u0161tevilom in vsoto\nnjegovih pravih deliteljev.\nNa primer, nepopolnost \u0161tevila $10$ je $|10 - (1 + 2 + 5)| = 2$.", 
      "language": 2, 
      "title": "Nepopolna \u0161tevila", 
      "timestamp": "2011-12-01 12:15:34", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 98, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "\u0160ahovnice", 
      "timestamp": "2013-02-25 02:15:49", 
      "author": 1, 
      "problem_set": 37, 
      "preamble": ""
    }
  }, 
  {
    "pk": 110, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "Pribli\u017eke za kvadratni koren \u0161tevila $n$ lahko izra\u010dunamo po\nnaslednjem postopku. Za\u010detni pribli\u017eek $x_0$ je enak $n / 2$.\nVsak naslednji pribli\u017eek $x_{k + 1}$ pa izra\u010dunamo kot\n$(x_k + n / x_k) / 2$.", 
      "language": 2, 
      "title": "Kvadratni koren", 
      "timestamp": "2012-03-14 09:54:10", 
      "author": 1, 
      "problem_set": 42, 
      "preamble": ""
    }
  }, 
  {
    "pk": 311, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Sebi\u010dnost", 
      "timestamp": "2013-02-04 07:49:04", 
      "author": 1, 
      "problem_set": 92, 
      "preamble": "class Drevo:\n    def __init__(self, *args, **kwargs):\n        if args:\n            self.prazno = False\n            self.vsebina = args[0]\n            self.levo = kwargs.get('levo', Drevo())\n            self.desno = kwargs.get('desno', Drevo())\n        else:\n            self.prazno = True\n\n    def __repr__(self):\n        if self.prazno:\n            return \"Drevo()\"\n        else:\n            opis = str(self.vsebina)\n            if not self.levo.prazno: opis += \", levo={0}\".format(self.levo)\n            if not self.desno.prazno: opis += \", desno={0}\".format(self.desno)\n            return \"Drevo({0})\".format(opis)\n\n    def vsebine(self):\n        if self.prazno:\n            return []\n        else:\n            return sorted([self.vsebina] + self.levo.vsebine() + self.desno.vsebine())"
    }
  }, 
  {
    "pk": 243, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Skupni prednik", 
      "timestamp": "2012-11-02 11:15:08", 
      "author": 1, 
      "problem_set": 75, 
      "preamble": "class IskalnoDrevo:\r\n    def __init__(self, vrednosti=[]):\r\n        self.prazno = True\r\n        for x in vrednosti:\r\n            self.vstavi(x)\r\n\r\n    def __repr__(self):\r\n        if self.prazno:\r\n            return \"IskalnoDrevo()\"\r\n        else:\r\n            opis = str(self.vrednost)\r\n            if not self.levo.prazno: opis += \", levo={0}\".format(self.levo)\r\n            if not self.desno.prazno: opis += \", desno={0}\".format(self.desno)\r\n            return \"IskalnoDrevo({0})\".format(opis)\r\n\r\n    def vstavi(self, x):\r\n        if self.prazno:\r\n            self.prazno = False\r\n            self.vrednost = x\r\n            self.levo = IskalnoDrevo()\r\n            self.desno = IskalnoDrevo()\r\n        elif x < self.vrednost:\r\n            self.levo.vstavi(x)\r\n        else:\r\n            self.desno.vstavi(x)"
    }
  }, 
  {
    "pk": 50, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Ulomki", 
      "timestamp": "2012-10-24 13:43:41", 
      "author": 1, 
      "problem_set": 14, 
      "preamble": ""
    }
  }, 
  {
    "pk": 262, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "$n$-terice", 
      "timestamp": "2012-10-22 20:50:45", 
      "author": 1, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 236, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Kraj\u0161anje znakov", 
      "timestamp": "2012-07-12 08:25:27", 
      "author": 1, 
      "problem_set": 73, 
      "preamble": ""
    }
  }, 
  {
    "pk": 126, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Sestavine, ki jih potrebujemo za nek recept, opi\u0161emo s slovarjem, v\nkaterem so klju\u010di sestavine, vrednosti pa koli\u010dine, ki jih potrebujemo.", 
      "language": 2, 
      "title": "Kuhamo in pe\u010demo", 
      "timestamp": "2012-05-04 11:25:40", 
      "author": 1, 
      "problem_set": 47, 
      "preamble": ""
    }
  }, 
  {
    "pk": 123, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Izpeljani seznami", 
      "timestamp": "2012-04-16 13:04:46", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": ""
    }
  }, 
  {
    "pk": 164, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Usmerjeni graf lahko predstavimo s slovarjem, v katerem so klju\u010di\r\nvozli\u0161\u010da, pripadajo\u010de vrednosti pa so mno\u017eice sosedov, torej vozli\u0161\u010d\r\nv katera vodijo povezave iz izbranega vozli\u0161\u010da.\r\n\r\nTako bi graf z vozli\u0161\u010di $1$, $2$, $3$ in s povezavami $(1, 3)$, $(2, 1)$\r\nin $(2, 3)$ predstavili s slovarjem `{1: {3}, 2: {1, 3}, 3: set()}`.", 
      "language": 2, 
      "title": "Usmerjeni grafi", 
      "timestamp": "2012-07-27 12:15:38", 
      "author": 1, 
      "problem_set": 58, 
      "preamble": ""
    }
  }, 
  {
    "pk": 27, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Najprej poglejte lekcijo [Urejanje z zlivanjem](http://vimeo.com/30670205).", 
      "language": 2, 
      "title": "Urejanje z zlivanjem", 
      "timestamp": "2012-10-24 09:22:27", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 168, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Tukaj re\u0161ujete 3. nalogo.", 
      "language": 2, 
      "title": "Naloga 3", 
      "timestamp": "2012-02-10 13:58:42", 
      "author": 86, 
      "problem_set": 59, 
      "preamble": ""
    }
  }, 
  {
    "pk": 74, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Definirajte razred `Polinom`, s katerim predstavimo polinom v\nspremenljivki $x$. Polinom predstavimo s seznamom njegovih\nkoeficientov, kjer je $k$-ti element seznama koeficient pri $x^k$.\nNa primer, polinom $x^3 + 2 x + 7$ predstavimo s\n`Polinom([7, 2 ,0, 1])`. Razmislite, kaj predstavlja `Polinom([])`.\nZadnji koeficient v seznamu mora biti neni\u010delen.", 
      "language": 2, 
      "title": "Polinomi", 
      "timestamp": "2011-12-08 11:55:59", 
      "author": 19, 
      "problem_set": 26, 
      "preamble": ""
    }
  }, 
  {
    "pk": 78, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Seznam \u0161tevil lahko razdelimo na *monotone odseke*, ki so podseznami\r\npadajo\u010dih ali rasto\u010di vrednosti. Na primer, seznam\r\n\r\n    [1,2,3,4,3,2,1,1,1,10,20,30]\r\n\r\nrazdelimo na odseke `[1,2,3,4]`, `[3,2,1]`, `[1]` in `[1,10,20,30]`.\r\nNa monotone odseke lahko razdelimo tudi iterator, pri \u010demer dobimo\r\niterator, ki vra\u010da sezname (predpostavimo, da ni neskon\u010dnih monotonih\r\nodsekov). Na primer, iterator, ki vra\u010da\r\n\r\n    1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ...\r\n\r\npredelamo v itreator, ki vra\u010da sezname\r\n\r\n    [1], [1,2], [1,2,3], [1,2,3,4], ...", 
      "language": 2, 
      "title": "Monotoni odseki", 
      "timestamp": "2011-12-15 11:21:15", 
      "author": 19, 
      "problem_set": 28, 
      "preamble": ""
    }
  }, 
  {
    "pk": 85, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Z ukazi `union`, `intersect` in `setdiff` lahko na vektorjih izvajamo\r\niste operacije kot na mno\u017eicah. Z ukazom `setequal` preverimo ali sta\r\ndve mno\u017eici enaki, z ukazom `is.element(x, y)` pa \u010de element `x`\r\nnastopa v vektorju `y`.\r\n\r\n    union(c(1, 2, 5), c(2, 3, 4, 6))\r\n    intersect(c(1, 2, 5), c(2, 3, 4, 6))\r\n    setdiff(c(1, 2, 5), c(2, 3, 4, 6))\r\n    is.element(5, 1 : 10)\r\n    is.element(15, 1 : 10)\r\n    is.element(c(0, 5, 10, 15), 1 : 10) # dela tudi po komponentah\r\n    5 %in% 1 : 10 # Namesto is.element(x, a) pi\u0161emo kar x %in% a", 
      "language": 1, 
      "title": "Velikosti mno\u017eic", 
      "timestamp": "2011-12-19 22:17:35", 
      "author": 1, 
      "problem_set": 30, 
      "preamble": ""
    }
  }, 
  {
    "pk": 96, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Urejanje", 
      "timestamp": "2012-02-07 09:24:35", 
      "author": 1, 
      "problem_set": 36, 
      "preamble": ""
    }
  }, 
  {
    "pk": 55, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Definirajte razred `Polinom`, s katerim predstavimo polinom v\r\nspremenljivki $x$. Polinom predstavimo s seznamom njegovih\r\nkoeficientov, kjer je $k$-ti element seznama koeficient pri $x^k$.\r\nNa primer, polinom $x^3 + 2 x + 7$ predstavimo s `Polinom([7, 2, 0, 1])`.\r\nRazmislite, kaj predstavlja `Polinom([])`. Zadnji koeficient v seznamu\r\nmora biti neni\u010delen.", 
      "language": 2, 
      "title": "Polinomi", 
      "timestamp": "2012-12-12 08:54:44", 
      "author": 1, 
      "problem_set": 14, 
      "preamble": ""
    }
  }, 
  {
    "pk": 58, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Iteratorji in generatorji", 
      "timestamp": "2012-11-07 13:43:55", 
      "author": 1, 
      "problem_set": 14, 
      "preamble": ""
    }
  }, 
  {
    "pk": 281, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "\u010ce \u017eelimo opazovati splo\u0161no gibanje spremenljivke, katere vrednosti\r\nprecej nihajo, na primer trenutna poraba goriva, si lahko pomagamo z\r\n[drse\u010dimi sredinami](http://en.wikipedia.org/wiki/Moving_average).\r\n\r\nRecimo, da senzor za porabo goriva nameri slede\u010do porabo goriva\r\n(v litrih na 100 kilometrov): $13, 5, 9, 4, 5, 0, 4, 2, 3, 1$.\r\nKot vidimo, poraba na za\u010detku precej sko\u010di, potem spet pade, pa spet\r\nsko\u010di in podobno. Voznik te\u017eko spremlja tako porabo. \u010ce pa si pogledamo\r\npovpre\u010dje 1., 2. in 3. \u010dlena, potem 2., 3. in 4. \u010dlena in tako naprej,\r\npa dobimo: $9, 6, 6, 3, 3, 2, 3, 2$.\r\n\r\nTo je le najenostavnej\u0161i primer. Seveda lahko vzamemo tudi povpre\u010dje\r\nkakega drugega \u0161tevila \u010dlenov, ali pa celo ute\u017eeno povpre\u010dje, pri\r\nkaterem nekateri \u010dleni bolj prispevajo k vrednosti kot drugi.", 
      "language": 1, 
      "title": "Drse\u010de sredine", 
      "timestamp": "2013-01-16 11:35:47", 
      "author": 346, 
      "problem_set": 17, 
      "preamble": ""
    }
  }, 
  {
    "pk": 178, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "\u0160ahovnice", 
      "timestamp": "2012-03-05 11:51:28", 
      "author": 161, 
      "problem_set": 64, 
      "preamble": ""
    }
  }, 
  {
    "pk": 292, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Za za\u010detek malo definicij:\n\n* _Sprehod na premici_ je zaporedje korakov, od katerih gre vsak za eno\n  enoto v levo ali v desno.\n* _Sprehod v ravnini_ je zaporedje korakov, od katerih gre vsak za eno\n  enoto v levo, v desno, navzgor ali navzdol.\n* Podobno lahko definiramo _sprehode v prostorih_ vi\u0161jih dimenzij: na\n  na vsakem koraku se premaknemo za $+e_i$ ali $-e_i$, kjer je $e_i$\n  naklju\u010dno izbrani enotski vektor.\n* _Naklju\u010dni sprehod_ je sprehod, pri katerem se na vsakem koraku z\n  enako verjetnostjo naklju\u010dno odlo\u010dimo za eno od smeri.\n\n\u0160e to: nobena od nalog ni opremljena s testi, zato boste morali sami\npreveriti, da va\u0161e re\u0161itve delujejo pravilno.", 
      "language": 1, 
      "title": "Naklju\u010dni sprehodi", 
      "timestamp": "2012-12-07 20:37:16", 
      "author": 1, 
      "problem_set": 27, 
      "preamble": ""
    }
  }, 
  {
    "pk": 81, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Ustvarjanje dreves", 
      "timestamp": "2011-12-15 11:28:09", 
      "author": 19, 
      "problem_set": 29, 
      "preamble": "class Drevo:\n\n    def __init__(self, *args, **kwargs):\n        if args:\n            self.prazno = False\n            self.vsebina = args[0]\n            self.levo = kwargs.get('levo', Drevo())\n            self.desno = kwargs.get('desno', Drevo())\n        else:\n            self.prazno = True\n\n    def __repr__(self, zamik = ''):\n        if self.prazno:\n          return 'Drevo()'.format(zamik)\n        elif self.levo.prazno and self.desno.prazno:\n          return 'Drevo({1})'.format(zamik, self.vsebina)\n        else:\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\n            format(\n              zamik,\n              self.vsebina,\n              self.levo.__repr__(zamik + '             '),\n              self.desno.__repr__(zamik + '              ')\n            )\n\n    def __eq__(self, other):\n        return ((self.prazno and other.prazno) or\n                (not self.prazno and not other.prazno and\n                 self.vsebina == other.vsebina and\n                 self.levo == other.levo and\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 91, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Pretvornik iz \u20ac v $", 
      "timestamp": "2013-01-18 13:52:54", 
      "author": 19, 
      "problem_set": 33, 
      "preamble": ""
    }
  }, 
  {
    "pk": 105, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Problem Hanojskih stolpov je slede\u010d: imamo tri palice z oznakami `A`,\n`B` in `C`, na katerih je nataknjenih `n` diskov razli\u010dnih velikosti,\npri \u010demer disk nikoli ne sme biti polo\u017een na manj\u0161ega. Na za\u010detku so\nvsi diski nataknjeni na palico `A`, naloga pa je, da vse prestavimo na\npalico `C`, pri \u010demer lahko premaknemo samo en disk naenkrat, prav tako\npa moramo paziti na urejenost diskov.", 
      "language": 2, 
      "title": "Hanojski stolpi", 
      "timestamp": "2012-05-20 20:51:05", 
      "author": 1, 
      "problem_set": 40, 
      "preamble": ""
    }
  }, 
  {
    "pk": 71, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "HTML", 
      "timestamp": "2011-12-04 08:27:29", 
      "author": 1, 
      "problem_set": 24, 
      "preamble": "import re\r\n\r\ndef kopija(vhod, izhod):\r\n    with open(vhod) as f:\r\n        s = f.read()\r\n    with open(izhod, 'w') as g:\r\n        g.write(s)"
    }
  }, 
  {
    "pk": 101, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Min in max", 
      "timestamp": "2013-02-25 04:05:49", 
      "author": 1, 
      "problem_set": 39, 
      "preamble": "import random\nimport math\n\ndef izvedi(source, d):\n    import io, sys\n    old_stdout = sys.stdout\n    new_stdout = io.StringIO()\n    sys.stdout = new_stdout\n    exec(source, d)\n    sys.stdout = old_stdout\n    return (d, new_stdout.getvalue())\n\n(margarina, moka, sladkor) = (0,)*3"
    }
  }, 
  {
    "pk": 251, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "\u0160tevilo \u010drk", 
      "timestamp": "2013-01-15 20:20:34", 
      "author": 1, 
      "problem_set": 77, 
      "preamble": "def _istedatoteke(ena,dva):\r\n    '''Primerja rezultat v datoteki 'ena' s pravilnim rezultatom v datoteki 'dva' '''\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)"
    }
  }, 
  {
    "pk": 41, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Na\u010deloma za predstavitev matrik v Pythonu uporabimo modul\n[array](http://docs.python.org/py3k/library/array.html),\na mi jih bomo predstavili kar s seznami seznamov.\n[Hilbertovo matriko](http://sl.wikipedia.org/wiki/Hilbertova_matrika)\nbi tako zapisali s seznamom `[[1, 1/2], [1/2, 1/3]]`.\n\nPredpostavite lahko, da imajo vse matrike vsaj en element in\nda imajo vsi podseznami enako dol\u017eino, ne smete pa predpostaviti,\nda so vse matrike kvadratne.", 
      "language": 2, 
      "title": "Matrike", 
      "timestamp": "2012-02-07 11:02:15", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": "_mat = [[i ** 2 + 3 * j for i in range(8)] for j in range(8)]"
    }
  }, 
  {
    "pk": 62, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Dan naj bo razred `Drevo`, ki predstavlja dvoji\u0161ko drevo.", 
      "language": 2, 
      "title": "Ustvarjanje dreves", 
      "timestamp": "2011-11-24 12:30:46", 
      "author": 1, 
      "problem_set": 20, 
      "preamble": "class Drevo:\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        if args:\r\n            self.prazno = False\r\n            self.vsebina = args[0]\r\n            self.levo = kwargs.get('levo', Drevo())\r\n            self.desno = kwargs.get('desno', Drevo())\r\n        else:\r\n            self.prazno = True\r\n\r\n    def __repr__(self, zamik = ''):\r\n        if self.prazno:\r\n          return 'Drevo()'.format(zamik)\r\n        elif self.levo.prazno and self.desno.prazno:\r\n          return 'Drevo({1})'.format(zamik, self.vsebina)\r\n        else:\r\n          return 'Drevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\r\n            format(\r\n              zamik,\r\n              self.vsebina,\r\n              self.levo.__repr__(zamik + '             '),\r\n              self.desno.__repr__(zamik + '              ')\r\n            )\r\n\r\n    def __eq__(self, other):\r\n        return ((self.prazno and other.prazno) or\r\n                (not self.prazno and not other.prazno and\r\n                 self.vsebina == other.vsebina and\r\n                 self.levo == other.levo and\r\n                 self.desno == other.desno))"
    }
  }, 
  {
    "pk": 108, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Intervali", 
      "timestamp": "2012-03-12 09:54:57", 
      "author": 1, 
      "problem_set": 41, 
      "preamble": ""
    }
  }, 
  {
    "pk": 225, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Delnice", 
      "timestamp": "2012-06-10 22:42:01", 
      "author": 1, 
      "problem_set": 71, 
      "preamble": ""
    }
  }, 
  {
    "pk": 119, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Me\u0161anje seznamov", 
      "timestamp": "2012-03-30 12:04:48", 
      "author": 1, 
      "problem_set": 44, 
      "preamble": ""
    }
  }, 
  {
    "pk": 129, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 3", 
      "timestamp": "2012-05-04 09:30:47", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "import random\r\nfrom time import clock\r\nimport inspect\r\n\r\nkarte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0161kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n\r\ndef unija(s):\r\n    x=set()\r\n    for i in s:\r\n        x=x.union(i)\r\n    return x\r\n\r\ndef jeenakomerna(f,a,b):\r\n    '''Preveri, da f vraca enakomerno porazdeljene vrednosti na intervalu [a,b)'''\r\n    s=[f(a,b) for i in range(1000)]\r\n    M=sum(s)/1000\r\n    V=sum([(x-M)**2/1000 for x in s])\r\n    # Povprecje enakomerno porazdeljene spr. je (a+b)/2, varianca je (b-a)^2/12\r\n    if abs((M-(a+b)/2))>0.1 or abs(V-(b-a)**2/12)>0.2:\r\n        return False\r\n    else:\r\n        return True\r\n\r\ndef nakljucna(f,*args):\r\n    random.seed(1)\r\n    return [f(*args) for i in range(10)]\r\n\r\ndef izpis(f,*args):\r\n    import io, sys\r\n    old_stdout = sys.stdout\r\n    new_stdout = io.StringIO()\r\n    random.seed(1)\r\n    sys.stdout = new_stdout\r\n    f(*args)\r\n    sys.stdout = old_stdout\r\n    return new_stdout.getvalue()"
    }
  }, 
  {
    "pk": 196, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Palindromi", 
      "timestamp": "2012-03-22 11:22:41", 
      "author": 1, 
      "problem_set": 43, 
      "preamble": ""
    }
  }, 
  {
    "pk": 23, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Vrednosti komponent spreminjamo s prireditvenim stavkom\r\n\r\n    x <- c(1, -3, 5, -7, 9, -11)\r\n    x[3] <- -5\r\n\r\nSpreminjamo lahko tudi ve\u010d vrednosti naenkrat\r\n\r\n    x[c(1, 5)] <- 2 # 1. in 5. komponento nastavimo na 2\r\n    x[c(2, 4)] <- c(60, 90) # 2. komponento nastavimo na 60, 4. pa na 90\r\n    x[x %% 3 == 0] <- 10 # vse komponente, deljive z 0, nastavimo na 10\r\n    x[x > 1] <- 100 * x[x > 1] # komponente, ve\u010dje od 1, pomno\u017eimo s 100", 
      "language": 1, 
      "title": "Spreminjanje komponent", 
      "timestamp": "2012-11-05 10:52:47", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 256, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Kadar je matrika *redka*, se pravi da ima prete\u017eno ni\u010delne elemente, je\nobi\u010dajna predstavitev potratna.\n\nObravnavajmo redko matriko\n\n    a = [[1, 0, 0, 0, 2, 0],\n         [0, 4, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5]]\n\nRedko matriko predstavimo s trojico `(d, m, n)` kjer je `d` slovar po\nkoordinatah, `m` je \u0161tevilo vrstic in `n` \u0161tevilo stolpcev.\nNa primer, zgornjo matriko `a` bi predstavili s trojico:\n\n    ({(0,0) : 1, (0,4) : 2, (1,1) : 4, (1,4): 3, (3,5) : 5}, 4, 6)\n\npri \u010demer na\u0161tejemo samo neni\u010delne elemente matrike.\n\nVse operacije z redkimi matrikami \u017eelimo narediti tako, da delamo\nneposredno s slovarji. Nikoli ne pretvarjamo redke matrike v tabelarno\nobliko, saj je to zelo neu\u010dinkovito.", 
      "language": 2, 
      "title": "Redke matrike", 
      "timestamp": "2012-10-01 12:38:43", 
      "author": 19, 
      "problem_set": 78, 
      "preamble": ""
    }
  }, 
  {
    "pk": 221, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Na vsakem zanimivem igri\u0161\u010du za golf so ovire: jezero, pesek, ...\r\n\r\n`Jezero` je krog, podan kot trojica `(x,y,r)`.\r\n`Pesek` je pravokotnik, podan kot \u010detverica`(x1,y1,x2,y2)`. Predpostavi\u0161 lahko, da \r\nso to po vrsti koordinate levega spodnjega in desnega zgornjega ogli\u0161\u010da.", 
      "language": 2, 
      "title": "Golf", 
      "timestamp": "2012-06-10 15:59:41", 
      "author": 1, 
      "problem_set": 70, 
      "preamble": "def _makefile1(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"1 90\", file=f)\r\n        print(\"2 -30\", file=f)\r\n        print(\"2 210\", file=f)\r\n        print(\"1 90\", file=f)\r\n\r\ndef _makefile2(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"0.000 1.000\", file=f)\r\n        print(\"1.732 0.000\", file=f)\r\n        print(\"0.000 -1.000\", file=f)\r\n        print(\"0.000 0.000\", file=f)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)"
    }
  }, 
  {
    "pk": 9, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Socialno omre\u017eje zaljubljenosti podamo s slovarjem, ki ime osebe\npreslika v mno\u017eico vseh, v katere je oseba zaljubljena (ena oseba\nje lahko zaljubljena v ve\u010d oseb). Na primer, slovar\n\n    s = {'Ana' : {'Bine','Cene'},\n         'Bine' : set(),\n         'Cene' : {'Bine'},\n         'Davorka' : {'Davorka'},\n         'Eva' : {'Bine'}}\n\nnam pove, da je Ana zaljubljena v Bineta in Cenete, Bine ni\nzaljubljen, Cene ljubi Bineta, Davorka samo sebe in Eva Bineta.", 
      "language": 2, 
      "title": "Ljubezen nam je vsem v pogubo", 
      "timestamp": "2012-10-11 12:16:47", 
      "author": 19, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 273, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Tabele", 
      "timestamp": "2012-12-10 13:47:12", 
      "author": 1, 
      "problem_set": 83, 
      "preamble": ""
    }
  }, 
  {
    "pk": 240, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Antipalindromi", 
      "timestamp": "2012-07-14 21:25:49", 
      "author": 1, 
      "problem_set": 74, 
      "preamble": ""
    }
  }, 
  {
    "pk": 185, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "\u010ce pri algoritmu Push-Relabel vedno izberemo aktivno to\u010dko z najve\u010djo\nrazdaljno ozna\u010ditvijo, lahko problem maksimalnega pretoka re\u0161imo v \u010dasu\n$O(n^2 \\sqrt{m})$, kjer je $n$ \u0161tevilo vozli\u0161\u010d in $m$ \u0161tevilo povezav.\n\nDa u\u010dinkovito sledimo aktivni to\u010dki, v algoritmu vzdr\u017eujemo:\n\n1. sezname $L_i$ (za $i = 1, 2, \\dots, 2n - 1$), ki hranijo indekse aktivnih\n   to\u010dk z razdaljno ozna\u010ditvijo $i$,\n2. indeks $i_{\\max}$ zadnjega nepraznega seznama,\n3. sezname $A_u$ (za $u \\neq s, t$), ki vsebujejo vse tiste dopustne povezave\n   pridru\u017eenega omre\u017eja $G_f$, ki se za\u010dnejo v $u$ \u2013 torej povezave, po\n   katerih lahko naredimo Push.\n\nVzdr\u017eevanje poteka na slede\u010d na\u010din:\n\n* pri koraku $Push(e)$ lo\u010dimo dva primera:\n\n    1. \u010de je bil klic nasi\u010den (zapolni kapaciteto $e$, torej je $u_f(e) = 0$),\n       iz seznama $A_u$ pobri\u0161emo $e$,\n    2. \u010de je bil klic nenasi\u010den ($u$ po klicu ni ve\u010d aktivno vozli\u0161\u010de), iz\n       seznama $L_{i_\\max}$ pobri\u0161emo $u$ in ponovno izra\u010dunamo $i_\\max$.\n\n    V obeh primerih moramo pogledati, ali smo dobili novo aktivno vozli\u0161\u010de in\n    po potrebi raz\u0161iriti seznam $L_{i_\\max - 1}$.\n\n* pri koraku $Relabel(u)$ to\u010dko $u$ prestavimo v nov seznam ter s sprehodom po\n  povezavah v $G$ ponovno izra\u010dunamo $A_u$.", 
      "language": 2, 
      "title": "Izbolj\u0161ava Goldberg-Tarjanovega algoritma", 
      "timestamp": "2012-03-20 16:37:08", 
      "author": 1, 
      "problem_set": 63, 
      "preamble": "from tkinter import *\nfrom math import *\n\nclass Tocka():\n\n    def __init__(self, oznaka, x, y, vrednost=None):\n        self.oznaka = oznaka\n        self.vrednost = vrednost\n        self.sosedi = []\n        self.x = x\n        self.y = y\n\n    def __repr__(self):\n        vrednost = '' if self.vrednost is None else ' ({0})'.format(self.vrednost)\n        return '{0}{1} {2}'.format(self.oznaka, vrednost, self.sosedi)\n\n    def narisi(self, platno, oznaka=True):\n        platno.create_oval(self.x - 10, self.y - 10, self.x + 10, self.y + 10, fill='red')\n        if oznaka: platno.create_text(self.x + 7, self.y - 7, text=str(self.oznaka), anchor=SW)\n        if self.vrednost is not None: platno.create_text(self.x, self.y, text=str(self.vrednost))\n\n    def stopnja(self):\n        return len(self.sosedi)\n\nclass Povezava():\n\n    def __init__(self, oznaka, zacetek, konec, usmerjena=False, vrednost=None):\n        self.oznaka = oznaka\n        self.zacetek = zacetek\n        self.konec = konec\n        self.usmerjena = usmerjena\n        self.vrednost = vrednost\n\n    def __repr__(self):\n        vrednost = '' if self.vrednost is None else ' ({0})'.format(self.vrednost)\n        smer = '>' if self.usmerjena else '-'\n        return '{0}{1} {2}{3}{4}'.format(self.oznaka, vrednost, self.zacetek.oznaka, smer, self.konec.oznaka)\n\n    def narisi(self, platno, oznaka=True):\n        sx = (self.zacetek.x + self.konec.x) / 2\n        sy = (self.zacetek.y + self.konec.y) / 2\n        platno.create_line(self.zacetek.x, self.zacetek.y, self.konec.x, self.konec.y, fill='blue')\n        if self.usmerjena:\n            ax = (sx + self.konec.x) / 2\n            ay = (sy + self.konec.y) / 2\n            bx = sx + 0.95 * (ax - sx)\n            by = sy + 0.95 * (ay - sy)\n            platno.create_line(bx, by, ax, ay, fill='blue', arrow=LAST)\n        if self.vrednost is not None:\n            platno.create_rectangle(sx - 10, sy - 7, sx + 10, sy + 7, fill='white', outline='blue')\n            platno.create_text(sx, sy, text=str(self.vrednost))\n        if oznaka:\n            dx = 3 if self.vrednost is None else 10\n            dy = 3 if self.vrednost is None else 7\n            platno.create_text(sx + dx, sy - dy, text=str(self.oznaka), anchor=SW)\n\nclass Graf():\n\n    def __init__(self):\n        self.tocke = []\n        self.povezave = []\n\n    def __repr__(self):\n        return '\\n'.join([str(tocka) for tocka in self.tocke])\n\n    def narisi(self, naslov, sirina, visina, oznakeTock=True, oznakePovezav=True):\n        okno = Tk()\n        okno.title(naslov)\n        platno = Canvas(okno, width=sirina, height=visina)\n        platno.pack()\n        for e in self.povezave: e.narisi(platno, oznakePovezav)\n        for v in self.tocke: v.narisi(platno, oznakeTock)\n        okno.mainloop()\n\n    def dodajTocko(self, x, y, vrednost=None):\n        tocka = Tocka(len(self.tocke), x, y, vrednost)\n        self.tocke.append(tocka)\n        return tocka\n\n    def dodajPovezavo(self, zacetek, konec, usmerjena=False, vrednost=None):\n        povezava = Povezava(len(self.povezave), zacetek, konec, usmerjena, vrednost)\n        zacetek.sosedi.append(povezava)\n        konec.sosedi.append(povezava)\n        self.povezave.append(povezava)\n        return povezava\n\n    def odstraniTocko(self, tocka):\n        while len(tocka.sosedi) > 0: self.odstraniPovezavo(tocka.sosedi[0])\n        if tocka.oznaka < len(self.tocke) - 1:\n            self.tocke[tocka.oznaka] = self.tocke[-1]\n            self.tocke[tocka.oznaka].oznaka = tocka.oznaka\n        del self.tocke[-1]\n\n    def odstraniPovezavo(self, povezava):\n        povezava.zacetek.sosedi.remove(povezava)\n        povezava.konec.sosedi.remove(povezava)\n        if povezava.oznaka < len(self.povezave) - 1:\n            self.povezave[povezava.oznaka] = self.povezave[-1]\n            self.povezave[povezava.oznaka].oznaka = povezava.oznaka\n        del self.povezave[-1]"
    }
  }, 
  {
    "pk": 47, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Smu\u010darski skok se to\u010dkuje po naslednjih pravilih:\n\n1. \u010ce skakalec pristane na K-to\u010dki (Bloudkova velikanka jo ima pri\n120 metrih), dobi 60 to\u010dk za dol\u017eino. Za vsak meter ve\u010d/manj se\npri\u0161teje/od\u0161teje 1,8 to\u010dke. Torej bi skakalec, ki bi na Bloudkovi\nvelikanki sko\u010dil 130 metrov, dobil 78 to\u010dk.\n\n2. Vsake skok oceni pet sodnikov, vsak z oceno med 0 in 20. To\u010dke za\nslog so vsota vseh ocen razen najni\u017eje in najvi\u0161je. Torej bi skakalec,\nki so ga ocenili z ocenami 18.0, 17.5, 17.0, 19.0, in 18.5 dobil\n18.0 + 17.5 + 18.5 = 54 to\u010dk.\n\n3. Skupni izkupi\u010dek to\u010dk vsake serije je vsota to\u010dk za dol\u017eino in za\nslog. Zgornji skakalec bi torej dobil 78 + 54 = 132 to\u010dk. V resnici\nse tem to\u010dkam doda \u0161e popravke za hitrost vetra, a se s tem tokrat\nne bomo ukvarjali.\n\n4. Zmagovalec tekme je tisti, ki v dveh serijah skupno dose\u017ee\nnajve\u010d to\u010dk.\n\nV spremenljivki `rezultati` so shranjene razdalje in ocene skokov s\n[sobotne tekme](http://www.fis-ski.com/pdf/2013/JP/3788/2013JP3788RL.pdf)\nza svetovni pokal v Kuusamu na Finskem.", 
      "language": 1, 
      "title": "Smu\u010darski skoki", 
      "timestamp": "2012-12-03 14:09:30", 
      "author": 1, 
      "problem_set": 13, 
      "preamble": "rezultati <- structure(\n  c(\n    135, 126, 128.5, 121, 128, 121.5, 134.5, 125, 122.5, \n    123.5, 141, 131.5, 117, 118.5, 127.5, 129, 126.5, 127.5, 134.5, \n    136.5, 119, 121, 137.5, 126, 130.5, 136, 134.5, 131.5, 136, 115.5, \n    18.5, 18, 18, 7.5, 18, 17.5, 18, 17.5, 17.5, 18, 8.5, 17.5, 17, \n    17.5, 18.5, 17.5, 17, 18.5, 18.5, 17.5, 17, 17, 18.5, 17.5, 17.5, \n    18, 19, 18, 18, 6.5, 18.5, 17.5, 18, 17, 17.5, 17.5, 18, 17.5, \n    17.5, 17.5, 19.5, 17.5, 17.5, 17.5, 18, 18, 18, 18, 18.5, 18, \n    17, 17, 18.5, 17.5, 18, 19, 19, 18, 19.5, 16.5, 18.5, 17.5, 18, \n    17, 18, 18.5, 18, 17.5, 17.5, 18, 19, 18, 17, 17.5, 19, 18, 18, \n    18, 18.5, 19, 17.5, 17, 18.5, 18, 18, 18.5, 19, 18, 19, 16, 18.5, \n    17.5, 18.5, 17, 18, 17.5, 18, 17.5, 17, 17.5, 19, 18.5, 17, 17, \n    18.5, 18.5, 18, 18, 18.5, 17.5, 17.5, 17, 18.5, 18, 18.5, 18, \n    18.5, 18, 18.5, 17, 18, 17.5, 18, 17, 17.5, 17, 18, 17, 17, 17, \n    18.5, 17, 17, 17, 18.5, 17, 18, 18, 18, 17.5, 17, 17, 17.5, 17.5, \n    18, 18, 18.5, 17.5, 18, 16.5, 130.5, 112, 135.5, 81.5, 132, 114.5, \n    135.5, 117, 102.5, 133.5, 97, 134, 107, 129.5, 132, 117.5, 122.5, \n    116, 125.5, 118.5, 135.5, 114.5, 128.5, 130, 133, 132, 116, 122, \n    126.5, 92.5, 18.5, 17, 18.5, 13.5, 16, 17, 17.5, 14.5, 15.5, \n    18, 13.5, 18.5, 16, 17.5, 18.5, 16.5, 16.5, 17, 18, 14, 18.5, \n    17, 18, 17.5, 18, 18, 17, 17, 18, 14.5, 18.5, 17, 18.5, 14, 18, \n    16.5, 18.5, 16, 16, 18.5, 15.5, 18.5, 16.5, 17.5, 18.5, 17, 17, \n    17.5, 18.5, 16, 18.5, 17.5, 18, 17.5, 18.5, 18.5, 17.5, 17, 18, \n    14.5, 19, 16.5, 18, 14, 17.5, 16.5, 18, 15, 15.5, 18.5, 13.5, \n    19, 16.5, 18, 19, 17, 17.5, 17.5, 18.5, 15, 19, 17, 18, 17.5, \n    18, 18.5, 17, 17.5, 18, 14, 18.5, 17, 18.5, 14, 17.5, 17, 18.5, \n    16.5, 16.5, 19, 16, 18.5, 16.5, 18, 19, 17, 17.5, 17, 18.5, 16, \n    19, 17, 18, 18, 18.5, 18.5, 17.5, 17, 18.5, 14.5, 18, 16.5, 18.5, \n    14.5, 17, 16.5, 18, 16.5, 16, 18, 14.5, 18.5, 16, 17.5, 18, 16.5, \n    16.5, 17, 18.5, 15, 18.5, 17, 17.5, 17.5, 18.5, 17.5, 17, 17, \n    17.5, 15\n    ),\n  .Dim = c(30L, 6L, 2L),\n  .Dimnames = list(\n    c(\n      \"Simon Ammann\", \"Lauri Asikainen\", \"Anders Bardal\", \"Gregor Deschwanden\", \"Manuel Fettner\", \n      \"Richard Freitag\", \"Severin Freund\", \"Karl Geiger\", \"Michael Hayboeck\", \n      \"Tom Hilde\", \"Jaka Hvala\", \"Noriaki Kasai\", \"Junshiro Kobayashi\", \n      \"Martin Koch\", \"Andreas Kofler\", \"Denis Kornilov\", \"Robert Kranjec\", \n      \"Dawid Kubacki\", \"Wolfgang Loitzl\", \"Michael Neumayer\", \"Peter Prevc\", \n      \"Alexey Romashov\", \"Gregor Schlierenzauer\", \"Andreas Stjernen\", \n      \"Taku Takeuchi\", \"Dimitry Vassiliev\", \"Rune Velta\", \"Andreas Wank\", \n      \"Andreas Wellinger\", \"Vladimir Zografski\"),\n    c(\"dolzina\", \"A\", \"B\", \"C\", \"D\", \"E\"),\n    c(\"1. serija\", \"2. serija\")\n    )\n  )"
    }
  }, 
  {
    "pk": 233, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "$k$-ta $n$-terica", 
      "timestamp": "2012-07-11 09:43:21", 
      "author": 1, 
      "problem_set": 72, 
      "preamble": ""
    }
  }, 
  {
    "pk": 299, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 1, 
      "title": "Interval zaupanja", 
      "timestamp": "2012-12-17 14:01:53", 
      "author": 1, 
      "problem_set": 89, 
      "preamble": ""
    }
  }, 
  {
    "pk": 229, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "V tekstovni datoteki je zapisano, kako pridemo do zaklada.\r\nV vsaki vrstici pi\u0161e S, J, V, Z, ki pomeni pomik za 1 korak v dolo\u010deno smer.", 
      "language": 2, 
      "title": "Otok zakladov", 
      "timestamp": "2012-07-27 12:14:27", 
      "author": 1, 
      "problem_set": 69, 
      "preamble": "def _makefile1(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"S\", file=f)\r\n        print(\"S\", file=f)\r\n        print(\"Z\", file=f)\r\n        print(\"J\", file=f)\r\n        print(\"V\", file=f)\r\n        print(\"V\", file=f)\r\n        print(\"V\", file=f)\r\n\r\ndef _makefile2(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"0 1\", file=f)\r\n        print(\"0 2\", file=f)\r\n        print(\"-1 2\", file=f)\r\n        print(\"-1 1\", file=f)\r\n        print(\"0 1\", file=f)\r\n        print(\"1 1\", file=f)\r\n        print(\"2 1\", file=f)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)"
    }
  }, 
  {
    "pk": 211, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Tina za vsako hrano, ki jo poje, zapi\u0161e njeno kalori\u010dno vrednost (celo\n\u0161tevilo). Vse te podatke hrani v datoteki: podatke vsakega dne zapi\u0161e v\nsvojo vrstico, znotraj vrstice pa jih lo\u010di z vejico.", 
      "language": 2, 
      "title": "Kalorije", 
      "timestamp": "2012-05-14 06:35:19", 
      "author": 1, 
      "problem_set": 49, 
      "preamble": ""
    }
  }, 
  {
    "pk": 261, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Izbori", 
      "timestamp": "2012-11-02 11:46:39", 
      "author": 1, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 244, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Izbori", 
      "timestamp": "2012-08-27 09:32:34", 
      "author": 1, 
      "problem_set": 75, 
      "preamble": ""
    }
  }, 
  {
    "pk": 247, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "\u0160tevilo \u010drk", 
      "timestamp": "2012-09-05 09:34:51", 
      "author": 1, 
      "problem_set": 76, 
      "preamble": "def _istedatoteke(ena,dva):\n    '''Primerja rezultat v datoteki 'ena' s pravilnim rezultatom v datoteki 'dva' '''\n    with open(ena) as f1, open(dva) as f2:\n        vrste1 = f1.read().strip()\n        vrste2 = f2.read().strip()\n        if vrste1 == vrste2:\n            return True\n        else:\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\n            print(vrste1)\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\n            print(vrste2)"
    }
  }, 
  {
    "pk": 277, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Iz Pythona ste navajeni uporabljati zanko `for`, ki jo pozna tudi R.\r\n\u010ce \u017eelite nek ukaz izvesti za vsak \u010dlen `x` vektorja `v`, napi\u0161ete\r\n\r\n    for(x in v) {\r\n      ukaz\r\n    }\r\n\r\nNa primer\r\n\r\n    for(x in 1 : 10) {\r\n      cat(x, \"\\n\")\r\n    }\r\n\r\nToda pozor, zanka `for` je izjemno neu\u010dinkovita. Poglejmo, koliko \u010dasa\r\nbi sestavljali vektor `v`, sestavljen iz milijon naklju\u010dnih \u0161tevil.\r\nNajbolj\u0161a re\u0161itev je kar ukaz `v <- runif(100000)`, ki v trenutku v `v`\r\nzapi\u0161e `1000000` naklju\u010dnih \u0161tevil. Neumnej\u0161a je re\u0161itev, da najprej\r\nv `v` zapi\u0161emo `1000000` ni\u010del, nato pa eno po eno zapisujemo\r\nnaklju\u010dna \u0161tevila.\r\n\r\n    v <- numeric(1000000)\r\n    for(i in 1 : 1000000) {\r\n      v[i] <- runif(1)\r\n    }\r\n\r\nNajbolj neumna stvar, ki jo lahko naredimo, pa je ta, da za\u010dnemo s\r\npraznim vektorjem in v njega na konec dodajamo naklju\u010dna \u0161tevila.\r\n\r\n    v <- numeric(0)\r\n    for(i in 1 : 1000000) {\r\n      v <- c(v, runif(1))\r\n    }\r\n\r\nTe\u017eava je v tem, da mora ra\u010dunalnik neprestano preurejati pomnilnik.", 
      "language": 1, 
      "title": "Zanka for", 
      "timestamp": "2012-11-07 12:40:28", 
      "author": 1, 
      "problem_set": 84, 
      "preamble": ""
    }
  }, 
  {
    "pk": 303, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Kopica", 
      "timestamp": "2013-01-15 07:54:13", 
      "author": 1, 
      "problem_set": 88, 
      "preamble": ""
    }
  }, 
  {
    "pk": 305, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Ni\u010delne vsote", 
      "timestamp": "2013-01-18 13:18:01", 
      "author": 1, 
      "problem_set": 91, 
      "preamble": ""
    }
  }, 
  {
    "pk": 264, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "Za kakr\u0161nokoli resno delo z matrikami v Pythonu uporabljamo knji\u017enico\r\n[NumPy](http://numpy.scipy.org) (bomo videli, zakaj). A zaradi\r\npreprostosti jih bomo vseeno predstavili kar s seznami seznamov.\r\n\r\nZaradi enostavnej\u0161ega ra\u010dunanja bomo pri tej nalogi prav tako\r\npredpostavili, da so dimenzije vseh matrik oblike $2^k \\times 2^k$.\r\nV nasprotnem primeru bi matrike do \u017eelene velikosti dopolnili z ni\u010dlami.", 
      "language": 2, 
      "title": "Strassenovo mno\u017eenje", 
      "timestamp": "2012-11-05 13:41:58", 
      "author": 1, 
      "problem_set": 79, 
      "preamble": "import time\r\n\r\ndef obicajno_mnozenje(a, b):\r\n    \"\"\"obicajno_mnozenje(a, b) po obi\u010dajnem postopku zmno\u017ei kvadratni matriki\r\n       a in b.\"\"\"\r\n    assert len(a[0]) == len(b)\r\n    return [[sum(a[i][k] * b[k][j] for k in range(len(b)))\r\n             for j in range(len(b[0]))]\r\n             for i in range(len(a))]\r\n\r\ndef primerjaj_case(k):\r\n    \"\"\"primerjaj_case(k) po obi\u010dajnem in Strassenovem postopku zmno\u017ei dve\r\n       kvadratni matriki velikosti 2 ** k ter primerja \u010dase mno\u017eenja.\"\"\"\r\n    n = 2 ** k\r\n    mat1 = [[i + j % 7 for i in range(n)] for j in range(n)]\r\n    mat2 = [[i + j % 4 for i in range(n)] for j in range(n)]\r\n    \r\n    print(\"Mno\u017eim...\", end=\"\")\r\n    zac = time.time()\r\n    zmn = obicajno_mnozenje(mat1, mat2)\r\n    kon = time.time()\r\n    print(\"Pomno\u017eeno ({0:.6}s).\".format(kon - zac))\r\n\r\n    print(\"Mno\u017eim po Strassenovo...\", end=\"\")\r\n    zac = time.time()\r\n    stras = strassenovo_mnozenje(mat1, mat2)\r\n    kon = time.time()\r\n    print(\"Pomno\u017eeno ({0:.6}s).\".format(kon - zac))"
    }
  }, 
  {
    "pk": 304, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Dijkstrov algoritem", 
      "timestamp": "2013-01-15 08:09:35", 
      "author": 1, 
      "problem_set": 90, 
      "preamble": "primer = {'s':{'u':10, 'x':5}, 'u':{'v':1, 'x':2}, 'v':{'y':4}, 'x':{'u':3, 'v':9, 'y':2}, 'y':{'s':7, 'v':6}}"
    }
  }, 
  {
    "pk": 270, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 1, 
      "title": "Osnovno programiranje", 
      "timestamp": "2012-10-30 10:21:31", 
      "author": 1, 
      "problem_set": 17, 
      "preamble": ""
    }
  }, 
  {
    "pk": 308, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Na mobilnih aparatih je bila svoje \u010dase zelo priljubljena funkcija T9,\npri kateri si besedo napisal tako, da si za vsako \u010drko v besedi po\nenkrat pritisnil tipko, na kateri je bila.\n\nNa primer, ker je \u010drka M na \u0161tevilki 6, \u010drka A pa na 2, ste besedo\nMAMA napisali tako, da ste vtipkali 6262. Seveda bi 6262 vtipkali tudi,\n\u010de bi \u017eeleli napisati OBNA, zato je imel telefon vgrajen tudi slovar,\nv katerem je poiskal najverjetnej\u0161i zadetek.", 
      "language": 2, 
      "title": "T9", 
      "timestamp": "2013-01-16 17:02:45", 
      "author": 1, 
      "problem_set": 91, 
      "preamble": "# slovar, v katerem je vsakemi \u010drki prirejena ustrezna \u0161tevilka\nstevilke = {'a': 2, 'b': 2, 'c': 2, 'd': 3, 'e': 3, 'f': 3,\n            'g': 4, 'h': 4, 'i': 4, 'j': 5, 'k': 5, 'l': 5,\n            'm': 6, 'n': 6, 'o': 6, 'p': 7, 'q': 7, 'r': 7, 's': 7,\n            't': 8, 'u': 8, 'v': 8, 'w': 9, 'x': 9, 'y': 9, 'z': 9}"
    }
  }, 
  {
    "pk": 82, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Razred `IskalnoDrevo` je podoben razredu `Drevo`.\nNjegov konstruktor `__init__` sprejme iterator in sestavi drevo, ki\nga dobimo, \u010de elemente seznama po vrsti vstavljamo v iskalno drevo.\nRazredu smo dodali tudi metodo `pravilno`, ki vrne `True`, \u010de je\ndrevo res iskalno (torej so v levem poddrevesu vsi podatki manj\u0161i,\nv desnem pa vsi ve\u010dji od podatka v korenu).", 
      "language": 2, 
      "title": "Iskalna drevesa", 
      "timestamp": "2012-02-10 11:20:33", 
      "author": 19, 
      "problem_set": 29, 
      "preamble": "class IskalnoDrevo():\n\n    def __init__(self, vsebina = []):\n        self.prazno = True\n        for n in vsebina:\n            self.dodaj(n)\n\n    def __repr__(self, zamik = ''):\n        if self.prazno:\n          return 'IskalnoDrevo()'.format(zamik)\n        elif self.levo.prazno and self.desno.prazno:\n          return 'IskalnoDrevo({1})'.format(zamik, self.vsebina)\n        else:\n          return 'IskalnoDrevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\n            format(\n              zamik,\n              self.vsebina,\n              self.levo.__repr__(zamik + '             '),\n              self.desno.__repr__(zamik + '              ')\n            )\n\n    def pravilno(self, minimum=None, maksimum=None):\n        if self.prazno:\n            return True\n        elif minimum and self.vsebina < minimum:\n            return False\n        elif maksimum and self.vsebina > maksimum:\n            return False\n        else:\n            return (self.levo.pravilno(minimum, self.vsebina) and\n                    self.desno.pravilno(self.vsebina, maksimum))"
    }
  }, 
  {
    "pk": 201, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Krogi", 
      "timestamp": "2012-03-30 12:21:55", 
      "author": 1, 
      "problem_set": 44, 
      "preamble": "import random\ndef tocka(a,b,c,d):\n    return (a+(b-a)*random.random(), c+(d-c)*random.random())"
    }
  }, 
  {
    "pk": 222, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Binarno relacijo $R \\subseteq A \\times A$ na mno\u017eici $A$ lahko v Pythonu\r\npredstavimo z mno\u017eico parov (naborov z dvema elementoma).\r\nTako bi relacijo deljivosti na mno\u017eici \u0161tevil od 1 do 12 predstavili z\r\nmno\u017eico:\r\n\r\n    {(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),\r\n     (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12),\r\n     (2, 2), (2, 4), (2, 6), (2, 8), (2, 10), (2, 12),\r\n     (3, 3), (3, 6), (3, 9), (3, 12), (4, 4), (4, 8), (4, 12),\r\n     (5, 5), (5, 10), (6, 6), (6, 12), (7, 7), (8, 8), (9, 9),\r\n     (10, 10), (11, 11), (12, 12)}", 
      "language": 2, 
      "title": "Relacije", 
      "timestamp": "2012-07-27 12:14:34", 
      "author": 1, 
      "problem_set": 70, 
      "preamble": "# Nekaj primerov relacij (vpi\u0161ite ime v konzolo, da vidite izra\u010dunano\r\n# mno\u017eico parov)\r\nenako = {(i, i) for i in range(1, 13)}\r\nmanjse = {(i, j) for i in range(1, 13) for j in range(i + 1, 13)}\r\nvecje = {(j, i) for i in range(1, 13) for j in range(i + 1, 13)}\r\nmanjseAliEnako = {(i, j) for i in range(1, 13) for j in range(i, 13)}\r\nvecjeAliEnako = {(j, i) for i in range(1, 13) for j in range(i, 13)}\r\ndeli = {(i, j) for i in range(1, 13) for j in range(i, 13) if j % i == 0}\r\n\r\n# \u0161tevili i in j sta v relaciji istiOstanek, \u010de data isti ostanek pri\r\n# deljenju z 2, torej \u010de sta obe sodi ali pa obe lihi.\r\nistiOstanek = {(i, j) for i in range(1, 13) for j in range(1, 13)\r\n               if i % 2 == j % 2}"
    }
  }, 
  {
    "pk": 152, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 3", 
      "timestamp": "2012-05-13 08:42:52", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def izpis(f,*args):\n    import io, sys\n    old_stdout = sys.stdout\n    new_stdout = io.StringIO()\n    sys.stdout = new_stdout\n    f(*args)\n    sys.stdout = old_stdout\n    return new_stdout.getvalue()\n\ndef _makefile(ime):\n    with open(ime, \"w\") as f:\n        print('Sami \"nizi\" in \"nenizi\"', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('\"celotna vrstica en sam niz\"', file=f)\n        print('\"niz na zacetku\" in \"na koncu\"', file=f)\n\ndef _makefile1(ime):\n    with open(ime, \"w\") as f:\n        print('Sami \"nizi\" in \\\\\"nenizi\\\\\", pa \"do\\\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en \"kratek\\\\\"', file=f)\n        print('spet \\\\\"niz na zacetku', file=f)\n        print('in \"na koncu\"spet\\\\\"', file=f)\n        print('in \"niz\"\"do niza\" pa \\\\\"\"kratek\"\\\\\"', file=f)\n\ndef _makefile2(ime):\n    with open(ime, \"w\") as f:\n        print('nizi\\nnenizi\\\\\\ndo\\\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\\nkratek\\\\', file=f)\n        print('niz na zacetku', file=f)\n        print('in \\nspet\\\\', file=f)\n        print('niz\\ndo niza\\n\\\\', file=f)\n        \ndef _makefile3(ime):\n    with open(ime, \"w\") as f:\n        print('nizi', file=f)\n        print('do\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\n        print('na koncu\\nniz\\ndo niza\\nkratek', file=f)\n\ndef _makefile4(ime):\n    with open(ime, \"w\") as f:\n        print('nizi', file=f)\n        print('do\\lgi', file=f)\n        print('Vrstica brez nizov', file=f)\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\n        print('na koncu\\nniz\"do niza\\nkratek', file=f)\n        \ndef _istedatoteke(ena,dva,original=None):\n    with open(ena) as f1, open(dva) as f2:\n        n1=f1.read().strip()\n        n2=f2.read().strip()\n        if n1 != n2:\n            if original != None:\n                print(\"Vhodna datoteka:\\n\"+'-'*50)\n                with open(original) as f3:\n                    print(f3.read())\n                print('-'*50)\n            print(\"Rezultat tvoje funkcije:\")\n            print(n1)\n            print(\"=\"*50+\"\\nPravilno:\")\n            print(n2)\n            return False\n        return True\n\ndef _jeblizu(a, b, eps=.1):\n    if b == 0:\n        return abs(a) < eps\n    else:\n        return abs(1-a/b) < eps\n    \ndef _removefiles(*ime):\n    import os\n    for i in ime:\n        try:\n            os.remove(i)\n        except:\n            pass\n\nfrom random import randint"
    }
  }, 
  {
    "pk": 153, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-05-04 09:30:51", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def izpis(f,*args):\r\n    import io, sys\r\n    old_stdout = sys.stdout\r\n    new_stdout = io.StringIO()\r\n    sys.stdout = new_stdout\r\n    f(*args)\r\n    sys.stdout = old_stdout\r\n    return new_stdout.getvalue()\r\n\r\ndef _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print('Sami \"nizi\" in \"nenizi\"', file=f)\r\n        print('Vrstica brez nizov', file=f)\r\n        print('\"celotna vrstica en sam niz\"', file=f)\r\n        print('\"niz na zacetku\" in \"na koncu\"', file=f)\r\n\r\ndef _makefile1(ime):\r\n    with open(ime, \"w\") as f:\r\n        print('Sami \"nizi\" in \\\\\"nenizi\\\\\", pa \"do\\\\lgi', file=f)\r\n        print('Vrstica brez nizov', file=f)\r\n        print('en sam niz\\\\\" nizi. \\\\Pa en \"kratek\\\\\"', file=f)\r\n        print('spet \\\\\"niz na zacetku', file=f)\r\n        print('in \"na koncu\"spet\\\\\"', file=f)\r\n        print('in \"niz\"\"do niza\" pa \\\\\"\"kratek\"\\\\\"', file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print('nizi\\nnenizi\\\\\\ndo\\\\lgi', file=f)\r\n        print('Vrstica brez nizov', file=f)\r\n        print('en sam niz\\\\\\nkratek\\\\', file=f)\r\n        print('niz na zacetku', file=f)\r\n        print('in \\nspet\\\\', file=f)\r\n        print('niz\\ndo niza\\n\\\\', file=f)\r\n        \r\ndef _makefile3(ime):\r\n    with open(ime, \"w\") as f:\r\n        print('nizi', file=f)\r\n        print('do\\lgi', file=f)\r\n        print('Vrstica brez nizov', file=f)\r\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\r\n        print('na koncu\\nniz\\ndo niza\\nkratek', file=f)\r\n\r\ndef _makefile4(ime):\r\n    with open(ime, \"w\") as f:\r\n        print('nizi', file=f)\r\n        print('do\\lgi', file=f)\r\n        print('Vrstica brez nizov', file=f)\r\n        print('en sam niz\\\\\" nizi. \\\\Pa en ', file=f)\r\n        print('na koncu\\nniz\"do niza\\nkratek', file=f)\r\n        \r\ndef _istedatoteke(ena,dva,original=None):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        n1=f1.read().strip()\r\n        n2=f2.read().strip()\r\n        if n1 != n2:\r\n            if original != None:\r\n                print(\"Vhodna datoteka:\\n\"+'-'*50)\r\n                with open(original) as f3:\r\n                    print(f3.read())\r\n                print('-'*50)\r\n            print(\"Rezultat tvoje funkcije:\")\r\n            print(n1)\r\n            print(\"=\"*50+\"\\nPravilno:\")\r\n            print(n2)\r\n            return False\r\n        return True\r\n\r\ndef _jeblizu(a, b, eps=.1):\r\n    if b == 0:\r\n        return abs(a) < eps\r\n    else:\r\n        return abs(1-a/b) < eps\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime:\r\n        try:\r\n            os.remove(i)\r\n        except:\r\n            pass\r\n\r\nfrom random import randint"
    }
  }, 
  {
    "pk": 230, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Za razliko od obi\u010dajnih dru\u017eabnih omre\u017eij, deluje nedru\u017eabno omre\u017eje\r\nHatebook tako, da si v omre\u017eje vsak dodaja svoje sovra\u017enike. Omre\u017eje\r\npredstavimo s slovarjem, pri \u010demer so klju\u010di osebe, vrednosti\r\npa mno\u017eice oseb, ki jih te osebe sovra\u017eijo.", 
      "language": 2, 
      "title": "Nedru\u017eabno omre\u017eje", 
      "timestamp": "2012-07-27 12:14:27", 
      "author": 1, 
      "problem_set": 69, 
      "preamble": "primerOmrezja1 = {'\u017diga': {'Zoran', 'Vesna', 'Ugo'},\r\n                  'Zoran': {'Vesna'},\r\n                  'Vesna': set(),\r\n                  'Ugo': {'Zoran', '\u017diga', 'Ugo'},\r\n                  'Tina': {'Vesna'}}\r\n\r\nprimerOmrezja2 = {'Filip': {'Betka', 'Anka'},\r\n                  'Evgen': {'Evgen', 'Darko', 'Betka'},\r\n                  'Darko': set(),\r\n                  'Cvetka': {'Darko', 'Betka'},\r\n                  'Betka': {'Anka', 'Filip'},\r\n                  'Anka': {'Anka'}}"
    }
  }, 
  {
    "pk": 253, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Datumi", 
      "timestamp": "2012-10-01 12:26:03", 
      "author": 1, 
      "problem_set": 78, 
      "preamble": ""
    }
  }, 
  {
    "pk": 279, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Mno\u017eice so v R-u predstavljene z vektorji, ki naj bi bili sestavljeni\niz razli\u010dnih \u010dlenov.\n\nZa obi\u010dajne operacije nad mno\u017eicami so vgrajene naslednje funkcije:\n`union(x, y)`, `intersect(x, y)`, `setdiff(x, y)`, `setequal(x, y)`, \n`is.element(e, x)`, kar lahko pi\u0161emo tudi kot `e %in% x`.\n\n\u010ce katero izmed zgornjih funkcij uporabimo na vektorju, ki nima samih \nrazli\u010dnih \u010dlenov, se le-ta avtomatsko spremeni v mno\u017eico (podvojitve\n\u010dlenov se torej izbri\u0161ejo).", 
      "language": 1, 
      "title": "Mno\u017eice", 
      "timestamp": "2012-11-11 21:43:17", 
      "author": 1, 
      "problem_set": 84, 
      "preamble": ""
    }
  }, 
  {
    "pk": 165, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Simon in Greta sta mlad zaljubljen par, ki pri\u010dakuje svojega prvega\r\notroka. Skrbni sorodniki jima po elektronski po\u0161ti po\u0161iljajo datoteke,\r\nv katerih jima pi\u0161ejo, kaj vse __NUJNO__ potrebujeta, \u010de \u017eelita, da njun\r\notrok zraste v zdravo, neodvisno osebnost.\r\n\r\nVsaka datoteka je sestavljena iz vrstic, v katerih pi\u0161e: ime predmeta,\r\ncena predmeta (zaokro\u017eeno na evre), nujnost (od 1 do 10, kjer je 10\r\nnajbolj nujno).\r\n\r\nPrimer nekaj vrstic:\r\n\r\n    avtomati\u010dno brisalo ritke,231,10\r\n    ljubezen,0,1\r\n    ortopedsko oblikovana duda,15,7\r\n\r\nPredpostavite lahko, da v imenu ni vejic, da okoli vejic ni presledkov,\r\nter da sta v vsaki vrstici natanko dve vejici.", 
      "language": 2, 
      "title": "Oprema za dojen\u010dka", 
      "timestamp": "2012-06-06 14:35:55", 
      "author": 1, 
      "problem_set": 58, 
      "preamble": ""
    }
  }, 
  {
    "pk": 179, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Beseda v okvir", 
      "timestamp": "2012-03-05 12:14:35", 
      "author": 161, 
      "problem_set": 64, 
      "preamble": ""
    }
  }, 
  {
    "pk": 197, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Podnizi", 
      "timestamp": "2012-03-26 12:24:13", 
      "author": 1, 
      "problem_set": 43, 
      "preamble": ""
    }
  }, 
  {
    "pk": 112, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Pra\u0161tevila", 
      "timestamp": "2012-03-14 09:55:33", 
      "author": 1, 
      "problem_set": 42, 
      "preamble": ""
    }
  }, 
  {
    "pk": 241, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Kartezi\u010dni produkt mno\u017eic $A_1 \\times A_2 \\times \\dots \\times A_n$ je\r\nmno\u017eica vseh naborov dol\u017eine $n$, pri katerih je $i$-ta komponenta iz\r\nmno\u017eice $A_i$.\r\n\r\nNa primer, kartezi\u010dni produkt mno\u017eic `{1, 2}, {3, 4, 5}, {6, 7}` je\r\nmno\u017eica\r\n\r\n    {(1, 3, 6), (1, 3, 7), (1, 4, 6), (1, 4, 7), (1, 5, 6), (1, 5, 7), \r\n     (2, 3, 6), (2, 3, 7), (2, 4, 6), (2, 4, 7), (2, 5, 6), (2, 5, 7)}", 
      "language": 2, 
      "title": "Kartezi\u010dni produkt", 
      "timestamp": "2012-07-27 12:13:55", 
      "author": 1, 
      "problem_set": 74, 
      "preamble": ""
    }
  }, 
  {
    "pk": 226, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Ponudbo trgovine lahko predstavimo s slovarjem, v katerem so klju\u010di\r\nizdelki, vrednosti pa cene. Razprodajo prav tako predstavimo s slovarjem,\r\nv katerem so klju\u010di izdelki, ki so na razprodaji, vrednosti pa so popusti\r\n(izra\u017eeni v odstotkih), na primer:\r\n`{'nogavice': 50, 'hla\u010de': 75, 'jakna': 45, 'majica': 70}`", 
      "language": 2, 
      "title": "Razprodaja", 
      "timestamp": "2012-07-06 11:31:46", 
      "author": 1, 
      "problem_set": 71, 
      "preamble": ""
    }
  }, 
  {
    "pk": 203, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Povpre\u010dja", 
      "timestamp": "2012-04-25 14:26:27", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": "_slovar = {'\u010c': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': '\u0160', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': '\u010c', 'V': 'N', 'Z': '\u017d', '\u0160': 'S', '\u017d': 'D'}\r\n_neslovar = {'\u010c': 'A', 'A': 'O', 'C': 'Z', 'B': 'N', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': '\u0160', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': '\u010c', 'V': 'N', 'Z': '\u017d', '\u0160': 'S', '\u017d': 'D'}\r\n_neslovar2 = {'X': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V', 'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F', 'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R', 'N': 'W', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G', 'T': 'X', 'V': 'N', 'Z': 'Y', 'W': 'S', 'Y': 'D'}\r\n\r\n\r\ndef _preveriinverz(a, b):\r\n    try:\r\n        for x in a:\r\n            if b[a[x]] != x:\r\n                return False\r\n        return True\r\n    except:\r\n        return False\r\n\r\ndef _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1\", file=f)\r\n        print(\"Ena A,0,1,3,2,6,2,0,5,6,3,2,1\", file=f)\r\n        print(\"Dober Clovek,3,0,1,2,0,1,5,4,3,7,8,1\", file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Janez Novak,18\", file=f)\r\n        print(\"Ena A,31\", file=f)\r\n        print(\"Dober Clovek,35\", file=f)\r\n\r\n\r\ndef _makefile3(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Ena A,0,1,3,2,6,2,0,5,6,3,2,1,31\", file=f)\r\n        print(\"Dober Clovek,3,0,1,2,0,1,5,4,3,7,8,1,35\", file=f)\r\n        print(\"Janez Novak,1,3,3,2,1,0,0,2,0,3,2,1,18\", file=f)\r\n        print(\"Povprecen Student,1.33,1.33,2.33,2.0,2.33,1.0,1.67,3.67,3.0,4.33,4.0,1.0,28.0\", file=f)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        return f1.read().strip() == f2.read().strip()\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)"
    }
  }, 
  {
    "pk": 37, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "V pomo\u010d pri re\u0161evanju nalog sta na voljo videa:\n\n* [Premetavanje elementov preko pivota](http://vimeo.com/31025494)\n* [Iskanje k-tega elementa](http://vimeo.com/31027120)", 
      "language": 2, 
      "title": "Izbiranje k-tega elementa", 
      "timestamp": "2012-10-24 09:46:15", 
      "author": 19, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 246, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Vrstice Pascalovega trikotnika", 
      "timestamp": "2012-09-05 09:37:58", 
      "author": 1, 
      "problem_set": 76, 
      "preamble": ""
    }
  }, 
  {
    "pk": 130, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-05-04 09:30:55", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "import random\r\nfrom time import clock\r\nimport inspect\r\n\r\nkarte=['I','II','III','IV','V','VI','VII','VIII','IX','X','XI','XII','XIII','XIV','XV','XVI','XVII','XVIII','XIX','XX','XXI','\u0161kis','H1','H2','H3','H4','HJ','HC','HQ','HK','D1','D2','D3','D4','DJ','DC','DQ','DK','C7','C8','C9','C10','CJ','CC','CQ','CK','S7','S8','S9','S10','SJ','SC','SQ','SK']\r\n\r\ndef unija(s):\r\n    x=set()\r\n    for i in s:\r\n        x=x.union(i)\r\n    return x\r\n\r\ndef jeenakomerna(f,a,b):\r\n    '''Preveri, da f vraca enakomerno porazdeljene vrednosti na intervalu [a,b)'''\r\n    s=[f(a,b) for i in range(1000)]\r\n    M=sum(s)/1000\r\n    V=sum([(x-M)**2/1000 for x in s])\r\n    # Povprecje enakomerno porazdeljene spr. je (a+b)/2, varianca je (b-a)^2/12\r\n    if abs((M-(a+b)/2))>0.1 or abs(V-(b-a)**2/12)>0.2:\r\n        return False\r\n    else:\r\n        return True\r\n\r\ndef nakljucna(f,*args):\r\n    random.seed(1)\r\n    return [f(*args) for i in range(10)]\r\n\r\ndef izpis(f,*args):\r\n    import io, sys\r\n    old_stdout = sys.stdout\r\n    new_stdout = io.StringIO()\r\n    random.seed(1)\r\n    sys.stdout = new_stdout\r\n    f(*args)\r\n    sys.stdout = old_stdout\r\n    return new_stdout.getvalue()"
    }
  }, 
  {
    "pk": 263, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Do komponent vektorjev lahko dostopamo tudi z njihovimi imeni. Na primer\r\n`islands` je vektor povr\u0161in najve\u010djih otokov na Zemlji. Do komponent lahko\r\ndostopamo kot poprej\r\n\r\n    islands[c(13, 16, 8)] # 13., 16. in 8. otok, urejeno po abecedi\r\n    islands[islands < 100] # otoki s povr\u0161ino, manj\u0161o od 100 kvadratnih milj\r\n\r\nali direktno po imenih\r\n\r\n    islands[\"Britain\"] # povr\u0161ina Velike Britanije\r\n    islands[c(\"Honshu\", \"Kyushu\", \"Hokkaido\", \"Shikoku\")] # Japonski otokov\r\n\r\n\u010ce imena ni, dobimo vrednost NA (not available).\r\n\r\n    islands[\"Blejski otok\"]\r\n\r\nV ozadju R uporablja vektor imen, do katerega lahko dostopamo z ukazom\r\n\r\n    names(islands)\r\n\r\nVektorje z imeni lahko s funkcijo `c` sestavimo tudi direktno\r\n\r\n    ocene <- c(mat = 4, sjk = 5, fiz = 4)\r\n    mean(ocene)\r\n    which.max(ocene)\r\n\r\nPrav tako lahko imena uporabljamo pri spreminjanju komponent\r\n\r\n    ocene[\"mat\"] <- 3\r\n    # kaj se zgodi, ko nastavite vrednost, ki je ni v vektorju?\r\n    ocene[\"bio\"] <- 5\r\n\r\nSeveda imena lahko tudi popravljamo, vendar ne na najbolj o\u010diten na\u010din.\r\nSlede\u010di ukaz javi napako, saj vektor imen nima vektorja imen.\r\n(Zadnji stavek trikrat hitro izgovori.)\r\n\r\n    names(islands)[\"Celon\"] <- \"Ceylon\"\r\n\r\nNamesto tega moramo uporabljati logi\u010dne ali pa \u0161tevil\u010dne indekse\r\n\r\n    names(islands)[names(islands) == \"Celon\"] <- \"Ceylon\"\r\n    names(islands)[11] <- \"Ceylon\"", 
      "language": 1, 
      "title": "Imena komponent", 
      "timestamp": "2012-11-05 10:52:47", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 252, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Vrstice Pascalovega trikotnika", 
      "timestamp": "2012-09-05 11:43:47", 
      "author": 1, 
      "problem_set": 77, 
      "preamble": ""
    }
  }, 
  {
    "pk": 278, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Dane imamo to\u010dke $t_1 = (x_1, y_1), \\ldots, t_n = (x_n, y_n)$ v ravnini.\r\nPoiskati \u017eelimo dve to\u010dki $t_i$ in $t_j$, da bo razdalja med njima minimalna.\r\nTo lahko re\u0161imo z metodo deli in vladaj, glej\r\n[opis na Wikipediji](http://en.wikipedia.org/wiki/Closest_pair_of_points_problem).\r\nPri re\u0161evanju naloge si lahko pomagajte z video lekcijami:\r\n\r\n* [Par najbli\u017ejih to\u010dk](http://vimeo.com/32434672) \r\n* [Par najbli\u017ejih to\u010dk, faza deli](http://vimeo.com/32434810)\r\n* [Par najbli\u017ejih to\u010dk, faza vladaj](http://vimeo.com/32435158)\r\n* [Par najbli\u017ejih to\u010dk, \u010dasovna zahtevnost](http://vimeo.com/32435263)\r\n* [Par najbli\u017ejih to\u010dk, izbolj\u0161ava](http://vimeo.com/32435495)\r\n\r\nV nadaljevanju naloge privzemimo, da so to\u010dke $t_1, \\ldots, t_n$ shranjene\r\nv tabeli `t` kot pari koordinat `(x_i, y_i)`.", 
      "language": 2, 
      "title": "Par najbli\u017ejih to\u010dk", 
      "timestamp": "2012-11-29 09:49:30", 
      "author": 19, 
      "problem_set": 79, 
      "preamble": ""
    }
  }, 
  {
    "pk": 295, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Mesar \u0160tefan", 
      "timestamp": "2012-12-10 14:11:53", 
      "author": 1, 
      "problem_set": 83, 
      "preamble": ""
    }
  }, 
  {
    "pk": 157, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-05-04 09:30:58", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def _makefile0(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"2,35,18,5,78\", file=f)\r\n        print(\"13,20\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"15,84,2,4,5,16,78,44,21\", file=f)\r\n        print(\"10,5,50,40\", file=f)\r\n\r\ndef _makefile1(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"138\", file=f)\r\n        print(\"33\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"269\", file=f)\r\n        print(\"105\", file=f)\r\n\r\n\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:                                                                                                                                                                     \r\n        print(\"28\", file=f)\r\n        print(\"16\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"30\", file=f)\r\n        print(\"26\", file=f)\r\n        print(\"22\", file=f)\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n"
    }
  }, 
  {
    "pk": 169, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Tukaj re\u0161ujete 4. nalogo", 
      "language": 2, 
      "title": "Naloga4", 
      "timestamp": "2012-02-10 14:03:32", 
      "author": 86, 
      "problem_set": 59, 
      "preamble": ""
    }
  }, 
  {
    "pk": 42, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Pogojni stavek", 
      "timestamp": "2011-11-23 14:40:57", 
      "author": 86, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 104, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Kompozitumi", 
      "timestamp": "2012-05-20 21:49:30", 
      "author": 1, 
      "problem_set": 40, 
      "preamble": ""
    }
  }, 
  {
    "pk": 191, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "V naslednjih dveh podnalogah bomo vadili raz\u0161irjeno obliko pogojnega\nstavka in gnezdene pogojne stavke. Raz\u0161irjena oblika je uporabna predvsem\ntakrat, kadar \u017eelimo raz\u010dleniti ve\u010d primerov hkrati. Sintaksa je\nnaslednja:\n\n    if pogoj1:\n        ukazi1\n    elif pogoj2:\n        ukazi2\n    elif pogoj3:\n        ...\n    else:\n        ukaziSicer\n\nV celotnem sklopu se izvede samo eden izmed sklopov ukazov (prvi sklop,\npri katerem je pogoj resni\u010den).", 
      "language": 2, 
      "title": "Ena limona, dve limoni, ... in kvadratna ena\u010dba", 
      "timestamp": "2012-03-18 19:47:16", 
      "author": 162, 
      "problem_set": 41, 
      "preamble": ""
    }
  }, 
  {
    "pk": 10, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Ena limona, dve limoni, \u2026", 
      "timestamp": "2012-02-15 10:21:05", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 186, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Naj bo $a_0$ naravno \u0161tevilo. Za vsak indeks $i$ definiramo: \u010ce je \u0161tevilo $a_i$ sodo, je $a_{i+1}=a_i/2$, sicer pa je $a_{i+1}=3a_i+1$. \r\n\r\nCollazova domneva pravi, da za vsako naravno \u0161tevilo $n$ Collatzovo zaporedje z za\u010detnim \u010dlenom $a_0=n$ vsebuje \u0161tevilo $1$. Najmanj\u0161i indeks $i$, za katerega je $a_i=1$, imenujemo indeks ustavitve Collatzovega zaporedja.", 
      "language": 2, 
      "title": "Collatzovo zaporedje", 
      "timestamp": "2012-03-19 08:36:42", 
      "author": 161, 
      "problem_set": 42, 
      "preamble": ""
    }
  }, 
  {
    "pk": 237, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Poten\u010dna mno\u017eica $P(A)$ mno\u017eice $A$ je mno\u017eica vseh podmno\u017eic\r\nmno\u017eice $A$. Ker Python ne dovoli mno\u017eic z mno\u017eicami kot elementi, bomo\r\npoten\u010dno mno\u017eico predstavili s seznamom mno\u017eic.\r\nNa primer, poten\u010dno mno\u017eico mno\u017eice `{1, 2, 3}` lahko predstavimo kot\r\n`[set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]`.", 
      "language": 2, 
      "title": "Poten\u010dna mno\u017eica", 
      "timestamp": "2012-07-27 12:13:52", 
      "author": 1, 
      "problem_set": 73, 
      "preamble": ""
    }
  }, 
  {
    "pk": 67, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 3, 
      "description": "Razred `IskalnoDrevo` je podoben razredu `Drevo`.\nNjegov konstruktor `__init__` sprejme iterator in sestavi drevo, ki\nga dobimo, \u010de elemente seznama po vrsti vstavljamo v iskalno drevo.\nRazredu smo dodali tudi metodo `pravilno`, ki vrne `True`, \u010de je\ndrevo res iskalno (torej so v levem poddrevesu vsi podatki manj\u0161i,\nv desnem pa vsi ve\u010dji od podatka v korenu).", 
      "language": 2, 
      "title": "Iskalna drevesa", 
      "timestamp": "2012-11-29 12:43:28", 
      "author": 1, 
      "problem_set": 20, 
      "preamble": "class IskalnoDrevo():\n\n    def __init__(self, vsebina = []):\n        self.prazno = True\n        for n in vsebina:\n            self.dodaj(n)\n\n    def __repr__(self, zamik = ''):\n        if self.prazno:\n          return 'IskalnoDrevo()'.format(zamik)\n        elif self.levo.prazno and self.desno.prazno:\n          return 'IskalnoDrevo({1})'.format(zamik, self.vsebina)\n        else:\n          return 'IskalnoDrevo({1},\\n{0}      levo = {2},\\n{0}      desno = {3})'.\\\n            format(\n              zamik,\n              self.vsebina,\n              self.levo.__repr__(zamik + '             '),\n              self.desno.__repr__(zamik + '              ')\n            )\n\n    def pravilno(self, minimum=None, maksimum=None):\n        if self.prazno:\n            return True\n        elif minimum and self.vsebina < minimum:\n            return False\n        elif maksimum and self.vsebina > maksimum:\n            return False\n        else:\n            return (self.levo.pravilno(minimum, self.vsebina) and\n                    self.desno.pravilno(self.vsebina, maksimum))"
    }
  }, 
  {
    "pk": 290, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Inverzije", 
      "timestamp": "2012-11-29 10:54:26", 
      "author": 1, 
      "problem_set": 79, 
      "preamble": ""
    }
  }, 
  {
    "pk": 121, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Delo s seznami", 
      "timestamp": "2012-03-30 12:07:17", 
      "author": 1, 
      "problem_set": 44, 
      "preamble": ""
    }
  }, 
  {
    "pk": 18, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Beseda je dala besedo", 
      "timestamp": "2011-11-23 14:38:01", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 199, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "V slovarju imamo shranjeno permutacijo naravnih \u0161tevil od $1$ do $n$.\nNa primer, permutacijo, ki transponira \u0161tevili $1$ in $3$, $2$ pa\npusti pri miru, zapi\u0161emo s slovarjem `{1: 3, 2: 2, 3: 1}`.", 
      "language": 2, 
      "title": "Permutacije", 
      "timestamp": "2012-05-07 01:21:59", 
      "author": 1, 
      "problem_set": 47, 
      "preamble": ""
    }
  }, 
  {
    "pk": 206, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Padavine", 
      "timestamp": "2012-04-09 22:31:45", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": "def _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Luka,Jaka\", file=f)\r\n        print(\"Luka\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Miha 3\", file=f)\r\n        print(\"Luka 2\", file=f)\r\n        print(\"Jaka 1\", file=f)\r\n\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n"
    }
  }, 
  {
    "pk": 103, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "Metoda `sort` lahko elemente seznama uredi glede na vrednosti dane\nfunkcije `key` namesto po obi\u010dajnem vrstnem redu.\n\n    >>> sez = [\"cveta\u010da\", \"por\", \"korenje\", \"koleraba\", \"zelena\"]\n    >>> sez.sort()\n    >>> sez # elementi so urejeni kot obi\u010dajno\n    ['cveta\u010da', 'koleraba', 'korenje', 'por', 'zelena']\n    >>> sez.sort(key=len) \n    >>> sez # elementi so urejeni po dol\u017eini\n    ['por', 'zelena', 'cveta\u010da', 'korenje', 'koleraba']\n    >>> sez.sort(key=lambda niz: niz[::-1])\n    >>> sez # elementi so urejene po abecedi, a glede na zadnje \u010drke\n    ['koleraba', 'zelena', 'cveta\u010da', 'korenje', 'por']", 
      "language": 2, 
      "title": "Urejanje seznamov", 
      "timestamp": "2012-05-20 21:08:52", 
      "author": 1, 
      "problem_set": 40, 
      "preamble": ""
    }
  }, 
  {
    "pk": 198, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Ban\u010dni ra\u010dun", 
      "timestamp": "2012-04-24 14:27:15", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": ""
    }
  }, 
  {
    "pk": 200, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 3", 
      "timestamp": "2012-05-04 09:31:01", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": ""
    }
  }, 
  {
    "pk": 43, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Preproste naloge iz slovarjev", 
      "timestamp": "2012-11-05 17:03:08", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 131, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "HTML datoteke", 
      "timestamp": "2012-05-13 11:53:18", 
      "author": 1, 
      "problem_set": 49, 
      "preamble": ""
    }
  }, 
  {
    "pk": 213, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 5, 
      "description": "", 
      "language": 2, 
      "title": "Ruleta", 
      "timestamp": "2012-04-16 13:36:02", 
      "author": 1, 
      "problem_set": 46, 
      "preamble": ""
    }
  }, 
  {
    "pk": 202, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 5, 
      "description": "Substitucijska \u0161ifra je enostaven na\u010din \u0161ifriranja, pri katerem vsako\n\u010drko iz dane abecede zamenjamo z neko drugo \u010drko. Tako \u0161ifro predstavimo\ns slovarjem, ki ima za klju\u010de vse \u010drke iz abecede, pripadajo\u010de vrednosti\npa so \u010drke, s katerimi jih za\u0161ifriramo.\n\nTako slovar `{'A': 'B', 'C': 'C', 'B': 'D', 'D': 'A'}` pomenil, da se\n`A` za\u0161ifrira v `B`, `B` v `D`, `D` v `A`, `C` pa se ne spremeni.", 
      "language": 2, 
      "title": "\u0160ifriranje", 
      "timestamp": "2012-05-07 01:49:56", 
      "author": 1, 
      "problem_set": 47, 
      "preamble": "# V vseh spodnjih primerih bomo uporabljali nasednjo substitucijsko \u0161ifro.\nnasa_sifra = {'\u010c': 'K', 'A': 'O', 'C': 'Z', 'B': 'M', 'E': 'V',\n              'D': 'C', 'G': 'P', 'F': 'E', 'I': 'B', 'H': 'F',\n              'K': 'I', 'J': 'A', 'M': 'U', 'L': 'H', 'O': 'R',\n              'N': '\u0160', 'P': 'J', 'S': 'T', 'R': 'L', 'U': 'G',\n              'T': '\u010c', 'V': 'N', 'Z': '\u017d', '\u0160': 'S', '\u017d': 'D'}"
    }
  }, 
  {
    "pk": 19, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 5, 
      "description": "Permutacije v Pythonu lahko predstavimo s seznami naravnih \u0161tevil.\n\nNa primer, permutacijo, ki transponira \u0161tevili 1 in 3, 2 pa\npusti pri miru, zapi\u0161emo s seznamom `[3, 2, 1]`.", 
      "language": 2, 
      "title": "Permutacije", 
      "timestamp": "2011-12-01 12:13:29", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 116, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 5, 
      "description": "", 
      "language": 2, 
      "title": "Poudarjanje znakov", 
      "timestamp": "2012-03-22 11:22:54", 
      "author": 1, 
      "problem_set": 43, 
      "preamble": ""
    }
  }, 
  {
    "pk": 210, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 5, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 4", 
      "timestamp": "2012-05-04 09:31:05", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def _makefile0(fname, ime, vrednost):\r\n    with open(fname, \"w\") as f:\r\n        print(ime, file=f)\r\n        print(vrednost, file=f)\r\n\r\ndef _makefile1(fname):\r\n    with open(fname, \"w\") as f:\r\n        print(\"a\", file=f)\r\n        print(\"0\", file=f)\r\n        print(\"b\", file=f)\r\n        print(\"1\", file=f)\r\n        print(\"c\", file=f)\r\n        print(\"2\", file=f)\r\n\r\n\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"2,35,18,5,78\", file=f)\r\n        print(\"13,20\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"15,84,2,4,5,16,78,44,21\", file=f)\r\n        print(\"10,5,50,40\", file=f)\r\n\r\ndef _makefile3(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"138\", file=f)\r\n        print(\"33\", file=f)\r\n        print(\"8\", file=f)\r\n        print(\"269\", file=f)\r\n        print(\"105\", file=f)\r\n\r\n\r\n\r\ndef _makefile4(ime):\r\n    with open(ime, \"w\") as f:                                                                                                                                                                     \r\n        print(\"1 28\", file=f)\r\n        print(\"2 16\", file=f)\r\n        print(\"3 8\", file=f)\r\n        print(\"4 30\", file=f)\r\n        print(\"5 26\", file=f)\r\n        print(\"22\", file=f)\r\n\r\n\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n\r\n\r\n"
    }
  }, 
  {
    "pk": 20, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 6, 
      "description": "Na\u010deloma za predstavitev matrik v Pythonu uporabimo modul `array`,\na mi jih bomo predstavili kar s seznami seznamov.\n[Hilbertovo matriko](http://sl.wikipedia.org/wiki/Hilbertova[[i ** 2 + 3 * j for i in range(8)] for j in range(8)]rika)\nbi tako zapisali s seznamom `[[1, 1/2], [1/2, 1/3]]`.\n\nPredpostavite lahko, da imajo vse matrike vsaj en element in\nda imajo vsi podseznami enako dol\u017eino, ne smete pa predpostaviti,\nda so vse matrike kvadratne.", 
      "language": 2, 
      "title": "Matrike", 
      "timestamp": "2012-10-11 12:20:47", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 207, 
    "model": "tomo.problem", 
    "fields": {
      "_order": 6, 
      "description": "", 
      "language": 2, 
      "title": "Naslov 7", 
      "timestamp": "2012-04-26 10:38:20", 
      "author": 1, 
      "problem_set": 62, 
      "preamble": "def _makefile(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Luka,Jaka\", file=f)\r\n        print(\"Luka\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n        print(\"Miha\", file=f)\r\n\r\ndef _makefile2(ime):\r\n    with open(ime, \"w\") as f:\r\n        print(\"Miha 3\", file=f)\r\n        print(\"Luka 2\", file=f)\r\n        print(\"Jaka 1\", file=f)\r\n\r\n\r\ndef _istevseenodatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = [l.strip() for l in f1.readlines()]\r\n        vrste1.sort()\r\n        vrste2 = [l.strip() for l in f2.readlines()]\r\n        vrste2.sort()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n\r\ndef _istedatoteke(ena,dva):\r\n    with open(ena) as f1, open(dva) as f2:\r\n        vrste1 = f1.read().strip()\r\n        vrste2 = f2.read().strip()\r\n        if vrste1 == vrste2:\r\n            return True\r\n        else:\r\n            print(\"Izhodna datoteka vsebuje naslednje vrstice: \")\r\n            print(vrste1)\r\n            print(\"Morala pa bi vsebovati naslednje vrstice: \")\r\n            print(vrste2)\r\n    \r\ndef _removefiles(*ime):\r\n    import os\r\n    for i in ime: os.remove(i)\r\n"
    }
  }
]