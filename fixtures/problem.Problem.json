[
  {
    "pk": 4, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Razdalje med to\u010dkami", 
      "timestamp": "2011-10-13 12:42:23", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 16, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "Funkcije definiramo kot\n\n    ime.funkcije <- function(argumenti) {\n      definicija\n    }\n\nNa\u010deloma je vrednost funkcije enaka vrednosti zadnjega izraza v njeni\ndefiniciji. \u010ce pa \u017eelimo, pa lahko rezultat funkcije vrnemo z ukazom\n`return(rezultat)`. Ukaz `return` vrne rezultat ter kon\u010da izvajanje\nfunkcije.\n\nNa primer, kvadratno funkcijo bi definirali kot\n\n    kvadrat <- function(x) {\n      x ^ 2\n    }\n\nlahko pa tudi kot\n\n    kvadrat <- function(x) {\n      return(x ^ 2)\n    }\n\nFunkcije lahko sprejmejo tudi ve\u010d argumentov, na primer:\n\n    povprecje <- function(x, y) {\n      (x + y) / 2\n    }\n\nTako kot v Pythonu so nekateri argumenti lahko tudi neobvezni.\nDolo\u010dimo jih s tem, da jim pripi\u0161emo privzeto vrednost, na primer:\n\n    eksponentna <- function(x, baza = 2.718281828) {\n      baza ^ x\n    }\n\nTake funkcije lahko kli\u010demo:\n1. kot obi\u010dajno: `eksponentna(3, 2)` vrne `8`;\n2. brez neobveznih argumentov: `eksponentna(3)` vrne `20.08554`;\n3. s poimenovanimi argumenti: `eksponentna(2, baza = 3)` vrne `9`.", 
      "language": 1, 
      "title": "Funkcije", 
      "timestamp": "2011-10-24 21:14:53", 
      "author": 1, 
      "problem_set": 4, 
      "preamble": ""
    }
  }, 
  {
    "pk": 21, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "Osnovne vektorje pi\u0161emo kot `c(x1, x2, ...)`\r\n\r\n     c(1, 2, 3, 4, 5, 6, 7)\r\n\r\nV resnici je `c` ukaz, ki ve\u010d vektorjev stakne v enega, in zgornji zapis\r\npredstavlja le stikanje ve\u010d vektorjev dol\u017eine 1.\r\n\r\n     c(c(1, 2, 3), c(4, 5, 6))\r\n\r\nZa ustvarjanje novih vektorjev nam je na voljo veliko ukazov\r\n\r\n     1 : 10        # \u0161tevila od 1 do 10\r\n     10 : 1        # \u0161tevila od 10 do 1\r\n     seq(1, 10, 2) # \u0161tevila od 1 do 10 z razmakom 2\r\n     rep(5, 10)    # 10 kopij \u0161tevila 5\r\n\r\n\u010ce izpis vektorja sega \u010dez rob okna, nam \u0161tevilka v oglatih oklepajih na\r\nza\u010detku vsake vrstice pove trenutni indeks. Sedaj veste, kaj pomeni `[1]`.\r\n\r\n     1 : 100\r\n\r\nObi\u010dajne matemati\u010dne operacije brez sprememb delujejo tudi na vektorjih.\r\n\r\n     2 * (1 : 10)\r\n     3 + rep(5, 10)\r\n     1 : 5 + seq(50, 10, -10)\r\n     1 : 10 ^ 2\r\n     (-5 : 5) > 0\r\n\r\n\u010ce je en vektor kraj\u0161i od drugega, se cikli\u010dno dopolni do dalj\u0161e dol\u017eine.\r\nV primeru, ko dalj\u0161a dol\u017eina ni ve\u010dkratnik kraj\u0161e, dobimo opozorilo.\r\n\r\n     c(1, 2, 3, 4) + c(10, 20)\r\n     c(1, 2, 3, 4) + c(10, 20, 10, 20)\r\n     c(1, 2, 3, 4) + c(10, 20, 30)\r\n\r\nR pozna ogromno funkcij, ki delujejo na vektorjih. Kaj po\u010dnejo?\r\n\r\n     sum(1 : 36)\r\n     prod(1 : 10)\r\n     mean(c(4, 3, 2, 4, 3, 3, 5))", 
      "language": 1, 
      "title": "Osnovni gradniki vektorjev", 
      "timestamp": "2011-10-17 12:43:25", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 1, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "Tako kot lani pri Uvodu v Programiranje, boste tudi letos naloge\r\nre\u0161evali s pomo\u010djo Toma.\r\n", 
      "language": 1, 
      "title": "Delo s Tomom", 
      "timestamp": "2011-10-26 10:56:58", 
      "author": 1, 
      "problem_set": 1, 
      "preamble": ""
    }
  }, 
  {
    "pk": 25, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "\nPred re\u0161evanjem naloge si oglejte lekcijo [Urejanje z izbiranjem](http://vimeo.com/30661029).\nPozor, video vsebuje re\u0161itev naloge. \u010ce \u017eelite nalogo re\u0161iti samostojno, video\nprekinite takoj, ko razumete, kako deluje algoritem. Pa \u0161e to: re\u0161itev iz videa _ne_ deluje pravilno!", 
      "language": 2, 
      "title": "Urejanje z izbiranjem", 
      "timestamp": "2011-10-20 08:54:02", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 36, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 2, 
      "title": "Bisekcija z dvema tabelama", 
      "timestamp": "2011-10-24 12:12:36", 
      "author": 19, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 28, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "Za\u017eeni razvojno okolje IDLE za Python 3 in re\u0161i naslednje\r\nnaloge.\r\n", 
      "language": 2, 
      "title": "Razvojno okolje Idle in osnove Pythona", 
      "timestamp": "2011-10-19 15:01:14", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 38, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "", 
      "language": 1, 
      "title": "Funkcije kot argumenti", 
      "timestamp": "2011-10-25 08:29:31", 
      "author": 1, 
      "problem_set": 10, 
      "preamble": ""
    }
  }, 
  {
    "pk": 39, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "\n\nMatriko obi\u010dajno predstavimo kot dvojno tabelo (tabelo tabel), kar\npa je potratno, \u010de je matrika *redka*, se pravi da ima prete\u017eno\nni\u010delne elemente.\n\nObravnavajmo redko matriko\n\n    a = [[1, 0, 0, 0, 2, 0],\n         [0, 4, 0, 0, 3, 0],\n         [0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 5]]\n\nPredstavimo jo lahko na tri na\u010dine:\n\n* **Slovar po koordinatah**, ki preslika pare indeksov v pozicije:\n\n        { (0,0) : 1, (0,4) : 2, (1,1) : 4, (1,4): 3, (3,5) : 5 }\n\n* **Slovar po vrsticah**, ki preslika neni\u010delne vrstice v slovarje, ki slikajo\n  neni\u010delne stolpce v vrednosti:\n\n        { 0 : {0 : 1, 4 : 2}, 1 : {1 : 4, 4 : 3}, 3 : {5 : 5} }\n \n* **Slovar po stolpcih**, ki preslika neni\u010delne stolpce v slovarje, ki\n  slikajo neni\u010delne vrstice v vrednosti;\n\n        { 0 : {0 : 1}, 1 : {1 : 4}, 4 : {0 : 2, 1 : 3}, 5 : {3 : 5} }\n\nRedko matriko predstavimo s trojico `(d,m,n)` kjer je `d` slovar po koordinatah,\n`m` je \u0161tevilo vrstic in `n` \u0161tevilo stolpcev. Na primer, zgornjo matriko `a`\nbi predstavili s trojico\n\n    ({(0,0) : 1, (0,4) : 2, (1,1) : 4, (1,4): 3, (3,5) : 5}, 4, 6)\n\nV\u010dasih bomo potrebovali tudi predstavitve redkih matrik s slovarji po\nvrsticah ali stolpcih.", 
      "language": 2, 
      "title": "Pretvarjanje med predstavitvami redkih matrik", 
      "timestamp": "2011-10-26 00:47:29", 
      "author": 19, 
      "problem_set": 11, 
      "preamble": ""
    }
  }, 
  {
    "pk": 33, 
    "model": "problem.problem", 
    "fields": {
      "_order": 0, 
      "description": "\u010ce vektorju nastavimo dimenzije, postane matrika, kjer gredo elementi\r\nnajprej od zgoraj navzdol, nato pa od leve proti desni.\r\n    \r\n    x <- 1 : 100\r\n    dim(x) <- c(5, 20) # x naj bo matrika dimenzije 5 \u00d7 20\r\n    x\r\n    dim(x) <- c(10, 10) # x naj bo matrika dimenzije 10 \u00d7 10\r\n    x\r\n\r\nMatrike na\u010deloma sestavljamo z ukazom `matrix`, ki sprejme vektor\r\nkomponent ter \u0161tevilo vrstic in stolpcev.\r\n\r\n    matrix(1 : 100, 10, 10)\r\n    matrix(1 : 10, 20, 5) # spet velja cikli\u010dno dopolnjevanje\r\n\r\nPodatki se na\u010deloma polnijo po stolpcih, s parametrom `byrow=TRUE` pa jih\r\nlahko polnimo tudi po vrsticah.\r\n\r\n    matrix(1 : 10, 20, 5, byrow=TRUE)\r\n    \r\nDo elementov dostopamo tako kot poprej, le da indekse lo\u010dimo z vejicami\r\n\r\n    x[10, 5]            # element v 10. vrstici in 5. stolpcu\r\n    x[c(4, 6), c(5, 9)] # elementi v 4. in 6. vrstici ter 5. in 9. stolpcu\r\n    x[4 : 6, 5 : 9]     # elementi od 4. do 6. vrstice ter od 5. do 9. stolpca\r\n    c(x[4, 5], x[6, 9]) # elementa v 4. vrstici in 5. stolpcu\r\n                        # ter v 6. vrstici in 9. stoplcu.\r\n    \r\n\u010ce indeksa ne podamo, vzamemo vse elemente\r\n\r\n    x[5, ] # vsi elementi v 5. vrstici\r\n    x[, 6] # vsi elementi v 6. stoplcu\r\n    \r\nUkaza `row` in `col` vrneta matriko indeksov vrstic in stolpcev.\r\nUkaza sta uporabna predvsem v indeksnih vektorjih\r\n\r\n    x[row(x) %in% c(2, 3, 5, 7)] # vsi elementi v 2., 3., 5. in 7. vrstici\r\n    x[row(x) == col(x)]          # vsi elementi na diagonali\r\n    x[row(x) == col(x) + 1]      # vsi elementi pod diagonalo\r\n    x[row(x) == col(x) - 1]      # vsi elementi nad diagonalo\r\n    \r\nSeveda spreminjanje dimenzij ni najbolj pameten na\u010din ustvarjanja matrik\r\nVe\u010d vektorjev enake dol\u017eine lahko zlo\u017eimo v matriko po vrsticah z ukazom\r\n`rbind` ali po stolpcih z ukazom `cbind`.\r\n\r\n    ocene <- rbind(Miha = c(mat = 5, sjk = 3, fiz = 3),\r\n                   Maja = c(mat = 4, sjk = 5, fiz = 4))\r\n    ocene[\"Miha\", \"mat\"]\r\n    \r\nPozor: veljajo imena stolpcev prvega vnosa:\r\n\r\n    ocene <- rbind(Miha = c(mat = 5, sjk = 3, fiz = 3),\r\n                   Maja = c(kem = 4, bio = 5, geo = 4))\r\n    \r\n\u010ce ukaz `rbind` (ali `cbind`) uporabimo na spremenljivkah, se njihova imena\r\nuporabijo za imena stolpcev.\r\n    \r\n    visine <- c(168, 197, 162, 174, 195, 167, 175, 159, 172, 182, 181, 176)\r\n    mase <- c(84, 70, 48, 74, 64, 73, 84, 88, 68, 71, 63, 68)\r\n    podatki <- cbind(visine, mase)\r\n\r\n\r\n\u010ce je komponenta matrike odvisna le od koordinat, si lahko pomagamo s\r\nfunkcijo `outer`. \r\n\r\nPo\u0161tevanko tako dobimo z ukazom\r\n\r\n    outer(1 : 10, 1 : 10, \"*\") # simbole predstavimo z nizi\r\n    \r\nmatriko binomskih koeficientov pa z\r\n\r\n    outer(0 : 10, 0 : 10, choose)\r\n\r\nFunkcija, ki jo kli\u010demo, mora delovati na vektorjih,\r\nvendar ve\u010d o tem naslednji\u010d.", 
      "language": 1, 
      "title": "Matrike", 
      "timestamp": "2011-10-26 08:38:39", 
      "author": 1, 
      "problem_set": 8, 
      "preamble": ""
    }
  }, 
  {
    "pk": 37, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "V pomo\u010d pri re\u0161evanju nalog sta na voljo videa:\r\n\r\n* [Premetavanje elementov preko pivota](http://vimeo.com/31025494)\r\n* [Iskanje k-tega elementa](http://vimeo.com/31027120)\r\n", 
      "language": 2, 
      "title": "Izbiranje k-tega elementa", 
      "timestamp": "2011-10-24 18:15:56", 
      "author": 19, 
      "problem_set": 9, 
      "preamble": ""
    }
  }, 
  {
    "pk": 17, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "Krmilni stavki v R-ju se obna\u0161ajo podobno kot v Pythonu.\nPogojni stavek napi\u0161emo kot:\n\n    if(pogoj) {\n      ukazi, ki se izvedejo, \u010de pogoj dr\u017ei\n    } else {\n      ukazi, ki se izvedejo, \u010de pogoj ne dr\u017ei\n    }\n\nZanka `while` prav tako deluje podobno kot v Pythonu:\n\n    while(pogoj) {\n      ukazi, ki se izvajajo, dokler pogoj dr\u017ei\n    }\n\nPoleg zanke `while` R pozna tudi zanko `repeat`, ki se obna\u0161a tako kot\nzanka `while`, v kateri je pogoj vedno enak `TRUE`.\n\u010ce \u017eelimo zaustaviti izvajanje zanke `repeat`, uporabimo ukaz `break`,\nki se obna\u0161a tako kot v Pythonu, ali pa ukaz `return`.\n\u010ce \u017eelimo sko\u010diti na naslednji korak trenutne zanke, pa uporabimo\nukaz `next`, ki se obna\u0161a tako kot `continue` v Pythonu.\n\n    prastevilo <- function(n) {\n      i <- 2\n      while(i < n) {\n        if(n %% i == 0)\n          return(FALSE)\n        i <- i + 1\n      }\n      return(TRUE)\n    }", 
      "language": 1, 
      "title": "Krmilni stavki in rekurzija", 
      "timestamp": "2011-10-24 21:14:27", 
      "author": 1, 
      "problem_set": 4, 
      "preamble": ""
    }
  }, 
  {
    "pk": 8, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "*Nepopolnost* \u0161tevila je absolutna razlika med \u0161tevilom in vsoto njegovih\r\npravih deliteljev.\r\nNa primer, nepopolnost \u0161tevila $10$ je $|10 - (1+2+5)| = 2$.\r\n", 
      "language": 2, 
      "title": "Nepopolna \u0161tevila", 
      "timestamp": "2011-10-06 09:27:38", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 40, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Osnovne operacije z redkimi matrikami", 
      "timestamp": "2011-10-26 00:55:57", 
      "author": 19, 
      "problem_set": 11, 
      "preamble": ""
    }
  }, 
  {
    "pk": 29, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "", 
      "language": 2, 
      "title": "Aritmetika", 
      "timestamp": "2011-10-26 08:53:35", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 22, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "Do komponent vektorjev dostopamo z indeksi tako, da v oglatih\r\noklepajih za vektorjem lahko na\u0161tejemo vektor \u017eelenih indeksov.\r\n\r\n    x <- 20 : 30\r\n    x[c(1, 2, 7)] # 1., 2. in 7. element\r\n    x[c(1, 2, 7, 5, 1)] # 1., 2., 7., 5. in 1. element\r\n    \r\nFunkcija order vrne vektor mest, na katera spadajo posamezne\r\nkomponente v vektorju, urejenem po velikosti. Po korakih izvedite\r\nspodnje tri ukaze. Kaj je rezultat zadnjega?\r\n\r\n    y <- c(3, 7, 1, 5, 9)\r\n    order(y)\r\n    y[order(y)]\r\n    \r\n\u010ce so indeksi negativni, na\u0161tejemo ne\u017eelene elemente.\r\n\r\n    x[c(-1, -2, -7)] # Vsi elementi razen 1., 2. in 7. elementa\r\n    \r\n\u010ce podamo vektor logi\u010dnih vrednosti, se izberejo tisti elementi, kjer je\r\npripadajo\u010da vrednost enaka `TRUE`.\r\n\r\n    x[c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE)]\r\n    \r\nNamen logi\u010dnih vektorjev v indeksih je izbor elementov, ki zado\u0161\u010dajo\r\ndanemu pogoju.\r\n\r\n    x %% 3 # vektor ostankov pri deljenju s 3 \r\n    x %% 3 == 0 # vektor, ki je TRUE tam, kjer je ostanek pri deljenju s 3 enak 0\r\n    x[x %% 3 == 0] # vsa \u0161tevila v vektorju x, ki so deljiva s 3\r\n    x[x %% 5 == 1] # vsa \u0161tevila, ki dajo pri deljenju s 5 ostanek 1\r\n\r\n\r\nDo komponent vektorjev lahko dostopamo tudi z njihovimi imeni. Na primer\r\n`islands` je vektor povr\u0161in najve\u010djih otokov na Zemlji. Do komponent lahko\r\ndostopamo kot poprej\r\n\r\n    islands[c(13, 16, 8)] # 13., 16. in 8. otok, urejeno po abecedi\r\n    islands[islands < 100] # otoki s povr\u0161ino, manj\u0161o od 100 kvadratnih milj\r\n\r\nali direktno po imenih\r\n\r\n    islands[\"Britain\"] # povr\u0161ina Velike Britanije\r\n    islands[c(\"Honshu\", \"Kyushu\", \"Hokkaido\", \"Shikoku\")] # Japonski otokov\r\n\r\n\u010ce imena ni, dobimo vrednost NA (not available).\r\n\r\n    islands[\"Blejski otok\"]\r\n\r\nVektorje z imeni lahko s funkcijo `c` sestavimo tudi direktno\r\n\r\n    ocene <- c(mat = 4, sjk = 5, fiz = 4)\r\n    mean(ocene)\r\n    which.max(ocene)", 
      "language": 1, 
      "title": "Indeksi", 
      "timestamp": "2011-10-17 18:04:40", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 26, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "\nPred re\u0161evanjem te naloge si oglejte si video lekcijo\n[Urejanje z vstavljanem](http://vimeo.com/30669299).\nPozor, video vsebuje re\u0161itev naloge, zato ga nehajte\ngledati takoj, ko razumete, kako algoritem deluje.", 
      "language": 2, 
      "title": "Urejanje z vstavljanem", 
      "timestamp": "2011-10-20 08:54:41", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 34, 
    "model": "problem.problem", 
    "fields": {
      "_order": 1, 
      "description": "Vektorji in matrike v R-ju se ne ustavijo pri dveh dimenzijah. O objektih\r\nvi\u0161jih dimenzij govorimo kot o razporeditvah. Postopek je enak.\r\n    \r\nPrvi dve dimenziji se poka\u017eeta v matri\u010dni obliki, za vse nadaljnje pri\r\nizpisu na\u0161tejemo vse mo\u017enosti.\r\n\r\n    x <- 1 : 100\r\n    dim(x) <- c(10, 5, 2)\r\n    x\r\n    \r\n    dim(x) <- c(5, 5, 2, 2)\r\n    x\r\n    \r\nDo komponent dostopamo na enak na\u010din kot prej.\r\n\r\n    x[4, , 1, ]      # elementi v 4. vrstici in indeksom 1. v 3. dimenziji.\r\n    x[, 2 : 4, , -2] # elementi od 2. do 4. stolpca in z\r\n                     # indeksom razli\u010dnim od 2 v 4. dimenziji.\r\n    x[, , , 1] <- -x[, , , 1] # negiraj elemente z indeksom 1 v 4. dimenziji\r\n    \r\nV spremenljivki `Titanic` so shranjeni podatki o pre\u017eivelih potnikih na\r\nTitaniku. Razporeditev je \u0161tiridimenzionalna.\r\nPoglejte, kaj opisuje katera dimenzija?\r\n    \r\n    Titanic[, \"Male\", , \"No\"] # \u0160tevila mo\u0161kih, ki niso pre\u017eiveli.\r\n    sum(Titanic[\"Crew\", , ,]) # Velikost celotne posadke", 
      "language": 1, 
      "title": "Razporeditve", 
      "timestamp": "2011-10-24 21:39:58", 
      "author": 1, 
      "problem_set": 8, 
      "preamble": ""
    }
  }, 
  {
    "pk": 9, 
    "model": "problem.problem", 
    "fields": {
      "_order": 2, 
      "description": "\nSocialno omre\u017eje zaljubljenosti podamo s slovarjem, ki ime osebe\npreslika v mno\u017eico vseh, v katere je oseba zaljubljena (ena oseba\nje lahko zaljubljena v ve\u010d oseb). Na primer, slovar\n\n    s = {'Ana' : {'Bine','Cene'},\n         'Bine' : set(),\n         'Cene' : {'Bine'},\n         'Davorka' : {'Davorka'},\n         'Eva' : {'Bine'}}\n\nnam pove, da je Ana zaljubljena v Bineta in Cenete, Bine ni\nzaljubljen, Cene ljubi Bineta, Davorka samo sebe in Eva Bineta.", 
      "language": 2, 
      "title": "Ljubezen nam je vsem v pogubo", 
      "timestamp": "2011-10-13 09:30:40", 
      "author": 19, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 23, 
    "model": "problem.problem", 
    "fields": {
      "_order": 2, 
      "description": "Vrednosti komponent spreminjamo s prireditvenim stavkom\r\n\r\n    x <- c(1, -3, 5, -7, 9, -11)\r\n    x[3] <- -5\r\n\r\nSpreminjamo lahko tudi ve\u010d vrednosti naenkrat\r\n\r\n    x[c(1, 5)] <- 2\r\n    x[c(2, 4)] <- c(60, 50)\r\n\r\nPrav tako lahko uporabljamo tudi imena\r\n\r\n    islands[\"Shikoku\"] <- 7\r\n\r\nSeveda imena lahko tudi popravljamo, vendar ne na najbolj o\u010diten na\u010din.\r\nSlede\u010di ukaz javi napako, saj vektor imen nima vektorja imen.\r\n(Zadnji stavek trikrat hitro izgovori.)\r\n\r\n    names(islands)[\"Celon\"] <- \"Ceylon\"\r\n\r\nNamesto tega moramo uporabljati logi\u010dne ali pa \u0161tevil\u010dne indekse\r\n\r\n    names(islands)[names(islands) == \"Celon\"] <- \"Ceylon\"\r\n    names(islands)[11] <- \"Ceylon\"", 
      "language": 1, 
      "title": "Spreminjanje komponent", 
      "timestamp": "2011-10-17 18:04:40", 
      "author": 1, 
      "problem_set": 5, 
      "preamble": ""
    }
  }, 
  {
    "pk": 27, 
    "model": "problem.problem", 
    "fields": {
      "_order": 2, 
      "description": "\nOglejte si video lekcijo [Urejanje z zlivanjem](http://vimeo.com/30670205).", 
      "language": 2, 
      "title": "Urejanje z zlivanjem", 
      "timestamp": "2011-10-20 08:55:04", 
      "author": 19, 
      "problem_set": 6, 
      "preamble": ""
    }
  }, 
  {
    "pk": 30, 
    "model": "problem.problem", 
    "fields": {
      "_order": 2, 
      "description": "", 
      "language": 2, 
      "title": "Seznami in tabele", 
      "timestamp": "2011-10-19 14:54:01", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 10, 
    "model": "problem.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Ena limona, dve limoni, \u2026", 
      "timestamp": "2011-10-13 12:57:34", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 31, 
    "model": "problem.problem", 
    "fields": {
      "_order": 3, 
      "description": "", 
      "language": 2, 
      "title": "Nizi", 
      "timestamp": "2011-10-19 14:54:01", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 32, 
    "model": "problem.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Zanke in pogojni stavki", 
      "timestamp": "2011-10-19 15:01:14", 
      "author": 19, 
      "problem_set": 7, 
      "preamble": ""
    }
  }, 
  {
    "pk": 18, 
    "model": "problem.problem", 
    "fields": {
      "_order": 4, 
      "description": "", 
      "language": 2, 
      "title": "Beseda je dala besedo", 
      "timestamp": "2011-10-12 12:24:26", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": ""
    }
  }, 
  {
    "pk": 19, 
    "model": "problem.problem", 
    "fields": {
      "_order": 5, 
      "description": "Permutacije v Pythonu lahko predstavimo s seznami naravnih \u0161tevil.\r\n\r\nNa primer, permutacijo, ki transponira \u0161tevili 1 in 3, 2 pa\r\npusti pri miru, zapi\u0161emo s seznamom `[3, 2, 1]`.", 
      "language": 2, 
      "title": "Permutacije", 
      "timestamp": "2011-10-13 13:38:06", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": "_perm = [100 - i for i in range(1, 100)]"
    }
  }, 
  {
    "pk": 20, 
    "model": "problem.problem", 
    "fields": {
      "_order": 6, 
      "description": "Na\u010deloma za predstavitev matrik v Pythonu uporabimo modul `array`,\r\na mi jih bomo predstavili kar s seznami seznamov.\r\n[Hilbertovo matriko](http://sl.wikipedia.org/wiki/Hilbertova_matrika)\r\nbi tako zapisali s seznamom `[[1, 1/2], [1/2, 1/3]]`.\r\n\r\nPredpostavite lahko, da imajo vse matrike vsaj en element in\r\nda imajo vsi podseznami enako dol\u017eino, ne smete pa predpostaviti,\r\nda so vse matrike kvadratne.", 
      "language": 2, 
      "title": "Matrike", 
      "timestamp": "2011-10-13 09:56:14", 
      "author": 1, 
      "problem_set": 2, 
      "preamble": "_mat = [[i ** 2 + 3 * j for i in range(8)] for j in range(8)]"
    }
  }
]